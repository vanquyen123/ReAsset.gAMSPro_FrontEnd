/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.15.0 (NJsonSchema v9.13.22.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AccountKTServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ACCOUNT_KT_Ins(body: CM_ACCOUNT_KT_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AccountKT/CM_ACCOUNT_KT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ACCOUNT_KT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ACCOUNT_KT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ACCOUNT_KT_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ACCOUNT_KT_Upd(body: CM_ACCOUNT_KT_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AccountKT/CM_ACCOUNT_KT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ACCOUNT_KT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ACCOUNT_KT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ACCOUNT_KT_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ACCOUNT_KT_Del(id: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AccountKT/CM_ACCOUNT_KT_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ACCOUNT_KT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ACCOUNT_KT_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ACCOUNT_KT_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_ACCOUNT_KT_Appr(id: string | undefined, currentUserName: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AccountKT/CM_ACCOUNT_KT_Appr?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ACCOUNT_KT_Appr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ACCOUNT_KT_Appr(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ACCOUNT_KT_Appr(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ACCOUNT_KT_Search(body: CM_ACCOUNT_KT_ENTITY | undefined): Observable<PagedResultDtoOfCM_ACCOUNT_KT_ENTITY> {
        let url_ = this.baseUrl + "/api/AccountKT/CM_ACCOUNT_KT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ACCOUNT_KT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ACCOUNT_KT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_ACCOUNT_KT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_ACCOUNT_KT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ACCOUNT_KT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_ACCOUNT_KT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_ACCOUNT_KT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_ACCOUNT_KT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_ACCOUNT_KT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ACCOUNT_KT_ById(id: string | undefined): Observable<CM_ACCOUNT_KT_ENTITY> {
        let url_ = this.baseUrl + "/api/AccountKT/CM_ACCOUNT_KT_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ACCOUNT_KT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ACCOUNT_KT_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_ACCOUNT_KT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ACCOUNT_KT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ACCOUNT_KT_ById(response: HttpResponseBase): Observable<CM_ACCOUNT_KT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ACCOUNT_KT_ENTITY.fromJS(resultData200) : new CM_ACCOUNT_KT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ACCOUNT_KT_ENTITY>(<any>null);
    }
}

@Injectable()
export class AllCodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param cdName (optional) 
     * @param cdType (optional) 
     * @return Success
     */
    cM_ALLCODE_GetByCDNAME(cdName: string | undefined, cdType: string | undefined): Observable<CM_ALLCODE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_GetByCDNAME?";
        if (cdName === null)
            throw new Error("The parameter 'cdName' cannot be null.");
        else if (cdName !== undefined)
            url_ += "cdName=" + encodeURIComponent("" + cdName) + "&"; 
        if (cdType === null)
            throw new Error("The parameter 'cdType' cannot be null.");
        else if (cdType !== undefined)
            url_ += "cdType=" + encodeURIComponent("" + cdType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_GetByCDNAME(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_GetByCDNAME(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_GetByCDNAME(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ALLCODE_Search(body: CM_ALLCODE_ENTITY | undefined): Observable<PagedResultDtoOfCM_ALLCODE_ENTITY> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_ALLCODE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_ALLCODE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_ALLCODE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_ALLCODE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_ALLCODE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_ALLCODE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ALLCODE_Ins(body: CM_ALLCODE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ALLCODE_Upd(body: CM_ALLCODE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ALLCODE_ById(id: number | undefined): Observable<CM_ALLCODE_ENTITY> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_ById(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ALLCODE_ENTITY.fromJS(resultData200) : new CM_ALLCODE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_ALLCODE_Del(id: number | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AllCode/CM_ALLCODE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ALLCODE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ALLCODE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ALLCODE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param cdName (optional) 
     * @param cdType (optional) 
     * @return Success
     */
    rEA_ALLCODE_GetByCDNAME(cdName: string | undefined, cdType: string | undefined): Observable<REA_ALLCODE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AllCode/REA_ALLCODE_GetByCDNAME?";
        if (cdName === null)
            throw new Error("The parameter 'cdName' cannot be null.");
        else if (cdName !== undefined)
            url_ += "cdName=" + encodeURIComponent("" + cdName) + "&"; 
        if (cdType === null)
            throw new Error("The parameter 'cdType' cannot be null.");
        else if (cdType !== undefined)
            url_ += "cdType=" + encodeURIComponent("" + cdType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_ALLCODE_GetByCDNAME(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_ALLCODE_GetByCDNAME(<any>response_);
                } catch (e) {
                    return <Observable<REA_ALLCODE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_ALLCODE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processREA_ALLCODE_GetByCDNAME(response: HttpResponseBase): Observable<REA_ALLCODE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(REA_ALLCODE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_ALLCODE_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_ALLCODE_Search(body: REA_ALLCODE_ENTITY | undefined): Observable<PagedResultDtoOfREA_ALLCODE_ENTITY> {
        let url_ = this.baseUrl + "/api/AllCode/REA_ALLCODE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_ALLCODE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_ALLCODE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_ALLCODE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_ALLCODE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_ALLCODE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_ALLCODE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_ALLCODE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_ALLCODE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_ALLCODE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_ALLCODE_Ins(body: REA_ALLCODE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/REA_ALLCODE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_ALLCODE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_ALLCODE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_ALLCODE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_ALLCODE_Upd(body: REA_ALLCODE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AllCode/REA_ALLCODE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_ALLCODE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_ALLCODE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_ALLCODE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_ALLCODE_ById(id: number | undefined): Observable<REA_ALLCODE_ENTITY> {
        let url_ = this.baseUrl + "/api/AllCode/REA_ALLCODE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_ALLCODE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_ALLCODE_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_ALLCODE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_ALLCODE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_ALLCODE_ById(response: HttpResponseBase): Observable<REA_ALLCODE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_ALLCODE_ENTITY.fromJS(resultData200) : new REA_ALLCODE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_ALLCODE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_ALLCODE_Del(id: number | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AllCode/REA_ALLCODE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_ALLCODE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_ALLCODE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_ALLCODE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class AppMenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllMenus(): Observable<AppMenuDto[]> {
        let url_ = this.baseUrl + "/api/AppMenu/GetAllMenus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMenus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMenus(<any>response_);
                } catch (e) {
                    return <Observable<AppMenuDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppMenuDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMenus(response: HttpResponseBase): Observable<AppMenuDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AppMenuDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppMenuDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_MENU_Search(body: TL_MENU_ENTITY | undefined): Observable<PagedResultDtoOfTL_MENU_ENTITY> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTL_MENU_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTL_MENU_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Search(response: HttpResponseBase): Observable<PagedResultDtoOfTL_MENU_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTL_MENU_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTL_MENU_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTL_MENU_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_MENU_Ins(body: TL_MENU_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_MENU_Upd(body: TL_MENU_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_MENU_ById(id: number | undefined): Observable<TL_MENU_ENTITY> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_ById(<any>response_);
                } catch (e) {
                    return <Observable<TL_MENU_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_MENU_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_ById(response: HttpResponseBase): Observable<TL_MENU_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_MENU_ENTITY.fromJS(resultData200) : new TL_MENU_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_MENU_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_MENU_Del(id: number | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    tL_MENU_App(id: number | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AppMenu/TL_MENU_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_MENU_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_MENU_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processTL_MENU_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class AppPermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAppPermissions(): Observable<FlatPermissionDto[]> {
        let url_ = this.baseUrl + "/api/AppPermission/GetAllAppPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppPermissions(<any>response_);
                } catch (e) {
                    return <Observable<FlatPermissionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FlatPermissionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAppPermissions(response: HttpResponseBase): Observable<FlatPermissionDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlatPermissionDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionDto[]>(<any>null);
    }
}

@Injectable()
export class AreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aREAS_Search(body: CM_AREAS_ENTITY | undefined): Observable<PagedResultDtoOfCM_AREAS_ENTITY> {
        let url_ = this.baseUrl + "/api/Area/AREAS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAREAS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAREAS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_AREAS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_AREAS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processAREAS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_AREAS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_AREAS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_AREAS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_AREAS_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aREA_Ins(body: CM_AREAS_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Area/AREA_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAREA_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAREA_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processAREA_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    aREA_Del(id: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Area/AREA_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAREA_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAREA_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processAREA_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    aREA_Upd(body: CM_AREAS_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Area/AREA_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAREA_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAREA_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processAREA_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    aREA_App(id: string | undefined, currentUserName: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Area/AREA_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAREA_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAREA_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processAREA_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    aREA_ByID(id: string | undefined): Observable<CM_AREAS_ENTITY> {
        let url_ = this.baseUrl + "/api/Area/AREA_ByID?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAREA_ByID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAREA_ByID(<any>response_);
                } catch (e) {
                    return <Observable<CM_AREAS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_AREAS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processAREA_ByID(response: HttpResponseBase): Observable<CM_AREAS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_AREAS_ENTITY.fromJS(resultData200) : new CM_AREAS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_AREAS_ENTITY>(<any>null);
    }
}

@Injectable()
export class AsposeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReport(body: ReportInfo | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReport(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReport(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReportMultiSheet(body: ReportInfo | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReportMultiSheet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportMultiSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportMultiSheet(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportMultiSheet(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReportFromHTML(body: ReportHtmlInfo | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReportFromHTML";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportFromHTML(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportFromHTML(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportFromHTML(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDataFromStore(body: ReportInfo | undefined): Observable<ReportTable[]> {
        let url_ = this.baseUrl + "/api/Aspose/GetDataFromStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataFromStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataFromStore(<any>response_);
                } catch (e) {
                    return <Observable<ReportTable[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReportTable[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataFromStore(response: HttpResponseBase): Observable<ReportTable[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReportTable.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReportTable[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReportCustomFomart(body: ReportInfo | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReportCustomFomart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportCustomFomart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportCustomFomart(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportCustomFomart(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getReport_BCKH_CustomFomart(body: ReportInfo | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Aspose/GetReport_BCKH_CustomFomart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReport_BCKH_CustomFomart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReport_BCKH_CustomFomart(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetReport_BCKH_CustomFomart(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getFileFromStore(body: ReportInfo | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Aspose/GetFileFromStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileFromStore(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileFromStore(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetFileFromStore(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class AttachFileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param refMaster (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_By_RefMaster(refMaster: string | undefined): Observable<CM_ATTACH_FILE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_By_RefMaster?";
        if (refMaster === null)
            throw new Error("The parameter 'refMaster' cannot be null.");
        else if (refMaster !== undefined)
            url_ += "refMaster=" + encodeURIComponent("" + refMaster) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_By_RefMaster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_By_RefMaster(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_By_RefMaster(response: HttpResponseBase): Observable<CM_ATTACH_FILE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_ATTACH_FILE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_ENTITY[]>(<any>null);
    }

    /**
     * @param refIds (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_By_RefId(refIds: string[] | undefined): Observable<CM_ATTACH_FILE_MODEL[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_By_RefId?";
        if (refIds === null)
            throw new Error("The parameter 'refIds' cannot be null.");
        else if (refIds !== undefined)
            refIds && refIds.forEach(item => { url_ += "refIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_By_RefId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_By_RefId(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_MODEL[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_MODEL[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_By_RefId(response: HttpResponseBase): Observable<CM_ATTACH_FILE_MODEL[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_ATTACH_FILE_MODEL.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_MODEL[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_Ins(body: CM_ATTACH_FILE_INPUT | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_ATTACH_FILE_Upd(body: CM_ATTACH_FILE_INPUT | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_ATTACH_FILE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_ATTACH_FILE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_ATTACH_FILE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_ATTACH_FILE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @return Success
     */
    testFile(): Observable<CM_ATTACH_FILE_ENTITY> {
        let url_ = this.baseUrl + "/api/AttachFile/TestFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestFile(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTestFile(response: HttpResponseBase): Observable<CM_ATTACH_FILE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ATTACH_FILE_ENTITY.fromJS(resultData200) : new CM_ATTACH_FILE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTmpFile(body: CM_ATTACH_FILE_INPUT | undefined): Observable<CM_ATTACH_FILE_INPUT> {
        let url_ = this.baseUrl + "/api/AttachFile/MoveTmpFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTmpFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTmpFile(<any>response_);
                } catch (e) {
                    return <Observable<CM_ATTACH_FILE_INPUT>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ATTACH_FILE_INPUT>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTmpFile(response: HttpResponseBase): Observable<CM_ATTACH_FILE_INPUT> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_ATTACH_FILE_INPUT.fromJS(resultData200) : new CM_ATTACH_FILE_INPUT();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ATTACH_FILE_INPUT>(<any>null);
    }

    /**
     * @param g (optional) 
     * @return Success
     */
    delete_g_path(g: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/AttachFile/Delete_g_path?";
        if (g === null)
            throw new Error("The parameter 'g' cannot be null.");
        else if (g !== undefined)
            url_ += "g=" + encodeURIComponent("" + g) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete_g_path(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete_g_path(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete_g_path(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param refId (optional) 
     * @param folderName (optional) 
     * @param body (optional) 
     * @return Success
     */
    uploadImageFiles(refId: string | undefined, folderName: string | undefined, body: CM_IMAGE_ENTITY[] | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AttachFile/UploadImageFiles?";
        if (refId === null)
            throw new Error("The parameter 'refId' cannot be null.");
        else if (refId !== undefined)
            url_ += "refId=" + encodeURIComponent("" + refId) + "&"; 
        if (folderName === null)
            throw new Error("The parameter 'folderName' cannot be null.");
        else if (folderName !== undefined)
            url_ += "folderName=" + encodeURIComponent("" + folderName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImageFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImageFiles(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImageFiles(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param ref_id (optional) 
     * @return Success
     */
    cM_IMAGE_ByRefId(ref_id: string | undefined): Observable<CM_IMAGE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_IMAGE_ByRefId?";
        if (ref_id === null)
            throw new Error("The parameter 'ref_id' cannot be null.");
        else if (ref_id !== undefined)
            url_ += "ref_id=" + encodeURIComponent("" + ref_id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_IMAGE_ByRefId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_IMAGE_ByRefId(<any>response_);
                } catch (e) {
                    return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_IMAGE_ByRefId(response: HttpResponseBase): Observable<CM_IMAGE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_IMAGE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_IMAGE_ENTITY[]>(<any>null);
    }

    /**
     * @param ass_code (optional) 
     * @return Success
     */
    cM_IMAGE_ByAssCode(ass_code: string | undefined): Observable<CM_IMAGE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_IMAGE_ByAssCode?";
        if (ass_code === null)
            throw new Error("The parameter 'ass_code' cannot be null.");
        else if (ass_code !== undefined)
            url_ += "ass_code=" + encodeURIComponent("" + ass_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_IMAGE_ByAssCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_IMAGE_ByAssCode(<any>response_);
                } catch (e) {
                    return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_IMAGE_ByAssCode(response: HttpResponseBase): Observable<CM_IMAGE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_IMAGE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_IMAGE_ENTITY[]>(<any>null);
    }

    /**
     * @param assId (optional) 
     * @param iNVENTORY_DT (optional) 
     * @return Success
     */
    cM_IMAGE_GetNearAsset(assId: string | undefined, iNVENTORY_DT: moment.Moment | undefined): Observable<CM_IMAGE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_IMAGE_GetNearAsset?";
        if (assId === null)
            throw new Error("The parameter 'assId' cannot be null.");
        else if (assId !== undefined)
            url_ += "assId=" + encodeURIComponent("" + assId) + "&"; 
        if (iNVENTORY_DT === null)
            throw new Error("The parameter 'iNVENTORY_DT' cannot be null.");
        else if (iNVENTORY_DT !== undefined)
            url_ += "INVENTORY_DT=" + encodeURIComponent(iNVENTORY_DT ? "" + iNVENTORY_DT.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_IMAGE_GetNearAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_IMAGE_GetNearAsset(<any>response_);
                } catch (e) {
                    return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_IMAGE_GetNearAsset(response: HttpResponseBase): Observable<CM_IMAGE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_IMAGE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_IMAGE_ENTITY[]>(<any>null);
    }

    /**
     * @param assId (optional) 
     * @param iNVENTORY_DT (optional) 
     * @return Success
     */
    cM_IMAGE_GetFirstAsset(assId: string | undefined, iNVENTORY_DT: moment.Moment | undefined): Observable<CM_IMAGE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/AttachFile/CM_IMAGE_GetFirstAsset?";
        if (assId === null)
            throw new Error("The parameter 'assId' cannot be null.");
        else if (assId !== undefined)
            url_ += "assId=" + encodeURIComponent("" + assId) + "&"; 
        if (iNVENTORY_DT === null)
            throw new Error("The parameter 'iNVENTORY_DT' cannot be null.");
        else if (iNVENTORY_DT !== undefined)
            url_ += "INVENTORY_DT=" + encodeURIComponent(iNVENTORY_DT ? "" + iNVENTORY_DT.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_IMAGE_GetFirstAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_IMAGE_GetFirstAsset(<any>response_);
                } catch (e) {
                    return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_IMAGE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_IMAGE_GetFirstAsset(response: HttpResponseBase): Observable<CM_IMAGE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_IMAGE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_IMAGE_ENTITY[]>(<any>null);
    }

    /**
     * @param image_path (optional) 
     * @param image_name (optional) 
     * @return Success
     */
    getImage(image_path: string | undefined, image_name: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/AttachFile/GetImage?";
        if (image_path === null)
            throw new Error("The parameter 'image_path' cannot be null.");
        else if (image_path !== undefined)
            url_ += "image_path=" + encodeURIComponent("" + image_path) + "&"; 
        if (image_name === null)
            throw new Error("The parameter 'image_name' cannot be null.");
        else if (image_name !== undefined)
            url_ += "image_name=" + encodeURIComponent("" + image_name) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImage(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetImage(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | undefined, entityId: string | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    ressetPermission(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/RessetPermission";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRessetPermission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRessetPermission(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRessetPermission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuthorizedPersonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_Search(body: REA_AUTHORIZED_PERSON_ENTITY | undefined): Observable<PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_Ins(body: REA_AUTHORIZED_PERSON_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_Upd(body: REA_AUTHORIZED_PERSON_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_ById(id: string | undefined): Observable<REA_AUTHORIZED_PERSON_ENTITY> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_AUTHORIZED_PERSON_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_AUTHORIZED_PERSON_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_ById(response: HttpResponseBase): Observable<REA_AUTHORIZED_PERSON_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_AUTHORIZED_PERSON_ENTITY.fromJS(resultData200) : new REA_AUTHORIZED_PERSON_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_AUTHORIZED_PERSON_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    rEA_AUTHORIZED_PEOPLE_Get_Id(): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/AuthorizedPerson/REA_AUTHORIZED_PEOPLE_Get_Id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_AUTHORIZED_PEOPLE_Get_Id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_AUTHORIZED_PEOPLE_Get_Id(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREA_AUTHORIZED_PEOPLE_Get_Id(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class BranchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cM_BRANCH_Combobox(): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Combobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Combobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Combobox(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Combobox(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_Search(body: CM_BRANCH_ENTITY | undefined): Observable<PagedResultDtoOfCM_BRANCH_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_BRANCH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_BRANCH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_BRANCH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_BRANCH_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_BRANCH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_BRANCH_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_GetAll(body: CM_BRANCH_ENTITY | undefined): Observable<PagedResultDtoOfCM_BRANCH_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_GetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_GetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_BRANCH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_BRANCH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_GetAll(response: HttpResponseBase): Observable<PagedResultDtoOfCM_BRANCH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_BRANCH_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_BRANCH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_BRANCH_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_ToExcel(body: CM_BRANCH_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_Ins(body: CM_BRANCH_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_Upd(body: CM_BRANCH_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_BRANCH_ById(id: string | undefined): Observable<CM_BRANCH_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_ById(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_BRANCH_ENTITY.fromJS(resultData200) : new CM_BRANCH_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY>(<any>null);
    }

    /**
     * @param regionId (optional) 
     * @param branchType (optional) 
     * @return Success
     */
    cM_BRANCH_GetFatherList(regionId: string | undefined, branchType: string | undefined): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_GetFatherList?";
        if (regionId === null)
            throw new Error("The parameter 'regionId' cannot be null.");
        else if (regionId !== undefined)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&"; 
        if (branchType === null)
            throw new Error("The parameter 'branchType' cannot be null.");
        else if (branchType !== undefined)
            url_ += "branchType=" + encodeURIComponent("" + branchType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_GetFatherList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_GetFatherList(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_GetFatherList(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_BRANCH_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_BRANCH_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param branchId (optional) 
     * @return Success
     */
    cM_BRANCH_Lev(branchId: string | undefined): Observable<CM_BRANCH_LEV_ENTITY> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_Lev?";
        if (branchId === null)
            throw new Error("The parameter 'branchId' cannot be null.");
        else if (branchId !== undefined)
            url_ += "branchId=" + encodeURIComponent("" + branchId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_Lev(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_Lev(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_LEV_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_LEV_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_Lev(response: HttpResponseBase): Observable<CM_BRANCH_LEV_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_BRANCH_LEV_ENTITY.fromJS(resultData200) : new CM_BRANCH_LEV_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_LEV_ENTITY>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    cM_BRANCH_GetAllChild(parentId: string | undefined): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_GetAllChild?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_GetAllChild(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_GetAllChild(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_GetAllChild(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getListData(body: any | undefined): Observable<{ [key: string] : number[][]; }> {
        let url_ = this.baseUrl + "/api/Branch/GetListData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListData(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : number[][]; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : number[][]; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetListData(response: HttpResponseBase): Observable<{ [key: string] : number[][]; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : number[][]; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_User_Search(body: CM_BRANCH_ENTITY | undefined): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_User_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_User_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_User_Search(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_User_Search(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_DEP_User_Search(body: CM_BRANCH_ENTITY | undefined): Observable<CM_BRANCH_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Branch/CM_BRANCH_DEP_User_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_DEP_User_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_DEP_User_Search(<any>response_);
                } catch (e) {
                    return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_BRANCH_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_DEP_User_Search(response: HttpResponseBase): Observable<CM_BRANCH_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_BRANCH_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class BranchHDServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_BRANCH_GET_ALL_HD(body: ExecQueryDto | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/BranchHD/CM_BRANCH_GET_ALL_HD";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_BRANCH_GET_ALL_HD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_BRANCH_GET_ALL_HD(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCM_BRANCH_GET_ALL_HD(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearPermissionAndRole(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearPermissionAndRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearPermissionAndRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearPermissionAndRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearPermissionAndRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearTmpFolderUpload(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearTmpFolderUpload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearTmpFolderUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearTmpFolderUpload(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearTmpFolderUpload(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CarTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Search(body: CM_CAR_TYPE_ENTITY | undefined): Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_CAR_TYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_CAR_TYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_CAR_TYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_CAR_TYPE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_CAR_TYPE_ToExcel(body: CM_CAR_TYPE_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Ins(body: CM_CAR_TYPE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Upd(body: CM_CAR_TYPE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_CAR_TYPE_List(body: CM_CAR_TYPE_ENTITY | undefined): Observable<CM_CAR_TYPE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_List(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_List(<any>response_);
                } catch (e) {
                    return <Observable<CM_CAR_TYPE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_CAR_TYPE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_List(response: HttpResponseBase): Observable<CM_CAR_TYPE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_CAR_TYPE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_CAR_TYPE_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_CAR_TYPE_ById(id: string | undefined): Observable<CM_CAR_TYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_CAR_TYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_CAR_TYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_ById(response: HttpResponseBase): Observable<CM_CAR_TYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_CAR_TYPE_ENTITY.fromJS(resultData200) : new CM_CAR_TYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_CAR_TYPE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_CAR_TYPE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_CAR_TYPE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/CarType/CM_CAR_TYPE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_CAR_TYPE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_CAR_TYPE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_CAR_TYPE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | undefined, userId: number | undefined, minMessageId: number | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId === null)
            throw new Error("The parameter 'minMessageId' cannot be null.");
        else if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CmUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tLUSER_GETBY_BRANCHID(body: TLUSER_GETBY_BRANCHID_ENTITY | undefined): Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY> {
        let url_ = this.baseUrl + "/api/CmUser/TLUSER_GETBY_BRANCHID";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTLUSER_GETBY_BRANCHID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTLUSER_GETBY_BRANCHID(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTLUSER_GETBY_BRANCHID(response: HttpResponseBase): Observable<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ContractServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_CONTRACT_Ins(body: REA_CONTRACT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_CONTRACT_Upd(body: REA_CONTRACT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_CONTRACT_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_CONTRACT_Search(body: REA_CONTRACT_ENTITY | undefined): Observable<PagedResultDtoOfREA_CONTRACT_ENTITY> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_CONTRACT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_CONTRACT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_CONTRACT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_CONTRACT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_CONTRACT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_CONTRACT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_CONTRACT_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_CONTRACT_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_CONTRACT_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_CONTRACT_ById(id: string | undefined): Observable<REA_CONTRACT_ENTITY> {
        let url_ = this.baseUrl + "/api/Contract/REA_CONTRACT_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_CONTRACT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_CONTRACT_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_CONTRACT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_CONTRACT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_CONTRACT_ById(response: HttpResponseBase): Observable<REA_CONTRACT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_CONTRACT_ENTITY.fromJS(resultData200) : new REA_CONTRACT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_CONTRACT_ENTITY>(<any>null);
    }
}

@Injectable()
export class DashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDashboardData(body: DashboarDto | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/Dashboard/GetDashboardData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getInvestTable(body: { [key: string] : any; } | undefined): Observable<InvestChartDto[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetInvestTable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestTable(<any>response_);
                } catch (e) {
                    return <Observable<InvestChartDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvestChartDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvestTable(response: HttpResponseBase): Observable<InvestChartDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvestChartDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvestChartDto[]>(<any>null);
    }

    /**
     * @param userLogin (optional) 
     * @param toDay (optional) 
     * @return Success
     */
    getValue_Dashboard_01(userLogin: string | undefined, toDay: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Dashboard/GetValue_Dashboard_01?";
        if (userLogin === null)
            throw new Error("The parameter 'userLogin' cannot be null.");
        else if (userLogin !== undefined)
            url_ += "userLogin=" + encodeURIComponent("" + userLogin) + "&"; 
        if (toDay === null)
            throw new Error("The parameter 'toDay' cannot be null.");
        else if (toDay !== undefined)
            url_ += "toDay=" + encodeURIComponent("" + toDay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValue_Dashboard_01(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValue_Dashboard_01(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetValue_Dashboard_01(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param userLogin (optional) 
     * @param toDay (optional) 
     * @return Success
     */
    getValue_Dashboard_02(userLogin: string | undefined, toDay: string | undefined): Observable<DASBOARD_02[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetValue_Dashboard_02?";
        if (userLogin === null)
            throw new Error("The parameter 'userLogin' cannot be null.");
        else if (userLogin !== undefined)
            url_ += "userLogin=" + encodeURIComponent("" + userLogin) + "&"; 
        if (toDay === null)
            throw new Error("The parameter 'toDay' cannot be null.");
        else if (toDay !== undefined)
            url_ += "toDay=" + encodeURIComponent("" + toDay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValue_Dashboard_02(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValue_Dashboard_02(<any>response_);
                } catch (e) {
                    return <Observable<DASBOARD_02[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DASBOARD_02[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetValue_Dashboard_02(response: HttpResponseBase): Observable<DASBOARD_02[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DASBOARD_02.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DASBOARD_02[]>(<any>null);
    }

    /**
     * @param userLogin (optional) 
     * @param toDay (optional) 
     * @return Success
     */
    getValue_Dashboard_03(userLogin: string | undefined, toDay: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Dashboard/GetValue_Dashboard_03?";
        if (userLogin === null)
            throw new Error("The parameter 'userLogin' cannot be null.");
        else if (userLogin !== undefined)
            url_ += "userLogin=" + encodeURIComponent("" + userLogin) + "&"; 
        if (toDay === null)
            throw new Error("The parameter 'toDay' cannot be null.");
        else if (toDay !== undefined)
            url_ += "toDay=" + encodeURIComponent("" + toDay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValue_Dashboard_03(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValue_Dashboard_03(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processGetValue_Dashboard_03(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param userLogin (optional) 
     * @param toDay (optional) 
     * @return Success
     */
    getValue_Dashboard_05(userLogin: string | undefined, toDay: string | undefined): Observable<DASBOARD_05[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetValue_Dashboard_05?";
        if (userLogin === null)
            throw new Error("The parameter 'userLogin' cannot be null.");
        else if (userLogin !== undefined)
            url_ += "userLogin=" + encodeURIComponent("" + userLogin) + "&"; 
        if (toDay === null)
            throw new Error("The parameter 'toDay' cannot be null.");
        else if (toDay !== undefined)
            url_ += "toDay=" + encodeURIComponent("" + toDay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValue_Dashboard_05(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValue_Dashboard_05(<any>response_);
                } catch (e) {
                    return <Observable<DASBOARD_05[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DASBOARD_05[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetValue_Dashboard_05(response: HttpResponseBase): Observable<DASBOARD_05[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DASBOARD_05.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DASBOARD_05[]>(<any>null);
    }

    /**
     * @param userLogin (optional) 
     * @param toDay (optional) 
     * @return Success
     */
    getValue_Dashboard_06(userLogin: string | undefined, toDay: string | undefined): Observable<DASBOARD_06[]> {
        let url_ = this.baseUrl + "/api/Dashboard/GetValue_Dashboard_06?";
        if (userLogin === null)
            throw new Error("The parameter 'userLogin' cannot be null.");
        else if (userLogin !== undefined)
            url_ += "userLogin=" + encodeURIComponent("" + userLogin) + "&"; 
        if (toDay === null)
            throw new Error("The parameter 'toDay' cannot be null.");
        else if (toDay !== undefined)
            url_ += "toDay=" + encodeURIComponent("" + toDay) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValue_Dashboard_06(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValue_Dashboard_06(<any>response_);
                } catch (e) {
                    return <Observable<DASBOARD_06[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DASBOARD_06[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetValue_Dashboard_06(response: HttpResponseBase): Observable<DASBOARD_06[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DASBOARD_06.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DASBOARD_06[]>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class DepartmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subbrId (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Combobox(subbrId: string | undefined): Observable<CM_DEPARTMENT_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Combobox?";
        if (subbrId === null)
            throw new Error("The parameter 'subbrId' cannot be null.");
        else if (subbrId !== undefined)
            url_ += "subbrId=" + encodeURIComponent("" + subbrId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Combobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Combobox(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPARTMENT_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPARTMENT_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Combobox(response: HttpResponseBase): Observable<CM_DEPARTMENT_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_DEPARTMENT_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPARTMENT_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Search(body: CM_DEPARTMENT_ENTITY | undefined): Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DEPARTMENT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DEPARTMENT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DEPARTMENT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DEPARTMENT_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPARTMENT_ToExcel(body: CM_DEPARTMENT_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Ins(body: CM_DEPARTMENT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Upd(body: CM_DEPARTMENT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPARTMENT_ById(id: string | undefined): Observable<CM_DEPARTMENT_ENTITY> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPARTMENT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPARTMENT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_ById(response: HttpResponseBase): Observable<CM_DEPARTMENT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DEPARTMENT_ENTITY.fromJS(resultData200) : new CM_DEPARTMENT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPARTMENT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPARTMENT_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_DEPARTMENT_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param bRANCH_ID (optional) 
     * @param uSER_LOGIN (optional) 
     * @return Success
     */
    cM_DEPARTMENT_By_BRANCH_ID(bRANCH_ID: string | undefined, uSER_LOGIN: string | undefined): Observable<CM_DEPARTMENT_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Department/CM_DEPARTMENT_By_BRANCH_ID?";
        if (bRANCH_ID === null)
            throw new Error("The parameter 'bRANCH_ID' cannot be null.");
        else if (bRANCH_ID !== undefined)
            url_ += "BRANCH_ID=" + encodeURIComponent("" + bRANCH_ID) + "&"; 
        if (uSER_LOGIN === null)
            throw new Error("The parameter 'uSER_LOGIN' cannot be null.");
        else if (uSER_LOGIN !== undefined)
            url_ += "USER_LOGIN=" + encodeURIComponent("" + uSER_LOGIN) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPARTMENT_By_BRANCH_ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPARTMENT_By_BRANCH_ID(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPARTMENT_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPARTMENT_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPARTMENT_By_BRANCH_ID(response: HttpResponseBase): Observable<CM_DEPARTMENT_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_DEPARTMENT_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPARTMENT_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class DeptGroupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Search(body: CM_DEPT_GROUP_ENTITY | undefined): Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DEPT_GROUP_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DEPT_GROUP_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DEPT_GROUP_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DEPT_GROUP_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_ToExcel(body: CM_DEPT_GROUP_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Ins(body: CM_DEPT_GROUP_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Upd(body: CM_DEPT_GROUP_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_ById(id: string | undefined): Observable<CM_DEPT_GROUP_ENTITY> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DEPT_GROUP_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DEPT_GROUP_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_ById(response: HttpResponseBase): Observable<CM_DEPT_GROUP_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DEPT_GROUP_ENTITY.fromJS(resultData200) : new CM_DEPT_GROUP_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DEPT_GROUP_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_DEPT_GROUP_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/DeptGroup/CM_DEPT_GROUP_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DEPT_GROUP_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DEPT_GROUP_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DEPT_GROUP_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class DivisionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DIVISION_Search(body: CM_DIVISION_ENTITY | undefined): Observable<PagedResultDtoOfCM_DIVISION_ENTITY> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_DIVISION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_DIVISION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_DIVISION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_DIVISION_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_DIVISION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_DIVISION_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DIVISION_ToExcel(body: CM_DIVISION_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DIVISION_Ins(body: CM_DIVISION_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_DIVISION_Upd(body: CM_DIVISION_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DIVISION_ById(id: string | undefined): Observable<CM_DIVISION_ENTITY> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_DIVISION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DIVISION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_ById(response: HttpResponseBase): Observable<CM_DIVISION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_DIVISION_ENTITY.fromJS(resultData200) : new CM_DIVISION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DIVISION_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_DIVISION_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_DIVISION_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param parentId (optional) 
     * @return Success
     */
    cM_DIVISION_GETALLCHILD(parentId: string | undefined): Observable<CM_DIVISION_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Division/CM_DIVISION_GETALLCHILD?";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_DIVISION_GETALLCHILD(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_DIVISION_GETALLCHILD(<any>response_);
                } catch (e) {
                    return <Observable<CM_DIVISION_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_DIVISION_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_DIVISION_GETALLCHILD(response: HttpResponseBase): Observable<CM_DIVISION_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_DIVISION_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_DIVISION_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Search(body: CM_EMPLOYEE_ENTITY | undefined): Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_EMPLOYEE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_EMPLOYEE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_EMPLOYEE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_EMPLOYEE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Ins(body: CM_EMPLOYEE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Upd(body: CM_EMPLOYEE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_EMPLOYEE_ById(id: string | undefined): Observable<CM_EMPLOYEE_ENTITY> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_EMPLOYEE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_EMPLOYEE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_ById(response: HttpResponseBase): Observable<CM_EMPLOYEE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_EMPLOYEE_ENTITY.fromJS(resultData200) : new CM_EMPLOYEE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_EMPLOYEE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_EMPLOYEE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Ins_Mul(body: CM_EMPLOYEE_ENTITY[] | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Ins_Mul";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Ins_Mul(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Ins_Mul(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Ins_Mul(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Upd_Mul(body: CM_EMPLOYEE_ENTITY[] | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Upd_Mul";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Upd_Mul(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Upd_Mul(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Upd_Mul(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    cM_EMPLOYEE_Del_Mul(ids: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Employee/CM_EMPLOYEE_Del_Mul?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_EMPLOYEE_Del_Mul(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_EMPLOYEE_Del_Mul(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_EMPLOYEE_Del_Mul(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(body: CreateFriendshipRequestByUserNameInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GoodsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODS_Search(body: CM_GOODS_ENTITY | undefined): Observable<PagedResultDtoOfCM_GOODS_ENTITY> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODS_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODS_ToExcel(body: CM_GOODS_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODS_Ins(body: CM_GOODS_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODS_Upd(body: CM_GOODS_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODS_ById(id: string | undefined): Observable<CM_GOODS_ENTITY> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_GOODS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_GOODS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_ById(response: HttpResponseBase): Observable<CM_GOODS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_GOODS_ENTITY.fromJS(resultData200) : new CM_GOODS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_GOODS_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODS_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_GOODS_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Goods/CM_GOODS_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODS_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODS_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODS_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class GoodsTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Search(body: CM_GOODSTYPE_ENTITY | undefined): Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODSTYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODSTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODSTYPE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_KH_Search(body: CM_GOODSTYPE_ENTITY | undefined): Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_KH_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_KH_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_KH_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_KH_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODSTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODSTYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODSTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODSTYPE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Ins(body: CM_GOODSTYPE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Upd(body: CM_GOODSTYPE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_ById(id: string | undefined): Observable<CM_GOODSTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_GOODSTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_GOODSTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_ById(response: HttpResponseBase): Observable<CM_GOODSTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_GOODSTYPE_ENTITY.fromJS(resultData200) : new CM_GOODSTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_GOODSTYPE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_GOODSTYPE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/GoodsType/CM_GOODSTYPE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    getConnectionStringDecryption(): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsType/GetConnectionStringDecryption";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConnectionStringDecryption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConnectionStringDecryption(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetConnectionStringDecryption(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    getSampleConfig(key: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsType/GetSampleConfig?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSampleConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSampleConfig(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSampleConfig(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getClientIpAddress(): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsType/GetClientIpAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientIpAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientIpAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientIpAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class GoodsTypeRealServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Search(body: CM_GOODSTYPE_REAL_ENTITY | undefined): Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_ToExcel(body: CM_GOODSTYPE_REAL_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Ins(body: CM_GOODSTYPE_REAL_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Upd(body: CM_GOODSTYPE_REAL_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_ById(id: string | undefined): Observable<CM_GOODSTYPE_REAL_ENTITY> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_GOODSTYPE_REAL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_ById(response: HttpResponseBase): Observable<CM_GOODSTYPE_REAL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_GOODSTYPE_REAL_ENTITY.fromJS(resultData200) : new CM_GOODSTYPE_REAL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_GOODSTYPE_REAL_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Del(id: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_GOODSTYPE_REAL_Appr(id: string | undefined, currentUserName: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/CM_GOODSTYPE_REAL_Appr?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_GOODSTYPE_REAL_Appr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_GOODSTYPE_REAL_Appr(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_GOODSTYPE_REAL_Appr(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    getClientIpAddress(): Observable<string> {
        let url_ = this.baseUrl + "/api/GoodsTypeReal/GetClientIpAddress";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientIpAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientIpAddress(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientIpAddress(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<HostSettingResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<HostSettingResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingResultDto.fromJS(resultData200) : new HostSettingResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ImageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uploadImageFile(body: FileUploadDto | undefined): Observable<FileUploadDto> {
        let url_ = this.baseUrl + "/api/Image/UploadImageFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImageFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImageFile(<any>response_);
                } catch (e) {
                    return <Observable<FileUploadDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileUploadDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImageFile(response: HttpResponseBase): Observable<FileUploadDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileUploadDto.fromJS(resultData200) : new FileUploadDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileUploadDto>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InsuCompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Search(body: CM_INSU_COMPANY_ENTITY | undefined): Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_INSU_COMPANY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_INSU_COMPANY_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_INSU_COMPANY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_INSU_COMPANY_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Ins(body: CM_INSU_COMPANY_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Upd(body: CM_INSU_COMPANY_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_ById(id: string | undefined): Observable<CM_INSU_COMPANY_ENTITY> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_INSU_COMPANY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_INSU_COMPANY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_ById(response: HttpResponseBase): Observable<CM_INSU_COMPANY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_INSU_COMPANY_ENTITY.fromJS(resultData200) : new CM_INSU_COMPANY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_INSU_COMPANY_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_INSU_COMPANY_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InsuCompany/CM_INSU_COMPANY_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_INSU_COMPANY_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_INSU_COMPANY_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_INSU_COMPANY_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class InvestmentPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_Ins(body: REA_INVESTMENT_PROPERTY_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_Upd(body: REA_INVESTMENT_PROPERTY_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_Search(body: REA_INVESTMENT_PROPERTY_ENTITY | undefined): Observable<PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_INVESTMENT_PROPERTY_ById(id: string | undefined): Observable<REA_INVESTMENT_PROPERTY_ENTITY> {
        let url_ = this.baseUrl + "/api/InvestmentProperty/REA_INVESTMENT_PROPERTY_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_INVESTMENT_PROPERTY_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_INVESTMENT_PROPERTY_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_INVESTMENT_PROPERTY_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_INVESTMENT_PROPERTY_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_INVESTMENT_PROPERTY_ById(response: HttpResponseBase): Observable<REA_INVESTMENT_PROPERTY_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_INVESTMENT_PROPERTY_ENTITY.fromJS(resultData200) : new REA_INVESTMENT_PROPERTY_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_INVESTMENT_PROPERTY_ENTITY>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class KhoiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_KHOI_Search(body: CM_KHOI_ENTITY | undefined): Observable<PagedResultDtoOfCM_KHOI_ENTITY> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_KHOI_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_KHOI_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_KHOI_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_KHOI_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_KHOI_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_KHOI_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_KHOI_Ins(body: CM_KHOI_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_KHOI_Upd(body: CM_KHOI_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_KHOI_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_KHOI_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_KHOI_ById(id: string | undefined): Observable<CM_KHOI_ENTITY> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_KHOI_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_KHOI_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_ById(response: HttpResponseBase): Observable<CM_KHOI_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_KHOI_ENTITY.fromJS(resultData200) : new CM_KHOI_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_KHOI_ENTITY>(<any>null);
    }

    /**
     * @return Success
     */
    cM_KHOI_Lst(): Observable<CM_KHOI_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_Lst";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_Lst(<any>response_);
                } catch (e) {
                    return <Observable<CM_KHOI_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_KHOI_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_Lst(response: HttpResponseBase): Observable<CM_KHOI_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_KHOI_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_KHOI_ENTITY[]>(<any>null);
    }

    /**
     * @return Success
     */
    cM_KHOI_DT_Lst(): Observable<CM_KHOI_DT_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_DT_Lst";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_DT_Lst(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_DT_Lst(<any>response_);
                } catch (e) {
                    return <Observable<CM_KHOI_DT_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_KHOI_DT_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_DT_Lst(response: HttpResponseBase): Observable<CM_KHOI_DT_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_KHOI_DT_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_KHOI_DT_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_KHOI_DT_Search(body: CM_KHOI_DT_ENTITY | undefined): Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY> {
        let url_ = this.baseUrl + "/api/Khoi/CM_KHOI_DT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_KHOI_DT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_KHOI_DT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_KHOI_DT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_KHOI_DT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_KHOI_DT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_KHOI_DT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_KHOI_DT_ENTITY>(<any>null);
    }
}

@Injectable()
export class LandAreaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_LAND_AREA_Ins(body: REA_LAND_AREA_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_LAND_AREA_Upd(body: REA_LAND_AREA_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_LAND_AREA_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_LAND_AREA_Search(body: REA_LAND_AREA_ENTITY | undefined): Observable<PagedResultDtoOfREA_LAND_AREA_ENTITY> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_LAND_AREA_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_LAND_AREA_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_LAND_AREA_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_LAND_AREA_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_LAND_AREA_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_LAND_AREA_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_LAND_AREA_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_LAND_AREA_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_LAND_AREA_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_LAND_AREA_ById(id: string | undefined): Observable<REA_LAND_AREA_ENTITY> {
        let url_ = this.baseUrl + "/api/LandArea/REA_LAND_AREA_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_LAND_AREA_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_LAND_AREA_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_LAND_AREA_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_LAND_AREA_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_LAND_AREA_ById(response: HttpResponseBase): Observable<REA_LAND_AREA_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_LAND_AREA_ENTITY.fromJS(resultData200) : new REA_LAND_AREA_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_LAND_AREA_ENTITY>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param key (optional) 
     * @return Success
     */
    deleteLanguageText(key: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguageText?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, filterText: string | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    cM_LOCATION_AllData(): Observable<CM_LOCATION_ENTITY> {
        let url_ = this.baseUrl + "/api/Location/CM_LOCATION_AllData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_LOCATION_AllData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_LOCATION_AllData(<any>response_);
                } catch (e) {
                    return <Observable<CM_LOCATION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_LOCATION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_LOCATION_AllData(response: HttpResponseBase): Observable<CM_LOCATION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_LOCATION_ENTITY.fromJS(resultData200) : new CM_LOCATION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_LOCATION_ENTITY>(<any>null);
    }
}

@Injectable()
export class MobileAuthenticationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    ldapAuthenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/MobileAuthentication/LdapAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLdapAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLdapAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLdapAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    normalAuthenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/MobileAuthentication/NormalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNormalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNormalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processNormalAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param provider (optional) 
     * @param returnUrl (optional) 
     * @param ss (optional) 
     * @return Success
     */
    externalLogin(provider: string | undefined, returnUrl: string | undefined, ss: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MobileAuthentication/ExternalLogin?";
        if (provider === null)
            throw new Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&"; 
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (ss === null)
            throw new Error("The parameter 'ss' cannot be null.");
        else if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @param ss (optional) 
     * @return Success
     */
    loginAdfs(returnUrl: string | undefined, ss: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MobileAuthentication/LoginAdfs?";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (ss === null)
            throw new Error("The parameter 'ss' cannot be null.");
        else if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginAdfs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginAdfs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLoginAdfs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @param remoteError (optional) 
     * @param ss (optional) 
     * @return Success
     */
    externalLoginCallback(returnUrl: string | undefined, remoteError: string | undefined, ss: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MobileAuthentication/ExternalLoginCallback?";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (remoteError === null)
            throw new Error("The parameter 'remoteError' cannot be null.");
        else if (remoteError !== undefined)
            url_ += "remoteError=" + encodeURIComponent("" + remoteError) + "&"; 
        if (ss === null)
            throw new Error("The parameter 'ss' cannot be null.");
        else if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLoginCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLoginCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLoginCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    signOutAdfs(): Observable<string> {
        let url_ = this.baseUrl + "/api/MobileAuthentication/SignOutAdfs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOutAdfs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOutAdfs(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSignOutAdfs(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class ModelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_MODEL_Search(body: CM_MODEL_ENTITY | undefined): Observable<PagedResultDtoOfCM_MODEL_ENTITY> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_MODEL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_MODEL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_MODEL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_MODEL_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_MODEL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_MODEL_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_MODEL_Ins(body: CM_MODEL_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_MODEL_Upd(body: CM_MODEL_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_MODEL_ById(id: string | undefined): Observable<CM_MODEL_ENTITY> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_MODEL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_MODEL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_ById(response: HttpResponseBase): Observable<CM_MODEL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_MODEL_ENTITY.fromJS(resultData200) : new CM_MODEL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_MODEL_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_MODEL_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_MODEL_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Model/CM_MODEL_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MODEL_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MODEL_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MODEL_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class MortgageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_MORTGAGE_Ins(body: REA_MORTGAGE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_MORTGAGE_Upd(body: REA_MORTGAGE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_MORTGAGE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_MORTGAGE_Search(body: REA_MORTGAGE_ENTITY | undefined): Observable<PagedResultDtoOfREA_MORTGAGE_ENTITY> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_MORTGAGE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_MORTGAGE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_MORTGAGE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_MORTGAGE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_MORTGAGE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_MORTGAGE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_MORTGAGE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_MORTGAGE_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_MORTGAGE_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_MORTGAGE_ById(id: string | undefined): Observable<REA_MORTGAGE_ENTITY> {
        let url_ = this.baseUrl + "/api/Mortgage/REA_MORTGAGE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_MORTGAGE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_MORTGAGE_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_MORTGAGE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_MORTGAGE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_MORTGAGE_ById(response: HttpResponseBase): Observable<REA_MORTGAGE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_MORTGAGE_ENTITY.fromJS(resultData200) : new REA_MORTGAGE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_MORTGAGE_ENTITY>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param state (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getUserNotificationsWithNotifications(tenantId: number | undefined, userId: number | undefined, state: UserNotificationState | undefined, skipCount: number | undefined, maxResultCount: number | undefined, startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<UserNotificationInfoWithNotificationInfo[]> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotificationsWithNotifications?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotificationsWithNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotificationsWithNotifications(<any>response_);
                } catch (e) {
                    return <Observable<UserNotificationInfoWithNotificationInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserNotificationInfoWithNotificationInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotificationsWithNotifications(response: HttpResponseBase): Observable<UserNotificationInfoWithNotificationInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserNotificationInfoWithNotificationInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserNotificationInfoWithNotificationInfo[]>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class OutsideShareholderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_Search(body: REA_OUTSIDE_SHAREHOLDER_ENTITY | undefined): Observable<PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_Ins(body: REA_OUTSIDE_SHAREHOLDER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_Upd(body: REA_OUTSIDE_SHAREHOLDER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_ById(id: string | undefined): Observable<REA_OUTSIDE_SHAREHOLDER_ENTITY> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_OUTSIDE_SHAREHOLDER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_OUTSIDE_SHAREHOLDER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_ById(response: HttpResponseBase): Observable<REA_OUTSIDE_SHAREHOLDER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_OUTSIDE_SHAREHOLDER_ENTITY.fromJS(resultData200) : new REA_OUTSIDE_SHAREHOLDER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_OUTSIDE_SHAREHOLDER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @return Success
     */
    rEA_OUTSIDE_SHAREHOLDER_Get_Id(): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/OutsideShareholder/REA_OUTSIDE_SHAREHOLDER_Get_Id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OUTSIDE_SHAREHOLDER_Get_Id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OUTSIDE_SHAREHOLDER_Get_Id(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OUTSIDE_SHAREHOLDER_Get_Id(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class OwnerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_OWNER_Search(body: REA_OWNER_ENTITY | undefined): Observable<PagedResultDtoOfREA_OWNER_ENTITY> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_OWNER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_OWNER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_OWNER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_OWNER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_OWNER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_OWNER_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_OWNER_Ins(body: REA_OWNER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_OWNER_Upd(body: REA_OWNER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_OWNER_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_OWNER_ById(id: string | undefined): Observable<REA_OWNER_ENTITY> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_OWNER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_OWNER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_ById(response: HttpResponseBase): Observable<REA_OWNER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_OWNER_ENTITY.fromJS(resultData200) : new REA_OWNER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_OWNER_ENTITY>(<any>null);
    }

    /**
     * @return Success
     */
    rEA_OWNER_Get_Id(): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_Get_Id";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_Get_Id(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_Get_Id(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_Get_Id(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @return Success
     */
    getOwnerTypeCodes(): Observable<CM_ALLCODE_ENTITY[]> {
        let url_ = this.baseUrl + "/api/Owner/GetOwnerTypeCodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnerTypeCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerTypeCodes(<any>response_);
                } catch (e) {
                    return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_ALLCODE_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnerTypeCodes(response: HttpResponseBase): Observable<CM_ALLCODE_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_ALLCODE_ENTITY[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_OWNER_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Owner/REA_OWNER_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_OWNER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_OWNER_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_OWNER_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled === null)
            throw new Error("The parameter 'recurringPaymentsEnabled' cannot be null.");
        else if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalPaymentId (optional) 
     * @param paypalPayerId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalPaymentId: string | undefined, paypalPayerId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalPaymentId === null)
            throw new Error("The parameter 'paypalPaymentId' cannot be null.");
        else if (paypalPaymentId !== undefined)
            url_ += "paypalPaymentId=" + encodeURIComponent("" + paypalPaymentId) + "&"; 
        if (paypalPayerId === null)
            throw new Error("The parameter 'paypalPayerId' cannot be null.");
        else if (paypalPayerId !== undefined)
            url_ += "paypalPayerId=" + encodeURIComponent("" + paypalPayerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayPalConfigurationDto.fromJS(resultData200) : new PayPalConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | undefined, userId: number | undefined, tenantId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_PROJECT_Ins(body: REA_PROJECT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_PROJECT_Upd(body: REA_PROJECT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_PROJECT_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_PROJECT_Search(body: REA_PROJECT_ENTITY | undefined): Observable<PagedResultDtoOfREA_PROJECT_ENTITY> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_PROJECT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_PROJECT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_PROJECT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_PROJECT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_PROJECT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_PROJECT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_PROJECT_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_PROJECT_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_PROJECT_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_PROJECT_ById(id: string | undefined): Observable<REA_PROJECT_ENTITY> {
        let url_ = this.baseUrl + "/api/Project/REA_PROJECT_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_PROJECT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_PROJECT_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_PROJECT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_PROJECT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_PROJECT_ById(response: HttpResponseBase): Observable<REA_PROJECT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_PROJECT_ENTITY.fromJS(resultData200) : new REA_PROJECT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_PROJECT_ENTITY>(<any>null);
    }
}

@Injectable()
export class RegionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REGION_Search(body: CM_REGION_ENTITY | undefined): Observable<PagedResultDtoOfCM_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REGION_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REGION_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_MANAGER_Search(body: CM_MANAGER_REGION_ENTITY | undefined): Observable<PagedResultDtoOfCM_MANAGER_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_MANAGER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_MANAGER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_MANAGER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_MANAGER_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_MANAGER_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_MANAGER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_MANAGER_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_MANAGER_REGION_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_MANAGER_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_MANAGER_REGION_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REGION_Ins(body: CM_REGION_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REGION_Upd(body: CM_REGION_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REGION_ById(id: string | undefined): Observable<CM_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_ById(response: HttpResponseBase): Observable<CM_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REGION_ENTITY.fromJS(resultData200) : new CM_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REGION_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REGION_DISPLAY_ById(id: string | undefined): Observable<CM_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_DISPLAY_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_DISPLAY_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_DISPLAY_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_DISPLAY_ById(response: HttpResponseBase): Observable<CM_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REGION_ENTITY.fromJS(resultData200) : new CM_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REGION_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REGION_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_REGION_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REGION_User_Search(body: CM_REGION_ENTITY | undefined): Observable<PagedResultDtoOfCM_REGION_ENTITY> {
        let url_ = this.baseUrl + "/api/Region/CM_REGION_User_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REGION_User_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REGION_User_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REGION_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REGION_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REGION_User_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REGION_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REGION_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REGION_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REGION_ENTITY>(<any>null);
    }
}

@Injectable()
export class RejectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REJECT_Search(body: CM_REJECT_LOG_ENTITY | undefined): Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY> {
        let url_ = this.baseUrl + "/api/Reject/CM_REJECT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REJECT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REJECT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REJECT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REJECT_LOG_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REJECT_LOG_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REJECT_LOG_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REJECT_LOG_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REJECT_Ins(body: CM_REJECT_LOG_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Reject/CM_REJECT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REJECT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REJECT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REJECT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param trd_id (optional) 
     * @param stage (optional) 
     * @return Success
     */
    cM_REJECT_ById(trd_id: string | undefined, stage: string | undefined): Observable<CM_REJECT_LOG_ENTITY> {
        let url_ = this.baseUrl + "/api/Reject/CM_REJECT_ById?";
        if (trd_id === null)
            throw new Error("The parameter 'trd_id' cannot be null.");
        else if (trd_id !== undefined)
            url_ += "trd_id=" + encodeURIComponent("" + trd_id) + "&"; 
        if (stage === null)
            throw new Error("The parameter 'stage' cannot be null.");
        else if (stage !== undefined)
            url_ += "stage=" + encodeURIComponent("" + stage) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REJECT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REJECT_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REJECT_LOG_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REJECT_LOG_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REJECT_ById(response: HttpResponseBase): Observable<CM_REJECT_LOG_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REJECT_LOG_ENTITY.fromJS(resultData200) : new CM_REJECT_LOG_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REJECT_LOG_ENTITY>(<any>null);
    }
}

@Injectable()
export class ReportTemplateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Search(body: CM_REPORT_TEMPLATE_ENTITY | undefined): Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_ToExcel(body: CM_REPORT_TEMPLATE_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Ins(body: CM_REPORT_TEMPLATE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Upd(body: CM_REPORT_TEMPLATE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_ById(id: string | undefined): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_ById(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REPORT_TEMPLATE_ENTITY.fromJS(resultData200) : new CM_REPORT_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param templateCode (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_ByCode(templateCode: string | undefined): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_ByCode?";
        if (templateCode === null)
            throw new Error("The parameter 'templateCode' cannot be null.");
        else if (templateCode !== undefined)
            url_ += "templateCode=" + encodeURIComponent("" + templateCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_ByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_ByCode(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_ByCode(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REPORT_TEMPLATE_ENTITY.fromJS(resultData200) : new CM_REPORT_TEMPLATE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_ENTITY>(<any>null);
    }

    /**
     * @param templateId (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_DETAIL_ByTemplateId(templateId: string | undefined): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_DETAIL_ByTemplateId?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "templateId=" + encodeURIComponent("" + templateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_DETAIL_ByTemplateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_DETAIL_ByTemplateId(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_DETAIL_ByTemplateId(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_REPORT_TEMPLATE_DETAIL_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_DETAIL_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_DETAIL_Upd(body: CM_REPORT_TEMPLATE_DETAIL_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_DETAIL_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_DETAIL_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_DETAIL_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_DETAIL_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param templateDetailId (optional) 
     * @return Success
     */
    cM_REPORT_TEMPLATE_DETAIL_ById(templateDetailId: string | undefined): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY> {
        let url_ = this.baseUrl + "/api/ReportTemplate/CM_REPORT_TEMPLATE_DETAIL_ById?";
        if (templateDetailId === null)
            throw new Error("The parameter 'templateDetailId' cannot be null.");
        else if (templateDetailId !== undefined)
            url_ += "templateDetailId=" + encodeURIComponent("" + templateDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_REPORT_TEMPLATE_DETAIL_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_REPORT_TEMPLATE_DETAIL_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_REPORT_TEMPLATE_DETAIL_ById(response: HttpResponseBase): Observable<CM_REPORT_TEMPLATE_DETAIL_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_REPORT_TEMPLATE_DETAIL_ENTITY.fromJS(resultData200) : new CM_REPORT_TEMPLATE_DETAIL_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_REPORT_TEMPLATE_DETAIL_ENTITY>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permission (optional) 
     * @param roleName (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined, roleName: string | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (roleName === null)
            throw new Error("The parameter 'roleName' cannot be null.");
        else if (roleName !== undefined)
            url_ += "RoleName=" + encodeURIComponent("" + roleName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRole(): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllRole";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRole(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRole(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SecurInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SECUR_INFO_Ins(body: CM_SECUR_INFO_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SECUR_INFO_Upd(body: CM_SECUR_INFO_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SECUR_INFO_Del(id: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_SECUR_INFO_Appr(id: string | undefined, currentUserName: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_Appr?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_Appr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_Appr(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_Appr(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SECUR_INFO_Search(body: CM_SECUR_INFO_ENTITY | undefined): Observable<PagedResultDtoOfCM_SECUR_INFO_ENTITY> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_SECUR_INFO_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_SECUR_INFO_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_SECUR_INFO_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_SECUR_INFO_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_SECUR_INFO_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_SECUR_INFO_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SECUR_INFO_ById(id: string | undefined): Observable<CM_SECUR_INFO_ENTITY> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_SECUR_INFO_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SECUR_INFO_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_ById(response: HttpResponseBase): Observable<CM_SECUR_INFO_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_SECUR_INFO_ENTITY.fromJS(resultData200) : new CM_SECUR_INFO_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SECUR_INFO_ENTITY>(<any>null);
    }

    /**
     * @return Success
     */
    cM_SECUR_INFO_List(): Observable<CM_SECUR_INFO_ENTITY[]> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_List(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_List(<any>response_);
                } catch (e) {
                    return <Observable<CM_SECUR_INFO_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SECUR_INFO_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_List(response: HttpResponseBase): Observable<CM_SECUR_INFO_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_SECUR_INFO_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SECUR_INFO_ENTITY[]>(<any>null);
    }

    /**
     * @return Success
     */
    cM_SECUR_INFO_ListAvailable(): Observable<CM_SECUR_INFO_ENTITY[]> {
        let url_ = this.baseUrl + "/api/SecurInfo/CM_SECUR_INFO_ListAvailable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SECUR_INFO_ListAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SECUR_INFO_ListAvailable(<any>response_);
                } catch (e) {
                    return <Observable<CM_SECUR_INFO_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SECUR_INFO_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SECUR_INFO_ListAvailable(response: HttpResponseBase): Observable<CM_SECUR_INFO_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CM_SECUR_INFO_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SECUR_INFO_ENTITY[]>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAppSetting(): Observable<SettingDto> {
        let url_ = this.baseUrl + "/api/Setting/GetAllAppSetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAppSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAppSetting(<any>response_);
                } catch (e) {
                    return <Observable<SettingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SettingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAppSetting(response: HttpResponseBase): Observable<SettingDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SettingDto.fromJS(resultData200) : new SettingDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingDto>(<any>null);
    }
}

@Injectable()
export class ShareholderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_Ins(body: REA_SHAREHOLDER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_Upd(body: REA_SHAREHOLDER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_Search(body: REA_SHAREHOLDER_ENTITY | undefined): Observable<PagedResultDtoOfREA_SHAREHOLDER_ENTITY> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_SHAREHOLDER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_SHAREHOLDER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_SHAREHOLDER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_SHAREHOLDER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_SHAREHOLDER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_SHAREHOLDER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_SHAREHOLDER_ById(id: string | undefined): Observable<REA_SHAREHOLDER_ENTITY> {
        let url_ = this.baseUrl + "/api/Shareholder/REA_SHAREHOLDER_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SHAREHOLDER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SHAREHOLDER_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_SHAREHOLDER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_SHAREHOLDER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SHAREHOLDER_ById(response: HttpResponseBase): Observable<REA_SHAREHOLDER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_SHAREHOLDER_ENTITY.fromJS(resultData200) : new REA_SHAREHOLDER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_SHAREHOLDER_ENTITY>(<any>null);
    }
}

@Injectable()
export class SodoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_SODO_Ins(body: REA_SODO_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_SODO_Upd(body: REA_SODO_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_SODO_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rEA_SODO_Search(body: REA_SODO_ENTITY | undefined): Observable<PagedResultDtoOfREA_SODO_ENTITY> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfREA_SODO_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfREA_SODO_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_Search(response: HttpResponseBase): Observable<PagedResultDtoOfREA_SODO_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfREA_SODO_ENTITY.fromJS(resultData200) : new PagedResultDtoOfREA_SODO_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfREA_SODO_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_SODO_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_SODO_Rej(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_Rej?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_Rej(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_Rej(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_Rej(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    rEA_SODO_Can(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_Can?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_Can(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_Can(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_Can(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rEA_SODO_ById(id: string | undefined): Observable<REA_SODO_ENTITY> {
        let url_ = this.baseUrl + "/api/Sodo/REA_SODO_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processREA_SODO_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processREA_SODO_ById(<any>response_);
                } catch (e) {
                    return <Observable<REA_SODO_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<REA_SODO_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processREA_SODO_ById(response: HttpResponseBase): Observable<REA_SODO_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? REA_SODO_ENTITY.fromJS(resultData200) : new REA_SODO_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<REA_SODO_ENTITY>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmPayment(body: StripeConfirmPaymentInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscription(body: StripeCreateSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: StripeUpdateSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StripeConfigurationDto.fromJS(resultData200) : new StripeConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SupplierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIER_Search(body: CM_SUPPLIER_ENTITY | undefined): Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_SUPPLIER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_SUPPLIER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_SUPPLIER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_SUPPLIER_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIER_ToExcel(body: CM_SUPPLIER_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIER_Ins(body: CM_SUPPLIER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIER_Upd(body: CM_SUPPLIER_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIER_ById(id: string | undefined): Observable<CM_SUPPLIER_ENTITY> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_SUPPLIER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SUPPLIER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_ById(response: HttpResponseBase): Observable<CM_SUPPLIER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_SUPPLIER_ENTITY.fromJS(resultData200) : new CM_SUPPLIER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SUPPLIER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIER_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_SUPPLIER_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Supplier/CM_SUPPLIER_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIER_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIER_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class SupplierTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Search(body: CM_SUPPLIERTYPE_ENTITY | undefined): Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Ins(body: CM_SUPPLIERTYPE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Upd(body: CM_SUPPLIERTYPE_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_ById(id: string | undefined): Observable<CM_SUPPLIERTYPE_ENTITY> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_SUPPLIERTYPE_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_ById(response: HttpResponseBase): Observable<CM_SUPPLIERTYPE_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_SUPPLIERTYPE_ENTITY.fromJS(resultData200) : new CM_SUPPLIERTYPE_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_SUPPLIERTYPE_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_SUPPLIERTYPE_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/SupplierType/CM_SUPPLIERTYPE_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_SUPPLIERTYPE_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_SUPPLIERTYPE_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_SUPPLIERTYPE_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class SysParametersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Search(body: SYS_PARAMETERS_ENTITY | undefined): Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Search(response: HttpResponseBase): Observable<PagedResultDtoOfSYS_PARAMETERS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSYS_PARAMETERS_ENTITY.fromJS(resultData200) : new PagedResultDtoOfSYS_PARAMETERS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSYS_PARAMETERS_ENTITY>(<any>null);
    }

    /**
     * @param tlname (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ROLE_Search(tlname: string | undefined): Observable<SYS_PARAMETERS_ENTITY[]> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ROLE_Search?";
        if (tlname === null)
            throw new Error("The parameter 'tlname' cannot be null.");
        else if (tlname !== undefined)
            url_ += "tlname=" + encodeURIComponent("" + tlname) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ROLE_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ROLE_Search(<any>response_);
                } catch (e) {
                    return <Observable<SYS_PARAMETERS_ENTITY[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_PARAMETERS_ENTITY[]>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ROLE_Search(response: HttpResponseBase): Observable<SYS_PARAMETERS_ENTITY[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SYS_PARAMETERS_ENTITY.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_PARAMETERS_ENTITY[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ToExcel(body: SYS_PARAMETERS_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Ins(body: SYS_PARAMETERS_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Upd(body: SYS_PARAMETERS_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ById(id: number | undefined): Observable<SYS_PARAMETERS_ENTITY> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ById(<any>response_);
                } catch (e) {
                    return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ById(response: HttpResponseBase): Observable<SYS_PARAMETERS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SYS_PARAMETERS_ENTITY.fromJS(resultData200) : new SYS_PARAMETERS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_PARAMETERS_ENTITY>(<any>null);
    }

    /**
     * @param parakey (optional) 
     * @return Success
     */
    sYS_PARAMETERS_ByParaKey(parakey: string | undefined): Observable<SYS_PARAMETERS_ENTITY> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_ByParaKey?";
        if (parakey === null)
            throw new Error("The parameter 'parakey' cannot be null.");
        else if (parakey !== undefined)
            url_ += "parakey=" + encodeURIComponent("" + parakey) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_ByParaKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_ByParaKey(<any>response_);
                } catch (e) {
                    return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<SYS_PARAMETERS_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_ByParaKey(response: HttpResponseBase): Observable<SYS_PARAMETERS_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SYS_PARAMETERS_ENTITY.fromJS(resultData200) : new SYS_PARAMETERS_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SYS_PARAMETERS_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    sYS_PARAMETERS_Del(id: number | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/SysParameters/SYS_PARAMETERS_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSYS_PARAMETERS_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSYS_PARAMETERS_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processSYS_PARAMETERS_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param tOP (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | undefined, subscriptionEndDateStart: moment.Moment | undefined, subscriptionEndDateEnd: moment.Moment | undefined, creationDateStart: moment.Moment | undefined, creationDateEnd: moment.Moment | undefined, editionId: number | undefined, editionIdSpecified: boolean | undefined, tOP: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart === null)
            throw new Error("The parameter 'subscriptionEndDateStart' cannot be null.");
        else if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd === null)
            throw new Error("The parameter 'subscriptionEndDateEnd' cannot be null.");
        else if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart === null)
            throw new Error("The parameter 'creationDateStart' cannot be null.");
        else if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd === null)
            throw new Error("The parameter 'creationDateEnd' cannot be null.");
        else if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (tOP === null)
            throw new Error("The parameter 'tOP' cannot be null.");
        else if (tOP !== undefined)
            url_ += "TOP=" + encodeURIComponent("" + tOP) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRegionalStats(input: GetRegionalStatsInput | undefined): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGeneralStats(input: GetGeneralStatsInput | undefined): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TermServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_TERM_Search(body: CM_TERM_ENTITY | undefined): Observable<PagedResultDtoOfCM_TERM_ENTITY> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_TERM_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_TERM_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_TERM_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_TERM_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_TERM_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_TERM_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_TERM_Ins(body: CM_TERM_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_TERM_Upd(body: CM_TERM_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_TERM_ById(id: string | undefined): Observable<CM_TERM_ENTITY> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_TERM_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_TERM_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_ById(response: HttpResponseBase): Observable<CM_TERM_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_TERM_ENTITY.fromJS(resultData200) : new CM_TERM_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_TERM_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_TERM_Del(id: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_TERM_App(id: string | undefined, currentUserName: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_TERM_SearchParam(body: CM_TERM_ENTITY | undefined): Observable<PagedResultDtoOfCM_TERM_ENTITY> {
        let url_ = this.baseUrl + "/api/Term/CM_TERM_SearchParam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_TERM_SearchParam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_TERM_SearchParam(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_TERM_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_TERM_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_TERM_SearchParam(response: HttpResponseBase): Observable<PagedResultDtoOfCM_TERM_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_TERM_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_TERM_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_TERM_ENTITY>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TlUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_USER_Search(body: TL_USER_ENTITY | undefined): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Search(response: HttpResponseBase): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTL_USER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTL_USER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTL_USER_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tLUSER_MANAGER_SEARCH(body: TL_USER_ENTITY | undefined): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        let url_ = this.baseUrl + "/api/TlUser/TLUSER_MANAGER_SEARCH";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTLUSER_MANAGER_SEARCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTLUSER_MANAGER_SEARCH(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTLUSER_MANAGER_SEARCH(response: HttpResponseBase): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTL_USER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTL_USER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTL_USER_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_USER_Ins(body: TL_USER_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Ins(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Ins(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_USER_Upd(body: TL_USER_ENTITY | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Upd(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Upd(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_USER_ById(id: string | undefined): Observable<TL_USER_ENTITY> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_ById(<any>response_);
                } catch (e) {
                    return <Observable<TL_USER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_USER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_ById(response: HttpResponseBase): Observable<TL_USER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_USER_ENTITY.fromJS(resultData200) : new TL_USER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_USER_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    tL_USER_Del(id: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_Del(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_Del(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    tL_USER_App(id: string | undefined, currentUserName: string | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_App(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_App(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tL_USER_REPORT_SEARCH(body: TL_USER_ENTITY | undefined): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        let url_ = this.baseUrl + "/api/TlUser/TL_USER_REPORT_SEARCH";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTL_USER_REPORT_SEARCH(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTL_USER_REPORT_SEARCH(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTL_USER_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processTL_USER_REPORT_SEARCH(response: HttpResponseBase): Observable<PagedResultDtoOfTL_USER_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTL_USER_ENTITY.fromJS(resultData200) : new PagedResultDtoOfTL_USER_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTL_USER_ENTITY>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    autoLogin(): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AutoLogin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAutoLogin(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateLdap(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateLdap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateLdap(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateLdap(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateLdap(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateOpenid(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateOpenid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateOpenid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateOpenid(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateOpenid(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticateFederation(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/AuthenticateFederation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateFederation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateFederation(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateFederation(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param user (optional) 
     * @return Success
     */
    getUserADFSInfomation(user: string | undefined): Observable<TL_USER_SearchResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetUserADFSInfomation?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserADFSInfomation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserADFSInfomation(<any>response_);
                } catch (e) {
                    return <Observable<TL_USER_SearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_USER_SearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserADFSInfomation(response: HttpResponseBase): Observable<TL_USER_SearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_USER_SearchResult.fromJS(resultData200) : new TL_USER_SearchResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_USER_SearchResult>(<any>null);
    }

    /**
     * @param user (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    getUserInfomation(user: string | undefined, currentUserName: string | undefined): Observable<TL_USER_SearchResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetUserInfomation?";
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfomation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfomation(<any>response_);
                } catch (e) {
                    return <Observable<TL_USER_SearchResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<TL_USER_SearchResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfomation(response: HttpResponseBase): Observable<TL_USER_SearchResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TL_USER_SearchResult.fromJS(resultData200) : new TL_USER_SearchResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TL_USER_SearchResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RefreshTokenResult.fromJS(resultData200) : new RefreshTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | undefined, severity: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity === null)
            throw new Error("The parameter 'severity' cannot be null.");
        else if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param provider (optional) 
     * @param returnUrl (optional) 
     * @param ss (optional) 
     * @return Success
     */
    externalLogin(provider: string | undefined, returnUrl: string | undefined, ss: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalLogin?";
        if (provider === null)
            throw new Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            url_ += "provider=" + encodeURIComponent("" + provider) + "&"; 
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (ss === null)
            throw new Error("The parameter 'ss' cannot be null.");
        else if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLogin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @param ss (optional) 
     * @return Success
     */
    loginAdfs(returnUrl: string | undefined, ss: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LoginAdfs?";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (ss === null)
            throw new Error("The parameter 'ss' cannot be null.");
        else if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginAdfs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginAdfs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLoginAdfs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @param remoteError (optional) 
     * @param ss (optional) 
     * @return Success
     */
    externalLoginCallback(returnUrl: string | undefined, remoteError: string | undefined, ss: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalLoginCallback?";
        if (returnUrl === null)
            throw new Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (remoteError === null)
            throw new Error("The parameter 'remoteError' cannot be null.");
        else if (remoteError !== undefined)
            url_ += "remoteError=" + encodeURIComponent("" + remoteError) + "&"; 
        if (ss === null)
            throw new Error("The parameter 'ss' cannot be null.");
        else if (ss !== undefined)
            url_ += "ss=" + encodeURIComponent("" + ss) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalLoginCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalLoginCallback(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExternalLoginCallback(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    signOutAdfs(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SignOutAdfs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignOutAdfs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignOutAdfs(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSignOutAdfs(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName === null)
            throw new Error("The parameter 'themeName' cannot be null.");
        else if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UltilityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param functionId (optional) 
     * @return Success
     */
    isApproveFunct(functionId: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Ultility/IsApproveFunct?";
        if (functionId === null)
            throw new Error("The parameter 'functionId' cannot be null.");
        else if (functionId !== undefined)
            url_ += "functionId=" + encodeURIComponent("" + functionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsApproveFunct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsApproveFunct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsApproveFunct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param procedureName (optional) 
     * @return Success
     */
    getProcedureContent(procedureName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ultility/GetProcedureContent?";
        if (procedureName === null)
            throw new Error("The parameter 'procedureName' cannot be null.");
        else if (procedureName !== undefined)
            url_ += "procedureName=" + encodeURIComponent("" + procedureName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcedureContent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcedureContent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcedureContent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getLogFile(): Observable<string> {
        let url_ = this.baseUrl + "/api/Ultility/GetLogFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogFile(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogFile(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param path (optional) 
     * @return Success
     */
    downloadFile(path: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Ultility/DownloadFile?";
        if (path === null)
            throw new Error("The parameter 'path' cannot be null.");
        else if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    dEL_F(files: string[] | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Ultility/DEL_F?";
        if (files === null)
            throw new Error("The parameter 'files' cannot be null.");
        else if (files !== undefined)
            files && files.forEach(item => { url_ += "files=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDEL_F(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDEL_F(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDEL_F(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param d (optional) 
     * @param fileName (optional) 
     * @param g (optional) 
     * @param settingName (optional) 
     * @return Success
     */
    uploadLogo(d: string | undefined, fileName: string | undefined, g: string | undefined, settingName: string | undefined): Observable<UPLOAD_W_T_RESULT> {
        let url_ = this.baseUrl + "/api/Ultility/UploadLogo?";
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&"; 
        if (fileName === null)
            throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined)
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (g === null)
            throw new Error("The parameter 'g' cannot be null.");
        else if (g !== undefined)
            url_ += "g=" + encodeURIComponent("" + g) + "&"; 
        if (settingName === null)
            throw new Error("The parameter 'settingName' cannot be null.");
        else if (settingName !== undefined)
            url_ += "settingName=" + encodeURIComponent("" + settingName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadLogo(<any>response_);
                } catch (e) {
                    return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(e);
                }
            } else
                return <Observable<UPLOAD_W_T_RESULT>><any>_observableThrow(response_);
        }));
    }

    protected processUploadLogo(response: HttpResponseBase): Observable<UPLOAD_W_T_RESULT> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UPLOAD_W_T_RESULT.fromJS(resultData200) : new UPLOAD_W_T_RESULT();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UPLOAD_W_T_RESULT>(<any>null);
    }

    /**
     * @param content (optional) 
     * @param _fileName (optional) 
     * @return Success
     */
    uploadSFtp(content: string | undefined, _fileName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Ultility/UploadSFtp?";
        if (content === null)
            throw new Error("The parameter 'content' cannot be null.");
        else if (content !== undefined)
            url_ += "content=" + encodeURIComponent("" + content) + "&"; 
        if (_fileName === null)
            throw new Error("The parameter '_fileName' cannot be null.");
        else if (_fileName !== undefined)
            url_ += "_fileName=" + encodeURIComponent("" + _fileName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadSFtp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadSFtp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadSFtp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_UNIT_Search(body: CM_UNIT_ENTITY | undefined): Observable<PagedResultDtoOfCM_UNIT_ENTITY> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_UNIT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_UNIT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_UNIT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_UNIT_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_UNIT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_UNIT_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_UNIT_Ins(body: CM_UNIT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_UNIT_Upd(body: CM_UNIT_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_UNIT_ById(id: string | undefined): Observable<CM_UNIT_ENTITY> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_UNIT_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_UNIT_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_ById(response: HttpResponseBase): Observable<CM_UNIT_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_UNIT_ENTITY.fromJS(resultData200) : new CM_UNIT_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_UNIT_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_UNIT_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_UNIT_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Unit/CM_UNIT_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_UNIT_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_UNIT_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_UNIT_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: GetUsersInput | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsersToExcel(body: GetUsersInput | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    approveUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ApproveUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApproveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/LockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListUser(body: CreateOrUpdateUserInput[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateListUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateListUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateListUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllLanguages(): Observable<AbpUserLocalizationConfigDto> {
        let url_ = this.baseUrl + "/api/services/app/UserConfiguration/GetAllLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLanguages(<any>response_);
                } catch (e) {
                    return <Observable<AbpUserLocalizationConfigDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AbpUserLocalizationConfigDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLanguages(response: HttpResponseBase): Observable<AbpUserLocalizationConfigDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AbpUserLocalizationConfigDto.fromJS(resultData200) : new AbpUserLocalizationConfigDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbpUserLocalizationConfigDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Observable<AbpUserConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserConfiguration/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AbpUserConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AbpUserConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AbpUserConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AbpUserConfigurationDto.fromJS(resultData200) : new AbpUserConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbpUserConfigurationDto>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WfDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    wF_EXECUTE(body: WfDefinitionParam | undefined): Observable<{ [key: string] : any; }> {
        let url_ = this.baseUrl + "/api/WfDefinition/WF_EXECUTE";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWF_EXECUTE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWF_EXECUTE(<any>response_);
                } catch (e) {
                    return <Observable<{ [key: string] : any; }>><any>_observableThrow(e);
                }
            } else
                return <Observable<{ [key: string] : any; }>><any>_observableThrow(response_);
        }));
    }

    protected processWF_EXECUTE(response: HttpResponseBase): Observable<{ [key: string] : any; }> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key];
                }
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<{ [key: string] : any; }>(<any>null);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_WORKFLOW_Search(body: CM_WORKFLOW_ENTITY | undefined): Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Search(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Search(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Search(response: HttpResponseBase): Observable<PagedResultDtoOfCM_WORKFLOW_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCM_WORKFLOW_ENTITY.fromJS(resultData200) : new PagedResultDtoOfCM_WORKFLOW_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCM_WORKFLOW_ENTITY>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_WORKFLOW_ToExcel(body: CM_WORKFLOW_ENTITY | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_ToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_ToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_ToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_ToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_WORKFLOW_Ins(body: CM_WORKFLOW_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Ins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Ins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Ins(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Ins(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_WORKFLOW_Upd(body: CM_WORKFLOW_ENTITY | undefined): Observable<InsertResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Upd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Upd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Upd(<any>response_);
                } catch (e) {
                    return <Observable<InsertResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<InsertResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Upd(response: HttpResponseBase): Observable<InsertResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsertResult.fromJS(resultData200) : new InsertResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_WORKFLOW_ById(id: string | undefined): Observable<CM_WORKFLOW_ENTITY> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_ById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_ById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_ById(<any>response_);
                } catch (e) {
                    return <Observable<CM_WORKFLOW_ENTITY>><any>_observableThrow(e);
                }
            } else
                return <Observable<CM_WORKFLOW_ENTITY>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_ById(response: HttpResponseBase): Observable<CM_WORKFLOW_ENTITY> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CM_WORKFLOW_ENTITY.fromJS(resultData200) : new CM_WORKFLOW_ENTITY();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CM_WORKFLOW_ENTITY>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    cM_WORKFLOW_Del(id: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_Del?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_Del(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_Del(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_Del(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param currentUserName (optional) 
     * @return Success
     */
    cM_WORKFLOW_App(id: string | undefined, currentUserName: string | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_App?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (currentUserName === null)
            throw new Error("The parameter 'currentUserName' cannot be null.");
        else if (currentUserName !== undefined)
            url_ += "currentUserName=" + encodeURIComponent("" + currentUserName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_App(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_App(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_App(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cM_WORKFLOW_TRANSACTION_Reject(body: CM_WORKFLOW_REJECT_MODEL | undefined): Observable<CommonResult> {
        let url_ = this.baseUrl + "/api/Workflow/CM_WORKFLOW_TRANSACTION_Reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCM_WORKFLOW_TRANSACTION_Reject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCM_WORKFLOW_TRANSACTION_Reject(<any>response_);
                } catch (e) {
                    return <Observable<CommonResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonResult>><any>_observableThrow(response_);
        }));
    }

    protected processCM_WORKFLOW_TRANSACTION_Reject(response: HttpResponseBase): Observable<CommonResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommonResult.fromJS(resultData200) : new CommonResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonResult>(<any>null);
    }
}

export class AbpLocalizationSourceDto implements IAbpLocalizationSourceDto {
    name!: string | undefined;
    type!: string | undefined;

    constructor(data?: IAbpLocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): AbpLocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }
}

export interface IAbpLocalizationSourceDto {
    name: string | undefined;
    type: string | undefined;
}

export class AbpMultiTenancyConfigDto implements IAbpMultiTenancyConfigDto {
    isEnabled!: boolean;
    ignoreFeatureCheckForHostUsers!: boolean;
    sides!: AbpMultiTenancySidesConfigDto;

    constructor(data?: IAbpMultiTenancyConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.ignoreFeatureCheckForHostUsers = data["ignoreFeatureCheckForHostUsers"];
            this.sides = data["sides"] ? AbpMultiTenancySidesConfigDto.fromJS(data["sides"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpMultiTenancyConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancyConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["ignoreFeatureCheckForHostUsers"] = this.ignoreFeatureCheckForHostUsers;
        data["sides"] = this.sides ? this.sides.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpMultiTenancyConfigDto {
    isEnabled: boolean;
    ignoreFeatureCheckForHostUsers: boolean;
    sides: AbpMultiTenancySidesConfigDto;
}

export class AbpMultiTenancySidesConfigDto implements IAbpMultiTenancySidesConfigDto {
    host!: MultiTenancySides;
    tenant!: MultiTenancySides;

    constructor(data?: IAbpMultiTenancySidesConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.host = data["host"];
            this.tenant = data["tenant"];
        }
    }

    static fromJS(data: any): AbpMultiTenancySidesConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancySidesConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["tenant"] = this.tenant;
        return data; 
    }
}

export interface IAbpMultiTenancySidesConfigDto {
    host: MultiTenancySides;
    tenant: MultiTenancySides;
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value!: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class AbpUserAntiForgeryConfigDto implements IAbpUserAntiForgeryConfigDto {
    tokenCookieName!: string | undefined;
    tokenHeaderName!: string | undefined;

    constructor(data?: IAbpUserAntiForgeryConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tokenCookieName = data["tokenCookieName"];
            this.tokenHeaderName = data["tokenHeaderName"];
        }
    }

    static fromJS(data: any): AbpUserAntiForgeryConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAntiForgeryConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenCookieName"] = this.tokenCookieName;
        data["tokenHeaderName"] = this.tokenHeaderName;
        return data; 
    }
}

export interface IAbpUserAntiForgeryConfigDto {
    tokenCookieName: string | undefined;
    tokenHeaderName: string | undefined;
}

export class AbpUserAuthConfigDto implements IAbpUserAuthConfigDto {
    allPermissions!: { [key: string] : string; } | undefined;
    grantedPermissions!: { [key: string] : string; } | undefined;

    constructor(data?: IAbpUserAuthConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in data["allPermissions"]) {
                    if (data["allPermissions"].hasOwnProperty(key))
                        this.allPermissions![key] = data["allPermissions"][key];
                }
            }
            if (data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in data["grantedPermissions"]) {
                    if (data["grantedPermissions"].hasOwnProperty(key))
                        this.grantedPermissions![key] = data["grantedPermissions"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserAuthConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAuthConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    data["allPermissions"][key] = this.allPermissions[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    data["grantedPermissions"][key] = this.grantedPermissions[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserAuthConfigDto {
    allPermissions: { [key: string] : string; } | undefined;
    grantedPermissions: { [key: string] : string; } | undefined;
}

export class AbpUserClockConfigDto implements IAbpUserClockConfigDto {
    provider!: string | undefined;

    constructor(data?: IAbpUserClockConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): AbpUserClockConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserClockConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        return data; 
    }
}

export interface IAbpUserClockConfigDto {
    provider: string | undefined;
}

export class AbpUserConfigurationDto implements IAbpUserConfigurationDto {
    multiTenancy!: AbpMultiTenancyConfigDto;
    session!: AbpUserSessionConfigDto;
    localization!: AbpUserLocalizationConfigDto;
    features!: AbpUserFeatureConfigDto;
    auth!: AbpUserAuthConfigDto;
    nav!: AbpUserNavConfigDto;
    setting!: AbpUserSettingConfigDto;
    clock!: AbpUserClockConfigDto;
    timing!: AbpUserTimingConfigDto;
    security!: AbpUserSecurityConfigDto;
    custom!: { [key: string] : any; } | undefined;

    constructor(data?: IAbpUserConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.multiTenancy = data["multiTenancy"] ? AbpMultiTenancyConfigDto.fromJS(data["multiTenancy"]) : <any>undefined;
            this.session = data["session"] ? AbpUserSessionConfigDto.fromJS(data["session"]) : <any>undefined;
            this.localization = data["localization"] ? AbpUserLocalizationConfigDto.fromJS(data["localization"]) : <any>undefined;
            this.features = data["features"] ? AbpUserFeatureConfigDto.fromJS(data["features"]) : <any>undefined;
            this.auth = data["auth"] ? AbpUserAuthConfigDto.fromJS(data["auth"]) : <any>undefined;
            this.nav = data["nav"] ? AbpUserNavConfigDto.fromJS(data["nav"]) : <any>undefined;
            this.setting = data["setting"] ? AbpUserSettingConfigDto.fromJS(data["setting"]) : <any>undefined;
            this.clock = data["clock"] ? AbpUserClockConfigDto.fromJS(data["clock"]) : <any>undefined;
            this.timing = data["timing"] ? AbpUserTimingConfigDto.fromJS(data["timing"]) : <any>undefined;
            this.security = data["security"] ? AbpUserSecurityConfigDto.fromJS(data["security"]) : <any>undefined;
            if (data["custom"]) {
                this.custom = {} as any;
                for (let key in data["custom"]) {
                    if (data["custom"].hasOwnProperty(key))
                        this.custom![key] = data["custom"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["nav"] = this.nav ? this.nav.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        if (this.custom) {
            data["custom"] = {};
            for (let key in this.custom) {
                if (this.custom.hasOwnProperty(key))
                    data["custom"][key] = this.custom[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserConfigurationDto {
    multiTenancy: AbpMultiTenancyConfigDto;
    session: AbpUserSessionConfigDto;
    localization: AbpUserLocalizationConfigDto;
    features: AbpUserFeatureConfigDto;
    auth: AbpUserAuthConfigDto;
    nav: AbpUserNavConfigDto;
    setting: AbpUserSettingConfigDto;
    clock: AbpUserClockConfigDto;
    timing: AbpUserTimingConfigDto;
    security: AbpUserSecurityConfigDto;
    custom: { [key: string] : any; } | undefined;
}

export class AbpUserCurrentCultureConfigDto implements IAbpUserCurrentCultureConfigDto {
    name!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IAbpUserCurrentCultureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AbpUserCurrentCultureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserCurrentCultureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAbpUserCurrentCultureConfigDto {
    name: string | undefined;
    displayName: string | undefined;
}

export class AbpUserFeatureConfigDto implements IAbpUserFeatureConfigDto {
    allFeatures!: { [key: string] : AbpStringValueDto; } | undefined;

    constructor(data?: IAbpUserFeatureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"]) {
                this.allFeatures = {} as any;
                for (let key in data["allFeatures"]) {
                    if (data["allFeatures"].hasOwnProperty(key))
                        this.allFeatures![key] = data["allFeatures"][key] ? AbpStringValueDto.fromJS(data["allFeatures"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserFeatureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserFeatureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures) {
            data["allFeatures"] = {};
            for (let key in this.allFeatures) {
                if (this.allFeatures.hasOwnProperty(key))
                    data["allFeatures"][key] = this.allFeatures[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserFeatureConfigDto {
    allFeatures: { [key: string] : AbpStringValueDto; } | undefined;
}

export class AbpUserIanaTimeZoneConfigDto implements IAbpUserIanaTimeZoneConfigDto {
    timeZoneId!: string | undefined;

    constructor(data?: IAbpUserIanaTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneId = data["timeZoneId"];
        }
    }

    static fromJS(data: any): AbpUserIanaTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserIanaTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data; 
    }
}

export interface IAbpUserIanaTimeZoneConfigDto {
    timeZoneId: string | undefined;
}

export class AbpUserLocalizationConfigDto implements IAbpUserLocalizationConfigDto {
    currentCulture!: AbpUserCurrentCultureConfigDto;
    languages!: LanguageInfo[] | undefined;
    currentLanguage!: LanguageInfo;
    sources!: AbpLocalizationSourceDto[] | undefined;
    values!: { [key: string] : { [key: string] : string; }; } | undefined;

    constructor(data?: IAbpUserLocalizationConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentCulture = data["currentCulture"] ? AbpUserCurrentCultureConfigDto.fromJS(data["currentCulture"]) : <any>undefined;
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(LanguageInfo.fromJS(item));
            }
            this.currentLanguage = data["currentLanguage"] ? LanguageInfo.fromJS(data["currentLanguage"]) : <any>undefined;
            if (data["sources"] && data["sources"].constructor === Array) {
                this.sources = [] as any;
                for (let item of data["sources"])
                    this.sources!.push(AbpLocalizationSourceDto.fromJS(item));
            }
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values![key] = data["values"][key] !== undefined ? data["values"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): AbpUserLocalizationConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserLocalizationConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        if (this.sources && this.sources.constructor === Array) {
            data["sources"] = [];
            for (let item of this.sources)
                data["sources"].push(item.toJSON());
        }
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserLocalizationConfigDto {
    currentCulture: AbpUserCurrentCultureConfigDto;
    languages: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo;
    sources: AbpLocalizationSourceDto[] | undefined;
    values: { [key: string] : { [key: string] : string; }; } | undefined;
}

export class AbpUserNavConfigDto implements IAbpUserNavConfigDto {
    menus!: { [key: string] : UserMenu; } | undefined;

    constructor(data?: IAbpUserNavConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["menus"]) {
                this.menus = {} as any;
                for (let key in data["menus"]) {
                    if (data["menus"].hasOwnProperty(key))
                        this.menus![key] = data["menus"][key] ? UserMenu.fromJS(data["menus"][key]) : new UserMenu();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserNavConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserNavConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.menus) {
            data["menus"] = {};
            for (let key in this.menus) {
                if (this.menus.hasOwnProperty(key))
                    data["menus"][key] = this.menus[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserNavConfigDto {
    menus: { [key: string] : UserMenu; } | undefined;
}

export class AbpUserSecurityConfigDto implements IAbpUserSecurityConfigDto {
    antiForgery!: AbpUserAntiForgeryConfigDto;

    constructor(data?: IAbpUserSecurityConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.antiForgery = data["antiForgery"] ? AbpUserAntiForgeryConfigDto.fromJS(data["antiForgery"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserSecurityConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSecurityConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["antiForgery"] = this.antiForgery ? this.antiForgery.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpUserSecurityConfigDto {
    antiForgery: AbpUserAntiForgeryConfigDto;
}

export class AbpUserSessionConfigDto implements IAbpUserSessionConfigDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    impersonatorTenantId!: number | undefined;
    multiTenancySide!: MultiTenancySides;

    constructor(data?: IAbpUserSessionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.multiTenancySide = data["multiTenancySide"];
        }
    }

    static fromJS(data: any): AbpUserSessionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSessionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["multiTenancySide"] = this.multiTenancySide;
        return data; 
    }
}

export interface IAbpUserSessionConfigDto {
    userId: number | undefined;
    tenantId: number | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    multiTenancySide: MultiTenancySides;
}

export class AbpUserSettingConfigDto implements IAbpUserSettingConfigDto {
    values!: { [key: string] : string; } | undefined;

    constructor(data?: IAbpUserSettingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values![key] = data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserSettingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSettingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }
}

export interface IAbpUserSettingConfigDto {
    values: { [key: string] : string; } | undefined;
}

export class AbpUserTimeZoneConfigDto implements IAbpUserTimeZoneConfigDto {
    windows!: AbpUserWindowsTimeZoneConfigDto;
    iana!: AbpUserIanaTimeZoneConfigDto;

    constructor(data?: IAbpUserTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.windows = data["windows"] ? AbpUserWindowsTimeZoneConfigDto.fromJS(data["windows"]) : <any>undefined;
            this.iana = data["iana"] ? AbpUserIanaTimeZoneConfigDto.fromJS(data["iana"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpUserTimeZoneConfigDto {
    windows: AbpUserWindowsTimeZoneConfigDto;
    iana: AbpUserIanaTimeZoneConfigDto;
}

export class AbpUserTimingConfigDto implements IAbpUserTimingConfigDto {
    timeZoneInfo!: AbpUserTimeZoneConfigDto;

    constructor(data?: IAbpUserTimingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneInfo = data["timeZoneInfo"] ? AbpUserTimeZoneConfigDto.fromJS(data["timeZoneInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneInfo"] = this.timeZoneInfo ? this.timeZoneInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAbpUserTimingConfigDto {
    timeZoneInfo: AbpUserTimeZoneConfigDto;
}

export class AbpUserWindowsTimeZoneConfigDto implements IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId!: string | undefined;
    baseUtcOffsetInMilliseconds!: number;
    currentUtcOffsetInMilliseconds!: number;
    isDaylightSavingTimeNow!: boolean;

    constructor(data?: IAbpUserWindowsTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneId = data["timeZoneId"];
            this.baseUtcOffsetInMilliseconds = data["baseUtcOffsetInMilliseconds"];
            this.currentUtcOffsetInMilliseconds = data["currentUtcOffsetInMilliseconds"];
            this.isDaylightSavingTimeNow = data["isDaylightSavingTimeNow"];
        }
    }

    static fromJS(data: any): AbpUserWindowsTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserWindowsTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        data["baseUtcOffsetInMilliseconds"] = this.baseUtcOffsetInMilliseconds;
        data["currentUtcOffsetInMilliseconds"] = this.currentUtcOffsetInMilliseconds;
        data["isDaylightSavingTimeNow"] = this.isDaylightSavingTimeNow;
        return data; 
    }
}

export interface IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId: string | undefined;
    baseUtcOffsetInMilliseconds: number;
    currentUtcOffsetInMilliseconds: number;
    isDaylightSavingTimeNow: boolean;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    features!: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features![key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    features: { [key: string] : boolean; } | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class AppMenuDto implements IAppMenuDto {
    menuId!: string | undefined;
    name!: string | undefined;
    permissionName!: string | undefined;
    icon!: string | undefined;
    route!: string | undefined;
    display!: string | undefined;
    items!: AppMenuDto[] | undefined;
    parentId!: string | undefined;
    parent!: AppMenuDto;
    external!: boolean;
    requiresAuthentication!: boolean;
    featureDependency!: string | undefined;
    parameters!: string[] | undefined;
    id!: string | undefined;

    constructor(data?: IAppMenuDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.name = data["name"];
            this.permissionName = data["permissionName"];
            this.icon = data["icon"];
            this.route = data["route"];
            this.display = data["display"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AppMenuDto.fromJS(item));
            }
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? AppMenuDto.fromJS(data["parent"]) : <any>undefined;
            this.external = data["external"];
            this.requiresAuthentication = data["requiresAuthentication"];
            this.featureDependency = data["featureDependency"];
            if (data["parameters"] && data["parameters"].constructor === Array) {
                this.parameters = [] as any;
                for (let item of data["parameters"])
                    this.parameters!.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AppMenuDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppMenuDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["name"] = this.name;
        data["permissionName"] = this.permissionName;
        data["icon"] = this.icon;
        data["route"] = this.route;
        data["display"] = this.display;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["external"] = this.external;
        data["requiresAuthentication"] = this.requiresAuthentication;
        data["featureDependency"] = this.featureDependency;
        if (this.parameters && this.parameters.constructor === Array) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IAppMenuDto {
    menuId: string | undefined;
    name: string | undefined;
    permissionName: string | undefined;
    icon: string | undefined;
    route: string | undefined;
    display: string | undefined;
    items: AppMenuDto[] | undefined;
    parentId: string | undefined;
    parent: AppMenuDto;
    external: boolean;
    requiresAuthentication: boolean;
    featureDependency: string | undefined;
    parameters: string[] | undefined;
    id: string | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    token!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.token = data["token"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["token"] = this.token;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    token: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    isLoginNoPassword!: boolean;
    impersonateOutput!: ImpersonateOutput;
    result!: string | undefined;
    errorDesc!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
            this.isLoginNoPassword = data["isLoginNoPassword"];
            this.impersonateOutput = data["impersonateOutput"] ? ImpersonateOutput.fromJS(data["impersonateOutput"]) : <any>undefined;
            this.result = data["result"];
            this.errorDesc = data["errorDesc"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["isLoginNoPassword"] = this.isLoginNoPassword;
        data["impersonateOutput"] = this.impersonateOutput ? this.impersonateOutput.toJSON() : <any>undefined;
        data["result"] = this.result;
        data["errorDesc"] = this.errorDesc;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    isLoginNoPassword: boolean;
    impersonateOutput: ImpersonateOutput;
    result: string | undefined;
    errorDesc: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export enum ChartDateInterval {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: moment.Moment;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: moment.Moment;
    sharedMessageId: string | undefined;
    id: number;
}

export enum ChatMessageReadState {
    Unread = 1, 
    Read = 2, 
}

export enum ChatSide {
    Sender = 1, 
    Receiver = 2, 
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class CM_ACCOUNT_KT_ENTITY implements ICM_ACCOUNT_KT_ENTITY {
    accounT_KT_ID!: string | undefined;
    accounT_KT_CODE!: string | undefined;
    accounT_KT_ACCOUNT!: string | undefined;
    accounT_KT_NAME!: string | undefined;
    accounT_KT_TYPE!: string | undefined;
    accounT_KT_TYPE_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    isChecked!: boolean | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    top!: number | undefined;
    totalCount!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_ACCOUNT_KT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accounT_KT_ID = data["accounT_KT_ID"];
            this.accounT_KT_CODE = data["accounT_KT_CODE"];
            this.accounT_KT_ACCOUNT = data["accounT_KT_ACCOUNT"];
            this.accounT_KT_NAME = data["accounT_KT_NAME"];
            this.accounT_KT_TYPE = data["accounT_KT_TYPE"];
            this.accounT_KT_TYPE_NAME = data["accounT_KT_TYPE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.isChecked = data["isChecked"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.top = data["top"];
            this.totalCount = data["totalCount"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_ACCOUNT_KT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ACCOUNT_KT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accounT_KT_ID"] = this.accounT_KT_ID;
        data["accounT_KT_CODE"] = this.accounT_KT_CODE;
        data["accounT_KT_ACCOUNT"] = this.accounT_KT_ACCOUNT;
        data["accounT_KT_NAME"] = this.accounT_KT_NAME;
        data["accounT_KT_TYPE"] = this.accounT_KT_TYPE;
        data["accounT_KT_TYPE_NAME"] = this.accounT_KT_TYPE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["isChecked"] = this.isChecked;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["top"] = this.top;
        data["totalCount"] = this.totalCount;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_ACCOUNT_KT_ENTITY {
    accounT_KT_ID: string | undefined;
    accounT_KT_CODE: string | undefined;
    accounT_KT_ACCOUNT: string | undefined;
    accounT_KT_NAME: string | undefined;
    accounT_KT_TYPE: string | undefined;
    accounT_KT_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isChecked: boolean | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    top: number | undefined;
    totalCount: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_ALLCODE_ENTITY implements ICM_ALLCODE_ENTITY {
    id!: number | undefined;
    cdname!: string | undefined;
    cdval!: string | undefined;
    content!: string | undefined;
    cdtype!: string | undefined;
    lstodr!: number | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_ALLCODE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cdname = data["cdname"];
            this.cdval = data["cdval"];
            this.content = data["content"];
            this.cdtype = data["cdtype"];
            this.lstodr = data["lstodr"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_ALLCODE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ALLCODE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cdname"] = this.cdname;
        data["cdval"] = this.cdval;
        data["content"] = this.content;
        data["cdtype"] = this.cdtype;
        data["lstodr"] = this.lstodr;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_ALLCODE_ENTITY {
    id: number | undefined;
    cdname: string | undefined;
    cdval: string | undefined;
    content: string | undefined;
    cdtype: string | undefined;
    lstodr: number | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_AREAS_ENTITY implements ICM_AREAS_ENTITY {
    areA_ID!: string | undefined;
    areA_CODE!: string | undefined;
    areA_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_AREAS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.areA_ID = data["areA_ID"];
            this.areA_CODE = data["areA_CODE"];
            this.areA_NAME = data["areA_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_AREAS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_AREAS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areA_ID"] = this.areA_ID;
        data["areA_CODE"] = this.areA_CODE;
        data["areA_NAME"] = this.areA_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_AREAS_ENTITY {
    areA_ID: string | undefined;
    areA_CODE: string | undefined;
    areA_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_ATTACH_FILE_ENTITY implements ICM_ATTACH_FILE_ENTITY {
    id!: number;
    attacH_ID!: string | undefined;
    type!: string | undefined;
    reF_ID!: string | undefined;
    filE_NAME_OLD!: string | undefined;
    patH_OLD!: string | undefined;
    filE_NAME_NEW!: string | undefined;
    patH_NEW!: string | undefined;
    filE_SIZE!: number | undefined;
    filE_TYPE!: string | undefined;
    attacH_DT!: moment.Moment | undefined;
    emP_ID!: string | undefined;
    index!: string | undefined;
    notes!: string | undefined;
    version!: string | undefined;
    action!: string | undefined;
    reF_MASTER!: string | undefined;
    attachDetail!: string | undefined;

    constructor(data?: ICM_ATTACH_FILE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.attacH_ID = data["attacH_ID"];
            this.type = data["type"];
            this.reF_ID = data["reF_ID"];
            this.filE_NAME_OLD = data["filE_NAME_OLD"];
            this.patH_OLD = data["patH_OLD"];
            this.filE_NAME_NEW = data["filE_NAME_NEW"];
            this.patH_NEW = data["patH_NEW"];
            this.filE_SIZE = data["filE_SIZE"];
            this.filE_TYPE = data["filE_TYPE"];
            this.attacH_DT = data["attacH_DT"] ? moment(data["attacH_DT"].toString()) : <any>undefined;
            this.emP_ID = data["emP_ID"];
            this.index = data["index"];
            this.notes = data["notes"];
            this.version = data["version"];
            this.action = data["action"];
            this.reF_MASTER = data["reF_MASTER"];
            this.attachDetail = data["attachDetail"];
        }
    }

    static fromJS(data: any): CM_ATTACH_FILE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ATTACH_FILE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attacH_ID"] = this.attacH_ID;
        data["type"] = this.type;
        data["reF_ID"] = this.reF_ID;
        data["filE_NAME_OLD"] = this.filE_NAME_OLD;
        data["patH_OLD"] = this.patH_OLD;
        data["filE_NAME_NEW"] = this.filE_NAME_NEW;
        data["patH_NEW"] = this.patH_NEW;
        data["filE_SIZE"] = this.filE_SIZE;
        data["filE_TYPE"] = this.filE_TYPE;
        data["attacH_DT"] = this.attacH_DT ? this.attacH_DT.toISOString() : <any>undefined;
        data["emP_ID"] = this.emP_ID;
        data["index"] = this.index;
        data["notes"] = this.notes;
        data["version"] = this.version;
        data["action"] = this.action;
        data["reF_MASTER"] = this.reF_MASTER;
        data["attachDetail"] = this.attachDetail;
        return data; 
    }
}

export interface ICM_ATTACH_FILE_ENTITY {
    id: number;
    attacH_ID: string | undefined;
    type: string | undefined;
    reF_ID: string | undefined;
    filE_NAME_OLD: string | undefined;
    patH_OLD: string | undefined;
    filE_NAME_NEW: string | undefined;
    patH_NEW: string | undefined;
    filE_SIZE: number | undefined;
    filE_TYPE: string | undefined;
    attacH_DT: moment.Moment | undefined;
    emP_ID: string | undefined;
    index: string | undefined;
    notes: string | undefined;
    version: string | undefined;
    action: string | undefined;
    reF_MASTER: string | undefined;
    attachDetail: string | undefined;
}

export class CM_ATTACH_FILE_INPUT implements ICM_ATTACH_FILE_INPUT {
    attachFile!: CM_ATTACH_FILE_ENTITY;
    childs!: CM_ATTACH_FILE_ENTITY[] | undefined;
    ids!: string | undefined;
    oldFiles!: string[] | undefined;
    newFiles!: string[] | undefined;

    constructor(data?: ICM_ATTACH_FILE_INPUT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attachFile = data["attachFile"] ? CM_ATTACH_FILE_ENTITY.fromJS(data["attachFile"]) : <any>undefined;
            if (data["childs"] && data["childs"].constructor === Array) {
                this.childs = [] as any;
                for (let item of data["childs"])
                    this.childs!.push(CM_ATTACH_FILE_ENTITY.fromJS(item));
            }
            this.ids = data["ids"];
            if (data["oldFiles"] && data["oldFiles"].constructor === Array) {
                this.oldFiles = [] as any;
                for (let item of data["oldFiles"])
                    this.oldFiles!.push(item);
            }
            if (data["newFiles"] && data["newFiles"].constructor === Array) {
                this.newFiles = [] as any;
                for (let item of data["newFiles"])
                    this.newFiles!.push(item);
            }
        }
    }

    static fromJS(data: any): CM_ATTACH_FILE_INPUT {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ATTACH_FILE_INPUT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachFile"] = this.attachFile ? this.attachFile.toJSON() : <any>undefined;
        if (this.childs && this.childs.constructor === Array) {
            data["childs"] = [];
            for (let item of this.childs)
                data["childs"].push(item.toJSON());
        }
        data["ids"] = this.ids;
        if (this.oldFiles && this.oldFiles.constructor === Array) {
            data["oldFiles"] = [];
            for (let item of this.oldFiles)
                data["oldFiles"].push(item);
        }
        if (this.newFiles && this.newFiles.constructor === Array) {
            data["newFiles"] = [];
            for (let item of this.newFiles)
                data["newFiles"].push(item);
        }
        return data; 
    }
}

export interface ICM_ATTACH_FILE_INPUT {
    attachFile: CM_ATTACH_FILE_ENTITY;
    childs: CM_ATTACH_FILE_ENTITY[] | undefined;
    ids: string | undefined;
    oldFiles: string[] | undefined;
    newFiles: string[] | undefined;
}

export class CM_ATTACH_FILE_MODEL implements ICM_ATTACH_FILE_MODEL {
    attacH_ID!: string | undefined;
    reF_ID!: string | undefined;
    filE_NAME!: string | undefined;

    constructor(data?: ICM_ATTACH_FILE_MODEL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attacH_ID = data["attacH_ID"];
            this.reF_ID = data["reF_ID"];
            this.filE_NAME = data["filE_NAME"];
        }
    }

    static fromJS(data: any): CM_ATTACH_FILE_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new CM_ATTACH_FILE_MODEL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attacH_ID"] = this.attacH_ID;
        data["reF_ID"] = this.reF_ID;
        data["filE_NAME"] = this.filE_NAME;
        return data; 
    }
}

export interface ICM_ATTACH_FILE_MODEL {
    attacH_ID: string | undefined;
    reF_ID: string | undefined;
    filE_NAME: string | undefined;
}

export class CM_BRANCH_ENTITY implements ICM_BRANCH_ENTITY {
    brancH_ID!: string | undefined;
    fatheR_ID!: string | undefined;
    iS_POTENTIAL!: string | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    daO_CODE!: string | undefined;
    daO_NAME!: string | undefined;
    regioN_ID!: string | undefined;
    brancH_TYPE!: string | undefined;
    addr!: string | undefined;
    provice!: string | undefined;
    tel!: string | undefined;
    taX_NO!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    f_BRANCH_CODE!: string | undefined;
    f_BRANCH_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    brancH_FILTER!: string | undefined;
    fatheR_CODE!: string | undefined;
    regioN_CODE!: string | undefined;
    regioN_NAME!: string | undefined;
    top!: number | undefined;
    brancH_LOGIN!: string | undefined;
    totalCount!: number | undefined;
    independenT_UNIT!: boolean | undefined;
    isChecked!: boolean | undefined;
    isLoadAll!: boolean | undefined;
    acC_CODE!: string | undefined;
    tlname!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_BRANCH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.brancH_ID = data["brancH_ID"];
            this.fatheR_ID = data["fatheR_ID"];
            this.iS_POTENTIAL = data["iS_POTENTIAL"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.regioN_ID = data["regioN_ID"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.addr = data["addr"];
            this.provice = data["provice"];
            this.tel = data["tel"];
            this.taX_NO = data["taX_NO"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.f_BRANCH_CODE = data["f_BRANCH_CODE"];
            this.f_BRANCH_NAME = data["f_BRANCH_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.brancH_FILTER = data["brancH_FILTER"];
            this.fatheR_CODE = data["fatheR_CODE"];
            this.regioN_CODE = data["regioN_CODE"];
            this.regioN_NAME = data["regioN_NAME"];
            this.top = data["top"];
            this.brancH_LOGIN = data["brancH_LOGIN"];
            this.totalCount = data["totalCount"];
            this.independenT_UNIT = data["independenT_UNIT"];
            this.isChecked = data["isChecked"];
            this.isLoadAll = data["isLoadAll"];
            this.acC_CODE = data["acC_CODE"];
            this.tlname = data["tlname"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_BRANCH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_BRANCH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brancH_ID"] = this.brancH_ID;
        data["fatheR_ID"] = this.fatheR_ID;
        data["iS_POTENTIAL"] = this.iS_POTENTIAL;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["regioN_ID"] = this.regioN_ID;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["addr"] = this.addr;
        data["provice"] = this.provice;
        data["tel"] = this.tel;
        data["taX_NO"] = this.taX_NO;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["f_BRANCH_CODE"] = this.f_BRANCH_CODE;
        data["f_BRANCH_NAME"] = this.f_BRANCH_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["brancH_FILTER"] = this.brancH_FILTER;
        data["fatheR_CODE"] = this.fatheR_CODE;
        data["regioN_CODE"] = this.regioN_CODE;
        data["regioN_NAME"] = this.regioN_NAME;
        data["top"] = this.top;
        data["brancH_LOGIN"] = this.brancH_LOGIN;
        data["totalCount"] = this.totalCount;
        data["independenT_UNIT"] = this.independenT_UNIT;
        data["isChecked"] = this.isChecked;
        data["isLoadAll"] = this.isLoadAll;
        data["acC_CODE"] = this.acC_CODE;
        data["tlname"] = this.tlname;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_BRANCH_ENTITY {
    brancH_ID: string | undefined;
    fatheR_ID: string | undefined;
    iS_POTENTIAL: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    regioN_ID: string | undefined;
    brancH_TYPE: string | undefined;
    addr: string | undefined;
    provice: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    f_BRANCH_CODE: string | undefined;
    f_BRANCH_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    brancH_FILTER: string | undefined;
    fatheR_CODE: string | undefined;
    regioN_CODE: string | undefined;
    regioN_NAME: string | undefined;
    top: number | undefined;
    brancH_LOGIN: string | undefined;
    totalCount: number | undefined;
    independenT_UNIT: boolean | undefined;
    isChecked: boolean | undefined;
    isLoadAll: boolean | undefined;
    acC_CODE: string | undefined;
    tlname: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_BRANCH_LEV_ENTITY implements ICM_BRANCH_LEV_ENTITY {
    areas!: CM_BRANCH_ENTITY[] | undefined;
    branchs!: CM_BRANCH_ENTITY[] | undefined;
    subBranchs!: CM_BRANCH_ENTITY[] | undefined;

    constructor(data?: ICM_BRANCH_LEV_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["areas"] && data["areas"].constructor === Array) {
                this.areas = [] as any;
                for (let item of data["areas"])
                    this.areas!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            if (data["branchs"] && data["branchs"].constructor === Array) {
                this.branchs = [] as any;
                for (let item of data["branchs"])
                    this.branchs!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
            if (data["subBranchs"] && data["subBranchs"].constructor === Array) {
                this.subBranchs = [] as any;
                for (let item of data["subBranchs"])
                    this.subBranchs!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CM_BRANCH_LEV_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_BRANCH_LEV_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.areas && this.areas.constructor === Array) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (this.branchs && this.branchs.constructor === Array) {
            data["branchs"] = [];
            for (let item of this.branchs)
                data["branchs"].push(item.toJSON());
        }
        if (this.subBranchs && this.subBranchs.constructor === Array) {
            data["subBranchs"] = [];
            for (let item of this.subBranchs)
                data["subBranchs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICM_BRANCH_LEV_ENTITY {
    areas: CM_BRANCH_ENTITY[] | undefined;
    branchs: CM_BRANCH_ENTITY[] | undefined;
    subBranchs: CM_BRANCH_ENTITY[] | undefined;
}

export class CM_CAR_TYPE_ENTITY implements ICM_CAR_TYPE_ENTITY {
    caR_TYPE_ID!: string | undefined;
    caR_TYPE_CODE!: string | undefined;
    caR_TYPE_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_CAR_TYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.caR_TYPE_ID = data["caR_TYPE_ID"];
            this.caR_TYPE_CODE = data["caR_TYPE_CODE"];
            this.caR_TYPE_NAME = data["caR_TYPE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_CAR_TYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_CAR_TYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caR_TYPE_ID"] = this.caR_TYPE_ID;
        data["caR_TYPE_CODE"] = this.caR_TYPE_CODE;
        data["caR_TYPE_NAME"] = this.caR_TYPE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_CAR_TYPE_ENTITY {
    caR_TYPE_ID: string | undefined;
    caR_TYPE_CODE: string | undefined;
    caR_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_COMPANY_ENTITY implements ICM_COMPANY_ENTITY {
    companY_ID!: string | undefined;
    companY_NAME!: string | undefined;
    companY_TYPE!: string | undefined;
    companY_PAR_VALUE_PER_SHARE!: number;
    companY_ADDRESS!: string | undefined;
    companY_TEL!: string | undefined;
    companY_TAX_NO!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;

    constructor(data?: ICM_COMPANY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companY_ID = data["companY_ID"];
            this.companY_NAME = data["companY_NAME"];
            this.companY_TYPE = data["companY_TYPE"];
            this.companY_PAR_VALUE_PER_SHARE = data["companY_PAR_VALUE_PER_SHARE"];
            this.companY_ADDRESS = data["companY_ADDRESS"];
            this.companY_TEL = data["companY_TEL"];
            this.companY_TAX_NO = data["companY_TAX_NO"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_COMPANY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_COMPANY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companY_ID"] = this.companY_ID;
        data["companY_NAME"] = this.companY_NAME;
        data["companY_TYPE"] = this.companY_TYPE;
        data["companY_PAR_VALUE_PER_SHARE"] = this.companY_PAR_VALUE_PER_SHARE;
        data["companY_ADDRESS"] = this.companY_ADDRESS;
        data["companY_TEL"] = this.companY_TEL;
        data["companY_TAX_NO"] = this.companY_TAX_NO;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_COMPANY_ENTITY {
    companY_ID: string | undefined;
    companY_NAME: string | undefined;
    companY_TYPE: string | undefined;
    companY_PAR_VALUE_PER_SHARE: number;
    companY_ADDRESS: string | undefined;
    companY_TEL: string | undefined;
    companY_TAX_NO: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
}

export class CM_DEPARTMENT_ENTITY implements ICM_DEPARTMENT_ENTITY {
    deP_ID!: string | undefined;
    deP_CODE!: string | undefined;
    deP_NAME!: string | undefined;
    daO_CODE!: string | undefined;
    daO_NAME!: string | undefined;
    brancH_ID!: string | undefined;
    brancH_NAME!: string | undefined;
    brancH_CODE!: string | undefined;
    grouP_ID!: string | undefined;
    grouP_NAME!: string | undefined;
    parenT_CODE!: string | undefined;
    parenT_NAME!: string | undefined;
    tel!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    khoI_ID!: string | undefined;
    tlname!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_DEPARTMENT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deP_ID = data["deP_ID"];
            this.deP_CODE = data["deP_CODE"];
            this.deP_NAME = data["deP_NAME"];
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_CODE = data["brancH_CODE"];
            this.grouP_ID = data["grouP_ID"];
            this.grouP_NAME = data["grouP_NAME"];
            this.parenT_CODE = data["parenT_CODE"];
            this.parenT_NAME = data["parenT_NAME"];
            this.tel = data["tel"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.khoI_ID = data["khoI_ID"];
            this.tlname = data["tlname"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DEPARTMENT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DEPARTMENT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deP_ID"] = this.deP_ID;
        data["deP_CODE"] = this.deP_CODE;
        data["deP_NAME"] = this.deP_NAME;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_CODE"] = this.brancH_CODE;
        data["grouP_ID"] = this.grouP_ID;
        data["grouP_NAME"] = this.grouP_NAME;
        data["parenT_CODE"] = this.parenT_CODE;
        data["parenT_NAME"] = this.parenT_NAME;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["khoI_ID"] = this.khoI_ID;
        data["tlname"] = this.tlname;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_DEPARTMENT_ENTITY {
    deP_ID: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    brancH_ID: string | undefined;
    brancH_NAME: string | undefined;
    brancH_CODE: string | undefined;
    grouP_ID: string | undefined;
    grouP_NAME: string | undefined;
    parenT_CODE: string | undefined;
    parenT_NAME: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    khoI_ID: string | undefined;
    tlname: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_DEPT_GROUP_ENTITY implements ICM_DEPT_GROUP_ENTITY {
    grouP_ID!: string | undefined;
    grouP_CODE!: string | undefined;
    grouP_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_DEPT_GROUP_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grouP_ID = data["grouP_ID"];
            this.grouP_CODE = data["grouP_CODE"];
            this.grouP_NAME = data["grouP_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DEPT_GROUP_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DEPT_GROUP_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grouP_ID"] = this.grouP_ID;
        data["grouP_CODE"] = this.grouP_CODE;
        data["grouP_NAME"] = this.grouP_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_DEPT_GROUP_ENTITY {
    grouP_ID: string | undefined;
    grouP_CODE: string | undefined;
    grouP_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_DISTRICT implements ICM_DISTRICT {
    diS_ID!: string | undefined;
    diS_CODE!: string | undefined;
    prO_ID!: string | undefined;
    diS_NAME!: string | undefined;
    diS_TYPE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    createdate!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeD_ID!: string | undefined;
    datE_APPROVE!: moment.Moment | undefined;

    constructor(data?: ICM_DISTRICT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diS_ID = data["diS_ID"];
            this.diS_CODE = data["diS_CODE"];
            this.prO_ID = data["prO_ID"];
            this.diS_NAME = data["diS_NAME"];
            this.diS_TYPE = data["diS_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_DISTRICT {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DISTRICT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diS_ID"] = this.diS_ID;
        data["diS_CODE"] = this.diS_CODE;
        data["prO_ID"] = this.prO_ID;
        data["diS_NAME"] = this.diS_NAME;
        data["diS_TYPE"] = this.diS_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_DISTRICT {
    diS_ID: string | undefined;
    diS_CODE: string | undefined;
    prO_ID: string | undefined;
    diS_NAME: string | undefined;
    diS_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_DIVISION_ENTITY implements ICM_DIVISION_ENTITY {
    diV_ID!: string | undefined;
    diV_CODE!: string | undefined;
    diV_NAME!: string | undefined;
    addr!: string | undefined;
    brancH_ID!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    brancH_LOGIN!: string | undefined;
    independenT_UNIT!: boolean | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_DIVISION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diV_ID = data["diV_ID"];
            this.diV_CODE = data["diV_CODE"];
            this.diV_NAME = data["diV_NAME"];
            this.addr = data["addr"];
            this.brancH_ID = data["brancH_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.brancH_LOGIN = data["brancH_LOGIN"];
            this.independenT_UNIT = data["independenT_UNIT"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_DIVISION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_DIVISION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diV_ID"] = this.diV_ID;
        data["diV_CODE"] = this.diV_CODE;
        data["diV_NAME"] = this.diV_NAME;
        data["addr"] = this.addr;
        data["brancH_ID"] = this.brancH_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["brancH_LOGIN"] = this.brancH_LOGIN;
        data["independenT_UNIT"] = this.independenT_UNIT;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_DIVISION_ENTITY {
    diV_ID: string | undefined;
    diV_CODE: string | undefined;
    diV_NAME: string | undefined;
    addr: string | undefined;
    brancH_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    brancH_LOGIN: string | undefined;
    independenT_UNIT: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_EMPLOYEE_ENTITY implements ICM_EMPLOYEE_ENTITY {
    emP_ID!: string | undefined;
    emP_CODE!: string | undefined;
    emP_NAME!: string | undefined;
    brancH_ID!: string | undefined;
    deP_ID!: string | undefined;
    brancH_TYPE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    autH_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    deP_NAME!: string | undefined;
    deP_NAME2!: string | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    khU_VUC!: string | undefined;
    chI_NHANH!: string | undefined;
    chI_NHANH_CODE!: string | undefined;
    pgd!: string | undefined;
    level!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_EMPLOYEE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emP_ID = data["emP_ID"];
            this.emP_CODE = data["emP_CODE"];
            this.emP_NAME = data["emP_NAME"];
            this.brancH_ID = data["brancH_ID"];
            this.deP_ID = data["deP_ID"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.deP_NAME = data["deP_NAME"];
            this.deP_NAME2 = data["deP_NAME2"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.khU_VUC = data["khU_VUC"];
            this.chI_NHANH = data["chI_NHANH"];
            this.chI_NHANH_CODE = data["chI_NHANH_CODE"];
            this.pgd = data["pgd"];
            this.level = data["level"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_EMPLOYEE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_EMPLOYEE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emP_ID"] = this.emP_ID;
        data["emP_CODE"] = this.emP_CODE;
        data["emP_NAME"] = this.emP_NAME;
        data["brancH_ID"] = this.brancH_ID;
        data["deP_ID"] = this.deP_ID;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["deP_NAME"] = this.deP_NAME;
        data["deP_NAME2"] = this.deP_NAME2;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["khU_VUC"] = this.khU_VUC;
        data["chI_NHANH"] = this.chI_NHANH;
        data["chI_NHANH_CODE"] = this.chI_NHANH_CODE;
        data["pgd"] = this.pgd;
        data["level"] = this.level;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_EMPLOYEE_ENTITY {
    emP_ID: string | undefined;
    emP_CODE: string | undefined;
    emP_NAME: string | undefined;
    brancH_ID: string | undefined;
    deP_ID: string | undefined;
    brancH_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    deP_NAME: string | undefined;
    deP_NAME2: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    khU_VUC: string | undefined;
    chI_NHANH: string | undefined;
    chI_NHANH_CODE: string | undefined;
    pgd: string | undefined;
    level: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_GOODS_ENTITY implements ICM_GOODS_ENTITY {
    gD_ID!: string | undefined;
    gD_CODE!: string | undefined;
    gD_NAME!: string | undefined;
    gD_TYPE_ID!: string | undefined;
    usE_BRANCH!: string | undefined;
    amorT_RATE!: number | undefined;
    description!: string | undefined;
    suP_ID!: string | undefined;
    price!: number | undefined;
    uniT_ID!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    uniT_CODE!: string | undefined;
    uniT_NAME!: string | undefined;
    gD_TYPE_NAME!: string | undefined;
    gD_TYPE_CODE!: string | undefined;
    suP_CODE!: string | undefined;
    suP_NAME!: string | undefined;
    cD_ID!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    isChecked!: boolean | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_GOODS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gD_ID = data["gD_ID"];
            this.gD_CODE = data["gD_CODE"];
            this.gD_NAME = data["gD_NAME"];
            this.gD_TYPE_ID = data["gD_TYPE_ID"];
            this.usE_BRANCH = data["usE_BRANCH"];
            this.amorT_RATE = data["amorT_RATE"];
            this.description = data["description"];
            this.suP_ID = data["suP_ID"];
            this.price = data["price"];
            this.uniT_ID = data["uniT_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.uniT_CODE = data["uniT_CODE"];
            this.uniT_NAME = data["uniT_NAME"];
            this.gD_TYPE_NAME = data["gD_TYPE_NAME"];
            this.gD_TYPE_CODE = data["gD_TYPE_CODE"];
            this.suP_CODE = data["suP_CODE"];
            this.suP_NAME = data["suP_NAME"];
            this.cD_ID = data["cD_ID"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.isChecked = data["isChecked"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_GOODS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_GOODS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gD_ID"] = this.gD_ID;
        data["gD_CODE"] = this.gD_CODE;
        data["gD_NAME"] = this.gD_NAME;
        data["gD_TYPE_ID"] = this.gD_TYPE_ID;
        data["usE_BRANCH"] = this.usE_BRANCH;
        data["amorT_RATE"] = this.amorT_RATE;
        data["description"] = this.description;
        data["suP_ID"] = this.suP_ID;
        data["price"] = this.price;
        data["uniT_ID"] = this.uniT_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["uniT_CODE"] = this.uniT_CODE;
        data["uniT_NAME"] = this.uniT_NAME;
        data["gD_TYPE_NAME"] = this.gD_TYPE_NAME;
        data["gD_TYPE_CODE"] = this.gD_TYPE_CODE;
        data["suP_CODE"] = this.suP_CODE;
        data["suP_NAME"] = this.suP_NAME;
        data["cD_ID"] = this.cD_ID;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["isChecked"] = this.isChecked;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_GOODS_ENTITY {
    gD_ID: string | undefined;
    gD_CODE: string | undefined;
    gD_NAME: string | undefined;
    gD_TYPE_ID: string | undefined;
    usE_BRANCH: string | undefined;
    amorT_RATE: number | undefined;
    description: string | undefined;
    suP_ID: string | undefined;
    price: number | undefined;
    uniT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    uniT_CODE: string | undefined;
    uniT_NAME: string | undefined;
    gD_TYPE_NAME: string | undefined;
    gD_TYPE_CODE: string | undefined;
    suP_CODE: string | undefined;
    suP_NAME: string | undefined;
    cD_ID: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_GOODSTYPE_ENTITY implements ICM_GOODSTYPE_ENTITY {
    gD_TYPE_ID!: string | undefined;
    gD_TYPE_CODE!: string | undefined;
    gD_TYPE_NAME!: string | undefined;
    asS_TYPE_ID!: string | undefined;
    parenT_ID!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    asS_TYPE_NAME!: string | undefined;
    parenT_NAME!: string | undefined;
    asS_TYPE_CODE!: string | undefined;
    parenT_CODE!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_GOODSTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gD_TYPE_ID = data["gD_TYPE_ID"];
            this.gD_TYPE_CODE = data["gD_TYPE_CODE"];
            this.gD_TYPE_NAME = data["gD_TYPE_NAME"];
            this.asS_TYPE_ID = data["asS_TYPE_ID"];
            this.parenT_ID = data["parenT_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.asS_TYPE_NAME = data["asS_TYPE_NAME"];
            this.parenT_NAME = data["parenT_NAME"];
            this.asS_TYPE_CODE = data["asS_TYPE_CODE"];
            this.parenT_CODE = data["parenT_CODE"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_GOODSTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_GOODSTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gD_TYPE_ID"] = this.gD_TYPE_ID;
        data["gD_TYPE_CODE"] = this.gD_TYPE_CODE;
        data["gD_TYPE_NAME"] = this.gD_TYPE_NAME;
        data["asS_TYPE_ID"] = this.asS_TYPE_ID;
        data["parenT_ID"] = this.parenT_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["asS_TYPE_NAME"] = this.asS_TYPE_NAME;
        data["parenT_NAME"] = this.parenT_NAME;
        data["asS_TYPE_CODE"] = this.asS_TYPE_CODE;
        data["parenT_CODE"] = this.parenT_CODE;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_GOODSTYPE_ENTITY {
    gD_TYPE_ID: string | undefined;
    gD_TYPE_CODE: string | undefined;
    gD_TYPE_NAME: string | undefined;
    asS_TYPE_ID: string | undefined;
    parenT_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    asS_TYPE_NAME: string | undefined;
    parenT_NAME: string | undefined;
    asS_TYPE_CODE: string | undefined;
    parenT_CODE: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_GOODSTYPE_REAL_ENTITY implements ICM_GOODSTYPE_REAL_ENTITY {
    gD_RETYPE_ID!: string | undefined;
    gD_RETYPE_CODE!: string | undefined;
    typE_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_GOODSTYPE_REAL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gD_RETYPE_ID = data["gD_RETYPE_ID"];
            this.gD_RETYPE_CODE = data["gD_RETYPE_CODE"];
            this.typE_NAME = data["typE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_GOODSTYPE_REAL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_GOODSTYPE_REAL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gD_RETYPE_ID"] = this.gD_RETYPE_ID;
        data["gD_RETYPE_CODE"] = this.gD_RETYPE_CODE;
        data["typE_NAME"] = this.typE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_GOODSTYPE_REAL_ENTITY {
    gD_RETYPE_ID: string | undefined;
    gD_RETYPE_CODE: string | undefined;
    typE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_IMAGE_ENTITY implements ICM_IMAGE_ENTITY {
    imagE_ID!: string | undefined;
    filE_NAME!: string | undefined;
    path!: string | undefined;
    reF_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    autH_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    basE64!: string | undefined;
    imagE_NAME!: string | undefined;

    constructor(data?: ICM_IMAGE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.imagE_ID = data["imagE_ID"];
            this.filE_NAME = data["filE_NAME"];
            this.path = data["path"];
            this.reF_ID = data["reF_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.basE64 = data["basE64"];
            this.imagE_NAME = data["imagE_NAME"];
        }
    }

    static fromJS(data: any): CM_IMAGE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_IMAGE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imagE_ID"] = this.imagE_ID;
        data["filE_NAME"] = this.filE_NAME;
        data["path"] = this.path;
        data["reF_ID"] = this.reF_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["basE64"] = this.basE64;
        data["imagE_NAME"] = this.imagE_NAME;
        return data; 
    }
}

export interface ICM_IMAGE_ENTITY {
    imagE_ID: string | undefined;
    filE_NAME: string | undefined;
    path: string | undefined;
    reF_ID: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    basE64: string | undefined;
    imagE_NAME: string | undefined;
}

export class CM_INSU_COMPANY_ENTITY implements ICM_INSU_COMPANY_ENTITY {
    insU_COMPANY_ID!: string | undefined;
    insU_COMPANY_CODE!: string | undefined;
    name!: string | undefined;
    addr!: string | undefined;
    email!: string | undefined;
    tel!: string | undefined;
    taX_NO!: string | undefined;
    contacT_PERSON!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_INSU_COMPANY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.insU_COMPANY_ID = data["insU_COMPANY_ID"];
            this.insU_COMPANY_CODE = data["insU_COMPANY_CODE"];
            this.name = data["name"];
            this.addr = data["addr"];
            this.email = data["email"];
            this.tel = data["tel"];
            this.taX_NO = data["taX_NO"];
            this.contacT_PERSON = data["contacT_PERSON"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_INSU_COMPANY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_INSU_COMPANY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["insU_COMPANY_ID"] = this.insU_COMPANY_ID;
        data["insU_COMPANY_CODE"] = this.insU_COMPANY_CODE;
        data["name"] = this.name;
        data["addr"] = this.addr;
        data["email"] = this.email;
        data["tel"] = this.tel;
        data["taX_NO"] = this.taX_NO;
        data["contacT_PERSON"] = this.contacT_PERSON;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_INSU_COMPANY_ENTITY {
    insU_COMPANY_ID: string | undefined;
    insU_COMPANY_CODE: string | undefined;
    name: string | undefined;
    addr: string | undefined;
    email: string | undefined;
    tel: string | undefined;
    taX_NO: string | undefined;
    contacT_PERSON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_KHOI_DT_ENTITY implements ICM_KHOI_DT_ENTITY {
    kdT_ID!: string | undefined;
    khoI_ID!: string | undefined;
    khoI_CODE!: string | undefined;
    khoI_NAME!: string | undefined;
    deP_ID!: string | undefined;
    brancH_ID!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    tscd!: number | undefined;
    ccld!: number | undefined;
    btsc!: number | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    deP_CODE!: string | undefined;
    deP_NAME!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_KHOI_DT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.kdT_ID = data["kdT_ID"];
            this.khoI_ID = data["khoI_ID"];
            this.khoI_CODE = data["khoI_CODE"];
            this.khoI_NAME = data["khoI_NAME"];
            this.deP_ID = data["deP_ID"];
            this.brancH_ID = data["brancH_ID"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.tscd = data["tscd"];
            this.ccld = data["ccld"];
            this.btsc = data["btsc"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.deP_CODE = data["deP_CODE"];
            this.deP_NAME = data["deP_NAME"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_KHOI_DT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_KHOI_DT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kdT_ID"] = this.kdT_ID;
        data["khoI_ID"] = this.khoI_ID;
        data["khoI_CODE"] = this.khoI_CODE;
        data["khoI_NAME"] = this.khoI_NAME;
        data["deP_ID"] = this.deP_ID;
        data["brancH_ID"] = this.brancH_ID;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["tscd"] = this.tscd;
        data["ccld"] = this.ccld;
        data["btsc"] = this.btsc;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["deP_CODE"] = this.deP_CODE;
        data["deP_NAME"] = this.deP_NAME;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_KHOI_DT_ENTITY {
    kdT_ID: string | undefined;
    khoI_ID: string | undefined;
    khoI_CODE: string | undefined;
    khoI_NAME: string | undefined;
    deP_ID: string | undefined;
    brancH_ID: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    tscd: number | undefined;
    ccld: number | undefined;
    btsc: number | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    deP_CODE: string | undefined;
    deP_NAME: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_KHOI_ENTITY implements ICM_KHOI_ENTITY {
    khoI_ID!: string | undefined;
    khoI_CODE!: string | undefined;
    khoI_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    cM_KHOI_DTs!: CM_KHOI_DT_ENTITY[] | undefined;
    cM_KHOI_XML!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_KHOI_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.khoI_ID = data["khoI_ID"];
            this.khoI_CODE = data["khoI_CODE"];
            this.khoI_NAME = data["khoI_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            if (data["cM_KHOI_DTs"] && data["cM_KHOI_DTs"].constructor === Array) {
                this.cM_KHOI_DTs = [] as any;
                for (let item of data["cM_KHOI_DTs"])
                    this.cM_KHOI_DTs!.push(CM_KHOI_DT_ENTITY.fromJS(item));
            }
            this.cM_KHOI_XML = data["cM_KHOI_XML"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_KHOI_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_KHOI_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["khoI_ID"] = this.khoI_ID;
        data["khoI_CODE"] = this.khoI_CODE;
        data["khoI_NAME"] = this.khoI_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        if (this.cM_KHOI_DTs && this.cM_KHOI_DTs.constructor === Array) {
            data["cM_KHOI_DTs"] = [];
            for (let item of this.cM_KHOI_DTs)
                data["cM_KHOI_DTs"].push(item.toJSON());
        }
        data["cM_KHOI_XML"] = this.cM_KHOI_XML;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_KHOI_ENTITY {
    khoI_ID: string | undefined;
    khoI_CODE: string | undefined;
    khoI_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    cM_KHOI_DTs: CM_KHOI_DT_ENTITY[] | undefined;
    cM_KHOI_XML: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_LOCATION_ENTITY implements ICM_LOCATION_ENTITY {
    districTs!: CM_DISTRICT[] | undefined;
    warDs!: CM_WARD[] | undefined;
    natioNs!: CM_NATION[] | undefined;
    provincEs!: CM_PROVINCE[] | undefined;

    constructor(data?: ICM_LOCATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["districTs"] && data["districTs"].constructor === Array) {
                this.districTs = [] as any;
                for (let item of data["districTs"])
                    this.districTs!.push(CM_DISTRICT.fromJS(item));
            }
            if (data["warDs"] && data["warDs"].constructor === Array) {
                this.warDs = [] as any;
                for (let item of data["warDs"])
                    this.warDs!.push(CM_WARD.fromJS(item));
            }
            if (data["natioNs"] && data["natioNs"].constructor === Array) {
                this.natioNs = [] as any;
                for (let item of data["natioNs"])
                    this.natioNs!.push(CM_NATION.fromJS(item));
            }
            if (data["provincEs"] && data["provincEs"].constructor === Array) {
                this.provincEs = [] as any;
                for (let item of data["provincEs"])
                    this.provincEs!.push(CM_PROVINCE.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CM_LOCATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_LOCATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.districTs && this.districTs.constructor === Array) {
            data["districTs"] = [];
            for (let item of this.districTs)
                data["districTs"].push(item.toJSON());
        }
        if (this.warDs && this.warDs.constructor === Array) {
            data["warDs"] = [];
            for (let item of this.warDs)
                data["warDs"].push(item.toJSON());
        }
        if (this.natioNs && this.natioNs.constructor === Array) {
            data["natioNs"] = [];
            for (let item of this.natioNs)
                data["natioNs"].push(item.toJSON());
        }
        if (this.provincEs && this.provincEs.constructor === Array) {
            data["provincEs"] = [];
            for (let item of this.provincEs)
                data["provincEs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICM_LOCATION_ENTITY {
    districTs: CM_DISTRICT[] | undefined;
    warDs: CM_WARD[] | undefined;
    natioNs: CM_NATION[] | undefined;
    provincEs: CM_PROVINCE[] | undefined;
}

export class CM_MANAGER_REGION_ENTITY implements ICM_MANAGER_REGION_ENTITY {
    manageR_ID!: string | undefined;
    tlname!: string | undefined;
    tlfullname!: string | undefined;
    tlsubbrid!: string | undefined;
    brancH_NAME!: string | undefined;
    brancH_CODE!: string | undefined;
    regioN_ID!: string | undefined;
    regioN_NAME!: string | undefined;
    regioN_CODE!: string | undefined;
    brancH_TYPE!: string | undefined;
    rolename!: string | undefined;
    rolE_ID!: string | undefined;
    totalCount!: number | undefined;
    brancH_ID!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_MANAGER_REGION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.manageR_ID = data["manageR_ID"];
            this.tlname = data["tlname"];
            this.tlfullname = data["tlfullname"];
            this.tlsubbrid = data["tlsubbrid"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_CODE = data["brancH_CODE"];
            this.regioN_ID = data["regioN_ID"];
            this.regioN_NAME = data["regioN_NAME"];
            this.regioN_CODE = data["regioN_CODE"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.rolename = data["rolename"];
            this.rolE_ID = data["rolE_ID"];
            this.totalCount = data["totalCount"];
            this.brancH_ID = data["brancH_ID"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_MANAGER_REGION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_MANAGER_REGION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["manageR_ID"] = this.manageR_ID;
        data["tlname"] = this.tlname;
        data["tlfullname"] = this.tlfullname;
        data["tlsubbrid"] = this.tlsubbrid;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_CODE"] = this.brancH_CODE;
        data["regioN_ID"] = this.regioN_ID;
        data["regioN_NAME"] = this.regioN_NAME;
        data["regioN_CODE"] = this.regioN_CODE;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["rolename"] = this.rolename;
        data["rolE_ID"] = this.rolE_ID;
        data["totalCount"] = this.totalCount;
        data["brancH_ID"] = this.brancH_ID;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_MANAGER_REGION_ENTITY {
    manageR_ID: string | undefined;
    tlname: string | undefined;
    tlfullname: string | undefined;
    tlsubbrid: string | undefined;
    brancH_NAME: string | undefined;
    brancH_CODE: string | undefined;
    regioN_ID: string | undefined;
    regioN_NAME: string | undefined;
    regioN_CODE: string | undefined;
    brancH_TYPE: string | undefined;
    rolename: string | undefined;
    rolE_ID: string | undefined;
    totalCount: number | undefined;
    brancH_ID: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_MODEL_ENTITY implements ICM_MODEL_ENTITY {
    mO_ID!: string | undefined;
    mO_CODE!: string | undefined;
    caR_TYPE_ID!: string | undefined;
    manufacturer!: string | undefined;
    poweR_RATE!: number | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    autH_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    mO_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    caR_TYPE_NAME!: string | undefined;
    manufactureR_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_MODEL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mO_ID = data["mO_ID"];
            this.mO_CODE = data["mO_CODE"];
            this.caR_TYPE_ID = data["caR_TYPE_ID"];
            this.manufacturer = data["manufacturer"];
            this.poweR_RATE = data["poweR_RATE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.mO_NAME = data["mO_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.caR_TYPE_NAME = data["caR_TYPE_NAME"];
            this.manufactureR_NAME = data["manufactureR_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_MODEL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_MODEL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mO_ID"] = this.mO_ID;
        data["mO_CODE"] = this.mO_CODE;
        data["caR_TYPE_ID"] = this.caR_TYPE_ID;
        data["manufacturer"] = this.manufacturer;
        data["poweR_RATE"] = this.poweR_RATE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["mO_NAME"] = this.mO_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["caR_TYPE_NAME"] = this.caR_TYPE_NAME;
        data["manufactureR_NAME"] = this.manufactureR_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_MODEL_ENTITY {
    mO_ID: string | undefined;
    mO_CODE: string | undefined;
    caR_TYPE_ID: string | undefined;
    manufacturer: string | undefined;
    poweR_RATE: number | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    mO_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    caR_TYPE_NAME: string | undefined;
    manufactureR_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_NATION implements ICM_NATION {
    naT_ID!: string | undefined;
    naT_CODE!: string | undefined;
    naT_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    createdate!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeD_ID!: string | undefined;
    datE_APPROVE!: moment.Moment | undefined;

    constructor(data?: ICM_NATION) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.naT_ID = data["naT_ID"];
            this.naT_CODE = data["naT_CODE"];
            this.naT_NAME = data["naT_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_NATION {
        data = typeof data === 'object' ? data : {};
        let result = new CM_NATION();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["naT_ID"] = this.naT_ID;
        data["naT_CODE"] = this.naT_CODE;
        data["naT_NAME"] = this.naT_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_NATION {
    naT_ID: string | undefined;
    naT_CODE: string | undefined;
    naT_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_PROVINCE implements ICM_PROVINCE {
    prO_ID!: string | undefined;
    prO_CODE!: string | undefined;
    naT_ID!: string | undefined;
    prO_NAME!: string | undefined;
    prO_TYPE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    createdate!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeD_ID!: string | undefined;
    datE_APPROVE!: moment.Moment | undefined;

    constructor(data?: ICM_PROVINCE) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.prO_ID = data["prO_ID"];
            this.prO_CODE = data["prO_CODE"];
            this.naT_ID = data["naT_ID"];
            this.prO_NAME = data["prO_NAME"];
            this.prO_TYPE = data["prO_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_PROVINCE {
        data = typeof data === 'object' ? data : {};
        let result = new CM_PROVINCE();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prO_ID"] = this.prO_ID;
        data["prO_CODE"] = this.prO_CODE;
        data["naT_ID"] = this.naT_ID;
        data["prO_NAME"] = this.prO_NAME;
        data["prO_TYPE"] = this.prO_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_PROVINCE {
    prO_ID: string | undefined;
    prO_CODE: string | undefined;
    naT_ID: string | undefined;
    prO_NAME: string | undefined;
    prO_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_REGION_ENTITY implements ICM_REGION_ENTITY {
    regioN_ID!: string | undefined;
    regioN_CODE!: string | undefined;
    regioN_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    cmManagerEntity!: CM_MANAGER_REGION_ENTITY[] | undefined;
    xmlData!: string | undefined;
    tlname!: string | undefined;
    brancH_ID!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_REGION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.regioN_ID = data["regioN_ID"];
            this.regioN_CODE = data["regioN_CODE"];
            this.regioN_NAME = data["regioN_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            if (data["cmManagerEntity"] && data["cmManagerEntity"].constructor === Array) {
                this.cmManagerEntity = [] as any;
                for (let item of data["cmManagerEntity"])
                    this.cmManagerEntity!.push(CM_MANAGER_REGION_ENTITY.fromJS(item));
            }
            this.xmlData = data["xmlData"];
            this.tlname = data["tlname"];
            this.brancH_ID = data["brancH_ID"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_REGION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REGION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regioN_ID"] = this.regioN_ID;
        data["regioN_CODE"] = this.regioN_CODE;
        data["regioN_NAME"] = this.regioN_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        if (this.cmManagerEntity && this.cmManagerEntity.constructor === Array) {
            data["cmManagerEntity"] = [];
            for (let item of this.cmManagerEntity)
                data["cmManagerEntity"].push(item.toJSON());
        }
        data["xmlData"] = this.xmlData;
        data["tlname"] = this.tlname;
        data["brancH_ID"] = this.brancH_ID;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_REGION_ENTITY {
    regioN_ID: string | undefined;
    regioN_CODE: string | undefined;
    regioN_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    cmManagerEntity: CM_MANAGER_REGION_ENTITY[] | undefined;
    xmlData: string | undefined;
    tlname: string | undefined;
    brancH_ID: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_REJECT_LOG_ENTITY implements ICM_REJECT_LOG_ENTITY {
    loG_ID!: string | undefined;
    stage!: string | undefined;
    trN_ID!: string | undefined;
    trN_TYPE!: string | undefined;
    loG_DT!: moment.Moment | undefined;
    autH_STAT!: string | undefined;
    reason!: string | undefined;
    iS_LATEST!: string | undefined;
    rejecteD_BY!: string | undefined;
    rejecteD_DT!: moment.Moment | undefined;
    lasteD_REASON!: string | undefined;
    emP_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_REJECT_LOG_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loG_ID = data["loG_ID"];
            this.stage = data["stage"];
            this.trN_ID = data["trN_ID"];
            this.trN_TYPE = data["trN_TYPE"];
            this.loG_DT = data["loG_DT"] ? moment(data["loG_DT"].toString()) : <any>undefined;
            this.autH_STAT = data["autH_STAT"];
            this.reason = data["reason"];
            this.iS_LATEST = data["iS_LATEST"];
            this.rejecteD_BY = data["rejecteD_BY"];
            this.rejecteD_DT = data["rejecteD_DT"] ? moment(data["rejecteD_DT"].toString()) : <any>undefined;
            this.lasteD_REASON = data["lasteD_REASON"];
            this.emP_NAME = data["emP_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_REJECT_LOG_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REJECT_LOG_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loG_ID"] = this.loG_ID;
        data["stage"] = this.stage;
        data["trN_ID"] = this.trN_ID;
        data["trN_TYPE"] = this.trN_TYPE;
        data["loG_DT"] = this.loG_DT ? this.loG_DT.toISOString() : <any>undefined;
        data["autH_STAT"] = this.autH_STAT;
        data["reason"] = this.reason;
        data["iS_LATEST"] = this.iS_LATEST;
        data["rejecteD_BY"] = this.rejecteD_BY;
        data["rejecteD_DT"] = this.rejecteD_DT ? this.rejecteD_DT.toISOString() : <any>undefined;
        data["lasteD_REASON"] = this.lasteD_REASON;
        data["emP_NAME"] = this.emP_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_REJECT_LOG_ENTITY {
    loG_ID: string | undefined;
    stage: string | undefined;
    trN_ID: string | undefined;
    trN_TYPE: string | undefined;
    loG_DT: moment.Moment | undefined;
    autH_STAT: string | undefined;
    reason: string | undefined;
    iS_LATEST: string | undefined;
    rejecteD_BY: string | undefined;
    rejecteD_DT: moment.Moment | undefined;
    lasteD_REASON: string | undefined;
    emP_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_REPORT_TEMPLATE_DETAIL_ENTITY implements ICM_REPORT_TEMPLATE_DETAIL_ENTITY {
    reporT_TEMPLATE_DETAIL_ID!: string | undefined;
    reporT_TEMPLATE_DETAIL_CONTENT!: string | undefined;
    reporT_TEMPLATE_ID!: string | undefined;
    reporT_TEMPLATE_DETAIL_CODE!: string | undefined;
    pagE_SIZE!: string | undefined;
    notes!: string | undefined;
    isDefault!: boolean;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    no!: number;
    page!: number;
    isChecked!: boolean | undefined;

    constructor(data?: ICM_REPORT_TEMPLATE_DETAIL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reporT_TEMPLATE_DETAIL_ID = data["reporT_TEMPLATE_DETAIL_ID"];
            this.reporT_TEMPLATE_DETAIL_CONTENT = data["reporT_TEMPLATE_DETAIL_CONTENT"];
            this.reporT_TEMPLATE_ID = data["reporT_TEMPLATE_ID"];
            this.reporT_TEMPLATE_DETAIL_CODE = data["reporT_TEMPLATE_DETAIL_CODE"];
            this.pagE_SIZE = data["pagE_SIZE"];
            this.notes = data["notes"];
            this.isDefault = data["isDefault"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.no = data["no"];
            this.page = data["page"];
            this.isChecked = data["isChecked"];
        }
    }

    static fromJS(data: any): CM_REPORT_TEMPLATE_DETAIL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REPORT_TEMPLATE_DETAIL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reporT_TEMPLATE_DETAIL_ID"] = this.reporT_TEMPLATE_DETAIL_ID;
        data["reporT_TEMPLATE_DETAIL_CONTENT"] = this.reporT_TEMPLATE_DETAIL_CONTENT;
        data["reporT_TEMPLATE_ID"] = this.reporT_TEMPLATE_ID;
        data["reporT_TEMPLATE_DETAIL_CODE"] = this.reporT_TEMPLATE_DETAIL_CODE;
        data["pagE_SIZE"] = this.pagE_SIZE;
        data["notes"] = this.notes;
        data["isDefault"] = this.isDefault;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["no"] = this.no;
        data["page"] = this.page;
        data["isChecked"] = this.isChecked;
        return data; 
    }
}

export interface ICM_REPORT_TEMPLATE_DETAIL_ENTITY {
    reporT_TEMPLATE_DETAIL_ID: string | undefined;
    reporT_TEMPLATE_DETAIL_CONTENT: string | undefined;
    reporT_TEMPLATE_ID: string | undefined;
    reporT_TEMPLATE_DETAIL_CODE: string | undefined;
    pagE_SIZE: string | undefined;
    notes: string | undefined;
    isDefault: boolean;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    no: number;
    page: number;
    isChecked: boolean | undefined;
}

export class CM_REPORT_TEMPLATE_ENTITY implements ICM_REPORT_TEMPLATE_ENTITY {
    reporT_TEMPLATE_ID!: string | undefined;
    reporT_TEMPLATE_NAME!: string | undefined;
    reporT_TEMPLATE_STORE!: string | undefined;
    reporT_TEMPLATE_CODE!: string | undefined;
    notes!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    reporT_TEMPLATE_DETAILs!: CM_REPORT_TEMPLATE_DETAIL_ENTITY[] | undefined;
    reporT_TEMPLATE_DETAIL_XML!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_REPORT_TEMPLATE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reporT_TEMPLATE_ID = data["reporT_TEMPLATE_ID"];
            this.reporT_TEMPLATE_NAME = data["reporT_TEMPLATE_NAME"];
            this.reporT_TEMPLATE_STORE = data["reporT_TEMPLATE_STORE"];
            this.reporT_TEMPLATE_CODE = data["reporT_TEMPLATE_CODE"];
            this.notes = data["notes"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            if (data["reporT_TEMPLATE_DETAILs"] && data["reporT_TEMPLATE_DETAILs"].constructor === Array) {
                this.reporT_TEMPLATE_DETAILs = [] as any;
                for (let item of data["reporT_TEMPLATE_DETAILs"])
                    this.reporT_TEMPLATE_DETAILs!.push(CM_REPORT_TEMPLATE_DETAIL_ENTITY.fromJS(item));
            }
            this.reporT_TEMPLATE_DETAIL_XML = data["reporT_TEMPLATE_DETAIL_XML"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_REPORT_TEMPLATE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_REPORT_TEMPLATE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reporT_TEMPLATE_ID"] = this.reporT_TEMPLATE_ID;
        data["reporT_TEMPLATE_NAME"] = this.reporT_TEMPLATE_NAME;
        data["reporT_TEMPLATE_STORE"] = this.reporT_TEMPLATE_STORE;
        data["reporT_TEMPLATE_CODE"] = this.reporT_TEMPLATE_CODE;
        data["notes"] = this.notes;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        if (this.reporT_TEMPLATE_DETAILs && this.reporT_TEMPLATE_DETAILs.constructor === Array) {
            data["reporT_TEMPLATE_DETAILs"] = [];
            for (let item of this.reporT_TEMPLATE_DETAILs)
                data["reporT_TEMPLATE_DETAILs"].push(item.toJSON());
        }
        data["reporT_TEMPLATE_DETAIL_XML"] = this.reporT_TEMPLATE_DETAIL_XML;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_REPORT_TEMPLATE_ENTITY {
    reporT_TEMPLATE_ID: string | undefined;
    reporT_TEMPLATE_NAME: string | undefined;
    reporT_TEMPLATE_STORE: string | undefined;
    reporT_TEMPLATE_CODE: string | undefined;
    notes: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    reporT_TEMPLATE_DETAILs: CM_REPORT_TEMPLATE_DETAIL_ENTITY[] | undefined;
    reporT_TEMPLATE_DETAIL_XML: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_SECUR_INFO_ENTITY implements ICM_SECUR_INFO_ENTITY {
    secuR_INFO_ID!: string | undefined;
    secuR_INFO_CODE!: string | undefined;
    secuR_INFO_NAME!: string | undefined;
    secuR_INFO_NOTES!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    isChecked!: boolean | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    top!: number | undefined;
    totalCount!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_SECUR_INFO_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.secuR_INFO_ID = data["secuR_INFO_ID"];
            this.secuR_INFO_CODE = data["secuR_INFO_CODE"];
            this.secuR_INFO_NAME = data["secuR_INFO_NAME"];
            this.secuR_INFO_NOTES = data["secuR_INFO_NOTES"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.isChecked = data["isChecked"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.top = data["top"];
            this.totalCount = data["totalCount"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_SECUR_INFO_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_SECUR_INFO_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["secuR_INFO_ID"] = this.secuR_INFO_ID;
        data["secuR_INFO_CODE"] = this.secuR_INFO_CODE;
        data["secuR_INFO_NAME"] = this.secuR_INFO_NAME;
        data["secuR_INFO_NOTES"] = this.secuR_INFO_NOTES;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["isChecked"] = this.isChecked;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["top"] = this.top;
        data["totalCount"] = this.totalCount;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_SECUR_INFO_ENTITY {
    secuR_INFO_ID: string | undefined;
    secuR_INFO_CODE: string | undefined;
    secuR_INFO_NAME: string | undefined;
    secuR_INFO_NOTES: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isChecked: boolean | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    top: number | undefined;
    totalCount: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_SUPPLIER_ENTITY implements ICM_SUPPLIER_ENTITY {
    suP_ID!: string | undefined;
    suP_CODE!: string | undefined;
    suP_NAME!: string | undefined;
    suP_TYPE_ID!: string | undefined;
    suP_TYPE_NAME!: string | undefined;
    regioN_ID!: string | undefined;
    regioN_NAME!: string | undefined;
    addr!: string | undefined;
    email!: string | undefined;
    taX_NO!: string | undefined;
    tel!: string | undefined;
    contacT_PERSON!: string | undefined;
    disciplines!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    disciplineS_NAME!: string | undefined;
    isChecked!: boolean | undefined;
    totalCount!: number | undefined;
    lasT_RATE_AVG!: number | undefined;
    lasT_RATE_DT!: moment.Moment | undefined;
    mA_CONG_NO!: string | undefined;
    brancH_TYPE!: string | undefined;
    brancH_ID!: string | undefined;
    brancH_LOGIN!: string | undefined;
    useR_LOGIN!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_SUPPLIER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.suP_ID = data["suP_ID"];
            this.suP_CODE = data["suP_CODE"];
            this.suP_NAME = data["suP_NAME"];
            this.suP_TYPE_ID = data["suP_TYPE_ID"];
            this.suP_TYPE_NAME = data["suP_TYPE_NAME"];
            this.regioN_ID = data["regioN_ID"];
            this.regioN_NAME = data["regioN_NAME"];
            this.addr = data["addr"];
            this.email = data["email"];
            this.taX_NO = data["taX_NO"];
            this.tel = data["tel"];
            this.contacT_PERSON = data["contacT_PERSON"];
            this.disciplines = data["disciplines"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.disciplineS_NAME = data["disciplineS_NAME"];
            this.isChecked = data["isChecked"];
            this.totalCount = data["totalCount"];
            this.lasT_RATE_AVG = data["lasT_RATE_AVG"];
            this.lasT_RATE_DT = data["lasT_RATE_DT"] ? moment(data["lasT_RATE_DT"].toString()) : <any>undefined;
            this.mA_CONG_NO = data["mA_CONG_NO"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_LOGIN = data["brancH_LOGIN"];
            this.useR_LOGIN = data["useR_LOGIN"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_SUPPLIER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_SUPPLIER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suP_ID"] = this.suP_ID;
        data["suP_CODE"] = this.suP_CODE;
        data["suP_NAME"] = this.suP_NAME;
        data["suP_TYPE_ID"] = this.suP_TYPE_ID;
        data["suP_TYPE_NAME"] = this.suP_TYPE_NAME;
        data["regioN_ID"] = this.regioN_ID;
        data["regioN_NAME"] = this.regioN_NAME;
        data["addr"] = this.addr;
        data["email"] = this.email;
        data["taX_NO"] = this.taX_NO;
        data["tel"] = this.tel;
        data["contacT_PERSON"] = this.contacT_PERSON;
        data["disciplines"] = this.disciplines;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["disciplineS_NAME"] = this.disciplineS_NAME;
        data["isChecked"] = this.isChecked;
        data["totalCount"] = this.totalCount;
        data["lasT_RATE_AVG"] = this.lasT_RATE_AVG;
        data["lasT_RATE_DT"] = this.lasT_RATE_DT ? this.lasT_RATE_DT.toISOString() : <any>undefined;
        data["mA_CONG_NO"] = this.mA_CONG_NO;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_LOGIN"] = this.brancH_LOGIN;
        data["useR_LOGIN"] = this.useR_LOGIN;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_SUPPLIER_ENTITY {
    suP_ID: string | undefined;
    suP_CODE: string | undefined;
    suP_NAME: string | undefined;
    suP_TYPE_ID: string | undefined;
    suP_TYPE_NAME: string | undefined;
    regioN_ID: string | undefined;
    regioN_NAME: string | undefined;
    addr: string | undefined;
    email: string | undefined;
    taX_NO: string | undefined;
    tel: string | undefined;
    contacT_PERSON: string | undefined;
    disciplines: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    disciplineS_NAME: string | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    lasT_RATE_AVG: number | undefined;
    lasT_RATE_DT: moment.Moment | undefined;
    mA_CONG_NO: string | undefined;
    brancH_TYPE: string | undefined;
    brancH_ID: string | undefined;
    brancH_LOGIN: string | undefined;
    useR_LOGIN: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_SUPPLIERTYPE_ENTITY implements ICM_SUPPLIERTYPE_ENTITY {
    suP_TYPE_ID!: string | undefined;
    suP_TYPE_CODE!: string | undefined;
    suP_TYPE_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_SUPPLIERTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.suP_TYPE_ID = data["suP_TYPE_ID"];
            this.suP_TYPE_CODE = data["suP_TYPE_CODE"];
            this.suP_TYPE_NAME = data["suP_TYPE_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_SUPPLIERTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_SUPPLIERTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suP_TYPE_ID"] = this.suP_TYPE_ID;
        data["suP_TYPE_CODE"] = this.suP_TYPE_CODE;
        data["suP_TYPE_NAME"] = this.suP_TYPE_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_SUPPLIERTYPE_ENTITY {
    suP_TYPE_ID: string | undefined;
    suP_TYPE_CODE: string | undefined;
    suP_TYPE_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_TERM_ENTITY implements ICM_TERM_ENTITY {
    terM_ID!: string | undefined;
    terM_CODE!: string | undefined;
    terM_NAME!: string | undefined;
    terM_DATE!: moment.Moment | undefined;
    notes!: string | undefined;
    brancH_CREATE!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    brancH_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    isChecked!: boolean | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    asseT_FLOG_CODE!: string | undefined;
    asseT_SERIAL_NO!: string | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_TERM_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.terM_ID = data["terM_ID"];
            this.terM_CODE = data["terM_CODE"];
            this.terM_NAME = data["terM_NAME"];
            this.terM_DATE = data["terM_DATE"] ? moment(data["terM_DATE"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.brancH_CREATE = data["brancH_CREATE"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.brancH_NAME = data["brancH_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.isChecked = data["isChecked"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.asseT_FLOG_CODE = data["asseT_FLOG_CODE"];
            this.asseT_SERIAL_NO = data["asseT_SERIAL_NO"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_TERM_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_TERM_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["terM_ID"] = this.terM_ID;
        data["terM_CODE"] = this.terM_CODE;
        data["terM_NAME"] = this.terM_NAME;
        data["terM_DATE"] = this.terM_DATE ? this.terM_DATE.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["brancH_CREATE"] = this.brancH_CREATE;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["brancH_NAME"] = this.brancH_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["isChecked"] = this.isChecked;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["asseT_FLOG_CODE"] = this.asseT_FLOG_CODE;
        data["asseT_SERIAL_NO"] = this.asseT_SERIAL_NO;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_TERM_ENTITY {
    terM_ID: string | undefined;
    terM_CODE: string | undefined;
    terM_NAME: string | undefined;
    terM_DATE: moment.Moment | undefined;
    notes: string | undefined;
    brancH_CREATE: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    brancH_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    isChecked: boolean | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    asseT_FLOG_CODE: string | undefined;
    asseT_SERIAL_NO: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_UNIT_ENTITY implements ICM_UNIT_ENTITY {
    uniT_ID!: string | undefined;
    uniT_CODE!: string | undefined;
    uniT_NAME!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS_NAME!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_UNIT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uniT_ID = data["uniT_ID"];
            this.uniT_CODE = data["uniT_CODE"];
            this.uniT_NAME = data["uniT_NAME"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_UNIT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_UNIT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uniT_ID"] = this.uniT_ID;
        data["uniT_CODE"] = this.uniT_CODE;
        data["uniT_NAME"] = this.uniT_NAME;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_UNIT_ENTITY {
    uniT_ID: string | undefined;
    uniT_CODE: string | undefined;
    uniT_NAME: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS_NAME: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_WARD implements ICM_WARD {
    waR_ID!: string | undefined;
    waR_CODE!: string | undefined;
    diS_ID!: string | undefined;
    waR_NAME!: string | undefined;
    waR_TYPE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    createdate!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeD_ID!: string | undefined;
    datE_APPROVE!: moment.Moment | undefined;

    constructor(data?: ICM_WARD) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.waR_ID = data["waR_ID"];
            this.waR_CODE = data["waR_CODE"];
            this.diS_ID = data["diS_ID"];
            this.waR_NAME = data["waR_NAME"];
            this.waR_TYPE = data["waR_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.createdate = data["createdate"] ? moment(data["createdate"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeD_ID = data["checkeD_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CM_WARD {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WARD();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waR_ID"] = this.waR_ID;
        data["waR_CODE"] = this.waR_CODE;
        data["diS_ID"] = this.diS_ID;
        data["waR_NAME"] = this.waR_NAME;
        data["waR_TYPE"] = this.waR_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["createdate"] = this.createdate ? this.createdate.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeD_ID"] = this.checkeD_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICM_WARD {
    waR_ID: string | undefined;
    waR_CODE: string | undefined;
    diS_ID: string | undefined;
    waR_NAME: string | undefined;
    waR_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    createdate: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeD_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
}

export class CM_WORKFLOW_ASSIGN_ENTITY implements ICM_WORKFLOW_ASSIGN_ENTITY {
    wF_ASSIGN_ID!: string | undefined;
    workfloW_ID!: string | undefined;
    workfloW_STEP!: number | undefined;
    assigns!: string | undefined;
    limiT_VALUE_FROM!: number | undefined;
    limiT_VALUE_TO!: number | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS!: string | undefined;
    no!: number;
    page!: number;
    isChecked!: boolean | undefined;

    constructor(data?: ICM_WORKFLOW_ASSIGN_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wF_ASSIGN_ID = data["wF_ASSIGN_ID"];
            this.workfloW_ID = data["workfloW_ID"];
            this.workfloW_STEP = data["workfloW_STEP"];
            this.assigns = data["assigns"];
            this.limiT_VALUE_FROM = data["limiT_VALUE_FROM"];
            this.limiT_VALUE_TO = data["limiT_VALUE_TO"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS = data["recorD_STATUS"];
            this.no = data["no"];
            this.page = data["page"];
            this.isChecked = data["isChecked"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_ASSIGN_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_ASSIGN_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wF_ASSIGN_ID"] = this.wF_ASSIGN_ID;
        data["workfloW_ID"] = this.workfloW_ID;
        data["workfloW_STEP"] = this.workfloW_STEP;
        data["assigns"] = this.assigns;
        data["limiT_VALUE_FROM"] = this.limiT_VALUE_FROM;
        data["limiT_VALUE_TO"] = this.limiT_VALUE_TO;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["no"] = this.no;
        data["page"] = this.page;
        data["isChecked"] = this.isChecked;
        return data; 
    }
}

export interface ICM_WORKFLOW_ASSIGN_ENTITY {
    wF_ASSIGN_ID: string | undefined;
    workfloW_ID: string | undefined;
    workfloW_STEP: number | undefined;
    assigns: string | undefined;
    limiT_VALUE_FROM: number | undefined;
    limiT_VALUE_TO: number | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS: string | undefined;
    no: number;
    page: number;
    isChecked: boolean | undefined;
}

export class CM_WORKFLOW_ENTITY implements ICM_WORKFLOW_ENTITY {
    workfloW_ID!: string | undefined;
    functioN_ID!: string | undefined;
    menU_NAME!: string | undefined;
    approvE_LEVEL!: string | undefined;
    steP_NUMBERS!: number | undefined;
    nexT_LEVEL!: string | undefined;
    limiT_VALUE_FROM!: number | undefined;
    limiT_VALUE_FROM_FROM!: number | undefined;
    limiT_VALUE_FROM_TO!: number | undefined;
    limiT_VALUE_TO!: number | undefined;
    limiT_VALUE_TO_FROM!: number | undefined;
    limiT_VALUE_TO_TO!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    workfloW_ASSIGNs!: CM_WORKFLOW_ASSIGN_ENTITY[] | undefined;
    workfloW_ASSIGN_XML!: string | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICM_WORKFLOW_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workfloW_ID = data["workfloW_ID"];
            this.functioN_ID = data["functioN_ID"];
            this.menU_NAME = data["menU_NAME"];
            this.approvE_LEVEL = data["approvE_LEVEL"];
            this.steP_NUMBERS = data["steP_NUMBERS"];
            this.nexT_LEVEL = data["nexT_LEVEL"];
            this.limiT_VALUE_FROM = data["limiT_VALUE_FROM"];
            this.limiT_VALUE_FROM_FROM = data["limiT_VALUE_FROM_FROM"];
            this.limiT_VALUE_FROM_TO = data["limiT_VALUE_FROM_TO"];
            this.limiT_VALUE_TO = data["limiT_VALUE_TO"];
            this.limiT_VALUE_TO_FROM = data["limiT_VALUE_TO_FROM"];
            this.limiT_VALUE_TO_TO = data["limiT_VALUE_TO_TO"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            if (data["workfloW_ASSIGNs"] && data["workfloW_ASSIGNs"].constructor === Array) {
                this.workfloW_ASSIGNs = [] as any;
                for (let item of data["workfloW_ASSIGNs"])
                    this.workfloW_ASSIGNs!.push(CM_WORKFLOW_ASSIGN_ENTITY.fromJS(item));
            }
            this.workfloW_ASSIGN_XML = data["workfloW_ASSIGN_XML"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workfloW_ID"] = this.workfloW_ID;
        data["functioN_ID"] = this.functioN_ID;
        data["menU_NAME"] = this.menU_NAME;
        data["approvE_LEVEL"] = this.approvE_LEVEL;
        data["steP_NUMBERS"] = this.steP_NUMBERS;
        data["nexT_LEVEL"] = this.nexT_LEVEL;
        data["limiT_VALUE_FROM"] = this.limiT_VALUE_FROM;
        data["limiT_VALUE_FROM_FROM"] = this.limiT_VALUE_FROM_FROM;
        data["limiT_VALUE_FROM_TO"] = this.limiT_VALUE_FROM_TO;
        data["limiT_VALUE_TO"] = this.limiT_VALUE_TO;
        data["limiT_VALUE_TO_FROM"] = this.limiT_VALUE_TO_FROM;
        data["limiT_VALUE_TO_TO"] = this.limiT_VALUE_TO_TO;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        if (this.workfloW_ASSIGNs && this.workfloW_ASSIGNs.constructor === Array) {
            data["workfloW_ASSIGNs"] = [];
            for (let item of this.workfloW_ASSIGNs)
                data["workfloW_ASSIGNs"].push(item.toJSON());
        }
        data["workfloW_ASSIGN_XML"] = this.workfloW_ASSIGN_XML;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICM_WORKFLOW_ENTITY {
    workfloW_ID: string | undefined;
    functioN_ID: string | undefined;
    menU_NAME: string | undefined;
    approvE_LEVEL: string | undefined;
    steP_NUMBERS: number | undefined;
    nexT_LEVEL: string | undefined;
    limiT_VALUE_FROM: number | undefined;
    limiT_VALUE_FROM_FROM: number | undefined;
    limiT_VALUE_FROM_TO: number | undefined;
    limiT_VALUE_TO: number | undefined;
    limiT_VALUE_TO_FROM: number | undefined;
    limiT_VALUE_TO_TO: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    workfloW_ASSIGNs: CM_WORKFLOW_ASSIGN_ENTITY[] | undefined;
    workfloW_ASSIGN_XML: string | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CM_WORKFLOW_REJECT_MODEL implements ICM_WORKFLOW_REJECT_MODEL {
    modeL_ID!: string | undefined;
    checkeR_ID!: string | undefined;
    functioN_ID!: string | undefined;
    notes!: string | undefined;
    tlsubbrid!: string | undefined;
    tablE_NAME!: string | undefined;
    primarY_KEY_NAME!: string | undefined;

    constructor(data?: ICM_WORKFLOW_REJECT_MODEL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.modeL_ID = data["modeL_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.functioN_ID = data["functioN_ID"];
            this.notes = data["notes"];
            this.tlsubbrid = data["tlsubbrid"];
            this.tablE_NAME = data["tablE_NAME"];
            this.primarY_KEY_NAME = data["primarY_KEY_NAME"];
        }
    }

    static fromJS(data: any): CM_WORKFLOW_REJECT_MODEL {
        data = typeof data === 'object' ? data : {};
        let result = new CM_WORKFLOW_REJECT_MODEL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["modeL_ID"] = this.modeL_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["functioN_ID"] = this.functioN_ID;
        data["notes"] = this.notes;
        data["tlsubbrid"] = this.tlsubbrid;
        data["tablE_NAME"] = this.tablE_NAME;
        data["primarY_KEY_NAME"] = this.primarY_KEY_NAME;
        return data; 
    }
}

export interface ICM_WORKFLOW_REJECT_MODEL {
    modeL_ID: string | undefined;
    checkeR_ID: string | undefined;
    functioN_ID: string | undefined;
    notes: string | undefined;
    tlsubbrid: string | undefined;
    tablE_NAME: string | undefined;
    primarY_KEY_NAME: string | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class CommonResult implements ICommonResult {
    result!: string | undefined;
    errorDesc!: string | undefined;
    attr1!: string | undefined;
    attr2!: string | undefined;
    attr3!: string | undefined;
    attr4!: string | undefined;
    attr5!: string | undefined;

    constructor(data?: ICommonResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.errorDesc = data["errorDesc"];
            this.attr1 = data["attr1"];
            this.attr2 = data["attr2"];
            this.attr3 = data["attr3"];
            this.attr4 = data["attr4"];
            this.attr5 = data["attr5"];
        }
    }

    static fromJS(data: any): CommonResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommonResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["errorDesc"] = this.errorDesc;
        data["attr1"] = this.attr1;
        data["attr2"] = this.attr2;
        data["attr3"] = this.attr3;
        data["attr4"] = this.attr4;
        data["attr5"] = this.attr5;
        return data; 
    }
}

export interface ICommonResult {
    result: string | undefined;
    errorDesc: string | undefined;
    attr1: string | undefined;
    attr2: string | undefined;
    attr3: string | undefined;
    attr4: string | undefined;
    attr5: string | undefined;
}

export class CommonSettingEditDto implements ICommonSettingEditDto {
    defaultRecordsCountPerPage!: string | undefined;
    resizableColumns!: string | undefined;
    isResponsive!: string | undefined;
    predefinedRecordsCountPerPage!: string | undefined;
    phoneNumberRegexValidation!: string | undefined;
    dateTimeFormatClient!: string | undefined;
    datePickerDisplayFormat!: string | undefined;
    datePickerValueFormat!: string | undefined;
    languageComboboxEnable!: boolean | undefined;
    timeShowSuccessMessage!: number | undefined;
    timeShowWarningMessage!: number | undefined;
    timeShowErrorMessage!: number | undefined;
    emailRegexValidation!: string | undefined;
    coreNoteRegexValidation!: string | undefined;
    codeNumberRegexValidation!: string | undefined;
    numberPlateRegexValidation!: string | undefined;
    maxQuantityNumber!: number | undefined;
    taxNoRegexValidation!: string | undefined;
    fullNameRegexValidation!: string | undefined;
    maxLenghtRegexValidation!: string | undefined;
    searchMenuVisible!: boolean | undefined;
    fileSizeAttach!: number | undefined;
    numberOfFiles!: string | undefined;
    maxFilenameLength!: string | undefined;
    fileExtensionAttach!: string | undefined;

    constructor(data?: ICommonSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultRecordsCountPerPage = data["defaultRecordsCountPerPage"];
            this.resizableColumns = data["resizableColumns"];
            this.isResponsive = data["isResponsive"];
            this.predefinedRecordsCountPerPage = data["predefinedRecordsCountPerPage"];
            this.phoneNumberRegexValidation = data["phoneNumberRegexValidation"];
            this.dateTimeFormatClient = data["dateTimeFormatClient"];
            this.datePickerDisplayFormat = data["datePickerDisplayFormat"];
            this.datePickerValueFormat = data["datePickerValueFormat"];
            this.languageComboboxEnable = data["languageComboboxEnable"];
            this.timeShowSuccessMessage = data["timeShowSuccessMessage"];
            this.timeShowWarningMessage = data["timeShowWarningMessage"];
            this.timeShowErrorMessage = data["timeShowErrorMessage"];
            this.emailRegexValidation = data["emailRegexValidation"];
            this.coreNoteRegexValidation = data["coreNoteRegexValidation"];
            this.codeNumberRegexValidation = data["codeNumberRegexValidation"];
            this.numberPlateRegexValidation = data["numberPlateRegexValidation"];
            this.maxQuantityNumber = data["maxQuantityNumber"];
            this.taxNoRegexValidation = data["taxNoRegexValidation"];
            this.fullNameRegexValidation = data["fullNameRegexValidation"];
            this.maxLenghtRegexValidation = data["maxLenghtRegexValidation"];
            this.searchMenuVisible = data["searchMenuVisible"];
            this.fileSizeAttach = data["fileSizeAttach"];
            this.numberOfFiles = data["numberOfFiles"];
            this.maxFilenameLength = data["maxFilenameLength"];
            this.fileExtensionAttach = data["fileExtensionAttach"];
        }
    }

    static fromJS(data: any): CommonSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultRecordsCountPerPage"] = this.defaultRecordsCountPerPage;
        data["resizableColumns"] = this.resizableColumns;
        data["isResponsive"] = this.isResponsive;
        data["predefinedRecordsCountPerPage"] = this.predefinedRecordsCountPerPage;
        data["phoneNumberRegexValidation"] = this.phoneNumberRegexValidation;
        data["dateTimeFormatClient"] = this.dateTimeFormatClient;
        data["datePickerDisplayFormat"] = this.datePickerDisplayFormat;
        data["datePickerValueFormat"] = this.datePickerValueFormat;
        data["languageComboboxEnable"] = this.languageComboboxEnable;
        data["timeShowSuccessMessage"] = this.timeShowSuccessMessage;
        data["timeShowWarningMessage"] = this.timeShowWarningMessage;
        data["timeShowErrorMessage"] = this.timeShowErrorMessage;
        data["emailRegexValidation"] = this.emailRegexValidation;
        data["coreNoteRegexValidation"] = this.coreNoteRegexValidation;
        data["codeNumberRegexValidation"] = this.codeNumberRegexValidation;
        data["numberPlateRegexValidation"] = this.numberPlateRegexValidation;
        data["maxQuantityNumber"] = this.maxQuantityNumber;
        data["taxNoRegexValidation"] = this.taxNoRegexValidation;
        data["fullNameRegexValidation"] = this.fullNameRegexValidation;
        data["maxLenghtRegexValidation"] = this.maxLenghtRegexValidation;
        data["searchMenuVisible"] = this.searchMenuVisible;
        data["fileSizeAttach"] = this.fileSizeAttach;
        data["numberOfFiles"] = this.numberOfFiles;
        data["maxFilenameLength"] = this.maxFilenameLength;
        data["fileExtensionAttach"] = this.fileExtensionAttach;
        return data; 
    }
}

export interface ICommonSettingEditDto {
    defaultRecordsCountPerPage: string | undefined;
    resizableColumns: string | undefined;
    isResponsive: string | undefined;
    predefinedRecordsCountPerPage: string | undefined;
    phoneNumberRegexValidation: string | undefined;
    dateTimeFormatClient: string | undefined;
    datePickerDisplayFormat: string | undefined;
    datePickerValueFormat: string | undefined;
    languageComboboxEnable: boolean | undefined;
    timeShowSuccessMessage: number | undefined;
    timeShowWarningMessage: number | undefined;
    timeShowErrorMessage: number | undefined;
    emailRegexValidation: string | undefined;
    coreNoteRegexValidation: string | undefined;
    codeNumberRegexValidation: string | undefined;
    numberPlateRegexValidation: string | undefined;
    maxQuantityNumber: number | undefined;
    taxNoRegexValidation: string | undefined;
    fullNameRegexValidation: string | undefined;
    maxLenghtRegexValidation: string | undefined;
    searchMenuVisible: boolean | undefined;
    fileSizeAttach: number | undefined;
    numberOfFiles: string | undefined;
    maxFilenameLength: string | undefined;
    fileExtensionAttach: string | undefined;
}

export class CONTRACT_ANNEX_ENTITY implements ICONTRACT_ANNEX_ENTITY {
    contracT_ANNEX_ID!: string | undefined;
    contracT_ID!: string | undefined;
    anneX_NAME!: string | undefined;
    anneX_SIGN_DT!: moment.Moment | undefined;
    anneX_TERM!: number;
    anneX_TERMINATE_DT!: moment.Moment | undefined;
    notes!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICONTRACT_ANNEX_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contracT_ANNEX_ID = data["contracT_ANNEX_ID"];
            this.contracT_ID = data["contracT_ID"];
            this.anneX_NAME = data["anneX_NAME"];
            this.anneX_SIGN_DT = data["anneX_SIGN_DT"] ? moment(data["anneX_SIGN_DT"].toString()) : <any>undefined;
            this.anneX_TERM = data["anneX_TERM"];
            this.anneX_TERMINATE_DT = data["anneX_TERMINATE_DT"] ? moment(data["anneX_TERMINATE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CONTRACT_ANNEX_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CONTRACT_ANNEX_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contracT_ANNEX_ID"] = this.contracT_ANNEX_ID;
        data["contracT_ID"] = this.contracT_ID;
        data["anneX_NAME"] = this.anneX_NAME;
        data["anneX_SIGN_DT"] = this.anneX_SIGN_DT ? this.anneX_SIGN_DT.toISOString() : <any>undefined;
        data["anneX_TERM"] = this.anneX_TERM;
        data["anneX_TERMINATE_DT"] = this.anneX_TERMINATE_DT ? this.anneX_TERMINATE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICONTRACT_ANNEX_ENTITY {
    contracT_ANNEX_ID: string | undefined;
    contracT_ID: string | undefined;
    anneX_NAME: string | undefined;
    anneX_SIGN_DT: moment.Moment | undefined;
    anneX_TERM: number;
    anneX_TERMINATE_DT: moment.Moment | undefined;
    notes: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CONTRACT_ITEM_ENTITY implements ICONTRACT_ITEM_ENTITY {
    contracT_ITEM_ID!: string | undefined;
    contracT_ID!: string | undefined;
    contracT_ITEM_INVESTMENT_PROP_ID!: string | undefined;
    contracT_ITEM_TYPE!: string | undefined;
    contracT_ITEM_RENTAL_AREA!: number;
    contracT_ITEM_TERM!: number;
    contracT_ITEM_EFFECT_DT!: moment.Moment | undefined;
    contracT_ITEM_TERMINATE_DT!: moment.Moment | undefined;
    notes!: string | undefined;
    contracT_ITEM_RENTAL_PRICE!: CONTRACT_ITEM_RENTAL_PRICE_ENTITY;
    contracT_ITEM_TYPE_NAME!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICONTRACT_ITEM_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contracT_ITEM_ID = data["contracT_ITEM_ID"];
            this.contracT_ID = data["contracT_ID"];
            this.contracT_ITEM_INVESTMENT_PROP_ID = data["contracT_ITEM_INVESTMENT_PROP_ID"];
            this.contracT_ITEM_TYPE = data["contracT_ITEM_TYPE"];
            this.contracT_ITEM_RENTAL_AREA = data["contracT_ITEM_RENTAL_AREA"];
            this.contracT_ITEM_TERM = data["contracT_ITEM_TERM"];
            this.contracT_ITEM_EFFECT_DT = data["contracT_ITEM_EFFECT_DT"] ? moment(data["contracT_ITEM_EFFECT_DT"].toString()) : <any>undefined;
            this.contracT_ITEM_TERMINATE_DT = data["contracT_ITEM_TERMINATE_DT"] ? moment(data["contracT_ITEM_TERMINATE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.contracT_ITEM_RENTAL_PRICE = data["contracT_ITEM_RENTAL_PRICE"] ? CONTRACT_ITEM_RENTAL_PRICE_ENTITY.fromJS(data["contracT_ITEM_RENTAL_PRICE"]) : <any>undefined;
            this.contracT_ITEM_TYPE_NAME = data["contracT_ITEM_TYPE_NAME"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CONTRACT_ITEM_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CONTRACT_ITEM_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contracT_ITEM_ID"] = this.contracT_ITEM_ID;
        data["contracT_ID"] = this.contracT_ID;
        data["contracT_ITEM_INVESTMENT_PROP_ID"] = this.contracT_ITEM_INVESTMENT_PROP_ID;
        data["contracT_ITEM_TYPE"] = this.contracT_ITEM_TYPE;
        data["contracT_ITEM_RENTAL_AREA"] = this.contracT_ITEM_RENTAL_AREA;
        data["contracT_ITEM_TERM"] = this.contracT_ITEM_TERM;
        data["contracT_ITEM_EFFECT_DT"] = this.contracT_ITEM_EFFECT_DT ? this.contracT_ITEM_EFFECT_DT.toISOString() : <any>undefined;
        data["contracT_ITEM_TERMINATE_DT"] = this.contracT_ITEM_TERMINATE_DT ? this.contracT_ITEM_TERMINATE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["contracT_ITEM_RENTAL_PRICE"] = this.contracT_ITEM_RENTAL_PRICE ? this.contracT_ITEM_RENTAL_PRICE.toJSON() : <any>undefined;
        data["contracT_ITEM_TYPE_NAME"] = this.contracT_ITEM_TYPE_NAME;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICONTRACT_ITEM_ENTITY {
    contracT_ITEM_ID: string | undefined;
    contracT_ID: string | undefined;
    contracT_ITEM_INVESTMENT_PROP_ID: string | undefined;
    contracT_ITEM_TYPE: string | undefined;
    contracT_ITEM_RENTAL_AREA: number;
    contracT_ITEM_TERM: number;
    contracT_ITEM_EFFECT_DT: moment.Moment | undefined;
    contracT_ITEM_TERMINATE_DT: moment.Moment | undefined;
    notes: string | undefined;
    contracT_ITEM_RENTAL_PRICE: CONTRACT_ITEM_RENTAL_PRICE_ENTITY;
    contracT_ITEM_TYPE_NAME: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CONTRACT_ITEM_RENTAL_PRICE_ENTITY implements ICONTRACT_ITEM_RENTAL_PRICE_ENTITY {
    contracT_ITEM_PRICE_ID!: string | undefined;
    contracT_ITEM_ID!: string | undefined;
    rentaL_PRICE_TYPE!: string | undefined;
    rentaL_PRICE_MONTH_NUMBER!: number;
    rentAl_PRICE_EFFECT_DT!: moment.Moment | undefined;
    rentaL_PRICE_UNIT_PRICE_VND!: number;
    rentaL_PRICE_UNIT_PRICE_USD!: number;
    notes!: string | undefined;
    retaL_PRICE_TYPE_NAME!: string | undefined;
    rentaL_PRICE_EXPIRE_DT!: moment.Moment | undefined;
    rentaL_PRICE_REVENUE_PER_MOUNTH!: number;
    rentaL_PRICE_TOTAL_REVENUE!: number;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ICONTRACT_ITEM_RENTAL_PRICE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contracT_ITEM_PRICE_ID = data["contracT_ITEM_PRICE_ID"];
            this.contracT_ITEM_ID = data["contracT_ITEM_ID"];
            this.rentaL_PRICE_TYPE = data["rentaL_PRICE_TYPE"];
            this.rentaL_PRICE_MONTH_NUMBER = data["rentaL_PRICE_MONTH_NUMBER"];
            this.rentAl_PRICE_EFFECT_DT = data["rentAl_PRICE_EFFECT_DT"] ? moment(data["rentAl_PRICE_EFFECT_DT"].toString()) : <any>undefined;
            this.rentaL_PRICE_UNIT_PRICE_VND = data["rentaL_PRICE_UNIT_PRICE_VND"];
            this.rentaL_PRICE_UNIT_PRICE_USD = data["rentaL_PRICE_UNIT_PRICE_USD"];
            this.notes = data["notes"];
            this.retaL_PRICE_TYPE_NAME = data["retaL_PRICE_TYPE_NAME"];
            this.rentaL_PRICE_EXPIRE_DT = data["rentaL_PRICE_EXPIRE_DT"] ? moment(data["rentaL_PRICE_EXPIRE_DT"].toString()) : <any>undefined;
            this.rentaL_PRICE_REVENUE_PER_MOUNTH = data["rentaL_PRICE_REVENUE_PER_MOUNTH"];
            this.rentaL_PRICE_TOTAL_REVENUE = data["rentaL_PRICE_TOTAL_REVENUE"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): CONTRACT_ITEM_RENTAL_PRICE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new CONTRACT_ITEM_RENTAL_PRICE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contracT_ITEM_PRICE_ID"] = this.contracT_ITEM_PRICE_ID;
        data["contracT_ITEM_ID"] = this.contracT_ITEM_ID;
        data["rentaL_PRICE_TYPE"] = this.rentaL_PRICE_TYPE;
        data["rentaL_PRICE_MONTH_NUMBER"] = this.rentaL_PRICE_MONTH_NUMBER;
        data["rentAl_PRICE_EFFECT_DT"] = this.rentAl_PRICE_EFFECT_DT ? this.rentAl_PRICE_EFFECT_DT.toISOString() : <any>undefined;
        data["rentaL_PRICE_UNIT_PRICE_VND"] = this.rentaL_PRICE_UNIT_PRICE_VND;
        data["rentaL_PRICE_UNIT_PRICE_USD"] = this.rentaL_PRICE_UNIT_PRICE_USD;
        data["notes"] = this.notes;
        data["retaL_PRICE_TYPE_NAME"] = this.retaL_PRICE_TYPE_NAME;
        data["rentaL_PRICE_EXPIRE_DT"] = this.rentaL_PRICE_EXPIRE_DT ? this.rentaL_PRICE_EXPIRE_DT.toISOString() : <any>undefined;
        data["rentaL_PRICE_REVENUE_PER_MOUNTH"] = this.rentaL_PRICE_REVENUE_PER_MOUNTH;
        data["rentaL_PRICE_TOTAL_REVENUE"] = this.rentaL_PRICE_TOTAL_REVENUE;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ICONTRACT_ITEM_RENTAL_PRICE_ENTITY {
    contracT_ITEM_PRICE_ID: string | undefined;
    contracT_ITEM_ID: string | undefined;
    rentaL_PRICE_TYPE: string | undefined;
    rentaL_PRICE_MONTH_NUMBER: number;
    rentAl_PRICE_EFFECT_DT: moment.Moment | undefined;
    rentaL_PRICE_UNIT_PRICE_VND: number;
    rentaL_PRICE_UNIT_PRICE_USD: number;
    notes: string | undefined;
    retaL_PRICE_TYPE_NAME: string | undefined;
    rentaL_PRICE_EXPIRE_DT: moment.Moment | undefined;
    rentaL_PRICE_REVENUE_PER_MOUNTH: number;
    rentaL_PRICE_TOTAL_REVENUE: number;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    makerId!: string | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            this.makerId = data["makerId"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        data["makerId"] = this.makerId;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    makerId: string | undefined;
    organizationUnits: number[] | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    id!: number;
    name!: string;
    surname!: string | undefined;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;
    isTwoFactorEnabled!: boolean;
    subbrId!: string | undefined;
    deP_ID!: string | undefined;
    roles!: UserListRoleDto[] | undefined;
    userCurrentLanguage!: string | undefined;
    type!: string | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.subbrId = data["subbrId"];
            this.deP_ID = data["deP_ID"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.userCurrentLanguage = data["userCurrentLanguage"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["subbrId"] = this.subbrId;
        data["deP_ID"] = this.deP_ID;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["userCurrentLanguage"] = this.userCurrentLanguage;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    id: number;
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
    isTwoFactorEnabled: boolean;
    subbrId: string | undefined;
    deP_ID: string | undefined;
    roles: UserListRoleDto[] | undefined;
    userCurrentLanguage: string | undefined;
    type: string | undefined;
}

export class DASBOARD_02 implements IDASBOARD_02 {
    grouP_ID!: string | undefined;
    values!: number;
    grouP_NAME!: string | undefined;

    constructor(data?: IDASBOARD_02) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grouP_ID = data["grouP_ID"];
            this.values = data["values"];
            this.grouP_NAME = data["grouP_NAME"];
        }
    }

    static fromJS(data: any): DASBOARD_02 {
        data = typeof data === 'object' ? data : {};
        let result = new DASBOARD_02();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grouP_ID"] = this.grouP_ID;
        data["values"] = this.values;
        data["grouP_NAME"] = this.grouP_NAME;
        return data; 
    }
}

export interface IDASBOARD_02 {
    grouP_ID: string | undefined;
    values: number;
    grouP_NAME: string | undefined;
}

export class DASBOARD_05 implements IDASBOARD_05 {
    lbl!: string | undefined;
    color!: string | undefined;
    sum_value!: string | undefined;

    constructor(data?: IDASBOARD_05) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lbl = data["lbl"];
            this.color = data["color"];
            this.sum_value = data["sum_value"];
        }
    }

    static fromJS(data: any): DASBOARD_05 {
        data = typeof data === 'object' ? data : {};
        let result = new DASBOARD_05();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lbl"] = this.lbl;
        data["color"] = this.color;
        data["sum_value"] = this.sum_value;
        return data; 
    }
}

export interface IDASBOARD_05 {
    lbl: string | undefined;
    color: string | undefined;
    sum_value: string | undefined;
}

export class DASBOARD_06 implements IDASBOARD_06 {
    value!: string | undefined;
    crdr!: string | undefined;
    month!: number;

    constructor(data?: IDASBOARD_06) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.crdr = data["crdr"];
            this.month = data["month"];
        }
    }

    static fromJS(data: any): DASBOARD_06 {
        data = typeof data === 'object' ? data : {};
        let result = new DASBOARD_06();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["crdr"] = this.crdr;
        data["month"] = this.month;
        return data; 
    }
}

export interface IDASBOARD_06 {
    value: string | undefined;
    crdr: string | undefined;
    month: number;
}

export class DashboarDto implements IDashboarDto {
    procName!: string | undefined;
    parameters!: ReportParameter[] | undefined;

    constructor(data?: IDashboarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.procName = data["procName"];
            if (data["parameters"] && data["parameters"].constructor === Array) {
                this.parameters = [] as any;
                for (let item of data["parameters"])
                    this.parameters!.push(ReportParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboarDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["procName"] = this.procName;
        if (this.parameters && this.parameters.constructor === Array) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDashboarDto {
    procName: string | undefined;
    parameters: ReportParameter[] | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export enum EditionPaymentType {
    NewRegistration = 0, 
    BuyNow = 1, 
    Upgrade = 2, 
    Extend = 3, 
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
    additionalData: AdditionalData | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;
    tenantEditionId!: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [] as any;
                for (let item of data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [] as any;
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export enum EntityChangeType {
    Created = 0, 
    Updated = 1, 
    Deleted = 2, 
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class ExecQueryDto implements IExecQueryDto {
    content!: string | undefined;

    constructor(data?: IExecQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): ExecQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

export interface IExecQueryDto {
    content: string | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class FileUploadDto implements IFileUploadDto {
    filE_NAME!: string | undefined;
    url!: string | undefined;
    filE_TYPE!: string | undefined;
    basE64!: string | undefined;

    constructor(data?: IFileUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filE_NAME = data["filE_NAME"];
            this.url = data["url"];
            this.filE_TYPE = data["filE_TYPE"];
            this.basE64 = data["basE64"];
        }
    }

    static fromJS(data: any): FileUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filE_NAME"] = this.filE_NAME;
        data["url"] = this.url;
        data["filE_TYPE"] = this.filE_TYPE;
        data["basE64"] = this.basE64;
        return data; 
    }
}

export interface IFileUploadDto {
    filE_NAME: string | undefined;
    url: string | undefined;
    filE_TYPE: string | undefined;
    basE64: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;
    isRootAction!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
            this.isRootAction = data["isRootAction"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        data["isRootAction"] = this.isRootAction;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
    isRootAction: boolean;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;
    isRootAction!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
            this.isRootAction = data["isRootAction"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        data["isRootAction"] = this.isRootAction;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
    isRootAction: boolean;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export enum FriendshipState {
    Accepted = 1, 
    Blocked = 2, 
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;
    roleKeys!: string[] | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
            if (data["roleKeys"] && data["roleKeys"].constructor === Array) {
                this.roleKeys = [] as any;
                for (let item of data["roleKeys"])
                    this.roleKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        if (this.roleKeys && this.roleKeys.constructor === Array) {
            data["roleKeys"] = [];
            for (let item of this.roleKeys)
                data["roleKeys"].push(item);
        }
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
    roleKeys: string[] | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [] as any;
                for (let item of data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [] as any;
                for (let item of data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GetGeneralStatsInput implements IGetGeneralStatsInput {

    constructor(data?: IGetGeneralStatsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): GetGeneralStatsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetGeneralStatsInput {
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [] as any;
                for (let item of data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class GetRegionalStatsInput implements IGetRegionalStatsInput {

    constructor(data?: IGetRegionalStatsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): GetRegionalStatsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetRegionalStatsInput {
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [] as any;
                for (let item of data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;
    actions!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
            if (data["actions"] && data["actions"].constructor === Array) {
                this.actions = [] as any;
                for (let item of data["actions"])
                    this.actions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        if (this.actions && this.actions.constructor === Array) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    actions: string[] | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [] as any;
                for (let item of data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment;
    friends: FriendDto[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    filter!: string | undefined;
    permission!: string | undefined;
    role!: number | undefined;
    onlyLockedUsers!: boolean;
    userName!: string | undefined;
    autH_STATUS!: string | undefined;
    subbrId!: string | undefined;
    independentUnit!: boolean;
    depId!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["filter"];
            this.permission = data["permission"];
            this.role = data["role"];
            this.onlyLockedUsers = data["onlyLockedUsers"];
            this.userName = data["userName"];
            this.autH_STATUS = data["autH_STATUS"];
            this.subbrId = data["subbrId"];
            this.independentUnit = data["independentUnit"];
            this.depId = data["depId"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        data["permission"] = this.permission;
        data["role"] = this.role;
        data["onlyLockedUsers"] = this.onlyLockedUsers;
        data["userName"] = this.userName;
        data["autH_STATUS"] = this.autH_STATUS;
        data["subbrId"] = this.subbrId;
        data["independentUnit"] = this.independentUnit;
        data["depId"] = this.depId;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IGetUsersInput {
    filter: string | undefined;
    permission: string | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean;
    userName: string | undefined;
    autH_STATUS: string | undefined;
    subbrId: string | undefined;
    independentUnit: boolean;
    depId: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number;
    maxRecentTenantsShownCount!: number;
    subscriptionEndAlertDayCount!: number;
    recentTenantsDayCount!: number;
    subscriptionEndDateStart!: moment.Moment;
    subscriptionEndDateEnd!: moment.Moment;
    tenantCreationStartDate!: moment.Moment;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [] as any;
                for (let item of data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [] as any;
                for (let item of data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number;
    maxRecentTenantsShownCount: number;
    subscriptionEndAlertDayCount: number;
    recentTenantsDayCount: number;
    subscriptionEndDateStart: moment.Moment;
    subscriptionEndDateEnd: moment.Moment;
    tenantCreationStartDate: moment.Moment;
}

export class HostSettingResultDto implements IHostSettingResultDto {
    requiredLogout!: boolean;
    requiredRefresh!: boolean;

    constructor(data?: IHostSettingResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requiredLogout = data["requiredLogout"];
            this.requiredRefresh = data["requiredRefresh"];
        }
    }

    static fromJS(data: any): HostSettingResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredLogout"] = this.requiredLogout;
        data["requiredRefresh"] = this.requiredRefresh;
        return data; 
    }
}

export interface IHostSettingResultDto {
    requiredLogout: boolean;
    requiredRefresh: boolean;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;
    userLoginSettingEditDto!: UserLoginSettingEditDto;
    commonSettingEditDto!: CommonSettingEditDto;
    logoCompanySettingDto!: LogoCompanySettingDto;
    sftpSettingEditDto!: SftpSettingEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
            this.userLoginSettingEditDto = data["userLoginSettingEditDto"] ? UserLoginSettingEditDto.fromJS(data["userLoginSettingEditDto"]) : <any>undefined;
            this.commonSettingEditDto = data["commonSettingEditDto"] ? CommonSettingEditDto.fromJS(data["commonSettingEditDto"]) : <any>undefined;
            this.logoCompanySettingDto = data["logoCompanySettingDto"] ? LogoCompanySettingDto.fromJS(data["logoCompanySettingDto"]) : <any>undefined;
            this.sftpSettingEditDto = data["sftpSettingEditDto"] ? SftpSettingEditDto.fromJS(data["sftpSettingEditDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["userLoginSettingEditDto"] = this.userLoginSettingEditDto ? this.userLoginSettingEditDto.toJSON() : <any>undefined;
        data["commonSettingEditDto"] = this.commonSettingEditDto ? this.commonSettingEditDto.toJSON() : <any>undefined;
        data["logoCompanySettingDto"] = this.logoCompanySettingDto ? this.logoCompanySettingDto.toJSON() : <any>undefined;
        data["sftpSettingEditDto"] = this.sftpSettingEditDto ? this.sftpSettingEditDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
    userLoginSettingEditDto: UserLoginSettingEditDto;
    commonSettingEditDto: CommonSettingEditDto;
    logoCompanySettingDto: LogoCompanySettingDto;
    sftpSettingEditDto: SftpSettingEditDto;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
}

export class IInputType implements IIInputType {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;
    tenancyId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
            this.tenancyId = data["tenancyId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        data["tenancyId"] = this.tenancyId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
    tenancyId: number | undefined;
    userId: number;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment;
    amount: number;
}

export class InsertResult implements IInsertResult {
    id!: string | undefined;
    ids!: string | undefined;
    result!: string | undefined;
    errorDesc!: string | undefined;
    attr1!: string | undefined;
    attr2!: string | undefined;
    attr3!: string | undefined;
    attr4!: string | undefined;
    attr5!: string | undefined;

    constructor(data?: IInsertResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ids = data["ids"];
            this.result = data["result"];
            this.errorDesc = data["errorDesc"];
            this.attr1 = data["attr1"];
            this.attr2 = data["attr2"];
            this.attr3 = data["attr3"];
            this.attr4 = data["attr4"];
            this.attr5 = data["attr5"];
        }
    }

    static fromJS(data: any): InsertResult {
        data = typeof data === 'object' ? data : {};
        let result = new InsertResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ids"] = this.ids;
        data["result"] = this.result;
        data["errorDesc"] = this.errorDesc;
        data["attr1"] = this.attr1;
        data["attr2"] = this.attr2;
        data["attr3"] = this.attr3;
        data["attr4"] = this.attr4;
        data["attr5"] = this.attr5;
        return data; 
    }
}

export interface IInsertResult {
    id: string | undefined;
    ids: string | undefined;
    result: string | undefined;
    errorDesc: string | undefined;
    attr1: string | undefined;
    attr2: string | undefined;
    attr3: string | undefined;
    attr4: string | undefined;
    attr5: string | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class InvestChartDto implements IInvestChartDto {
    target!: string | undefined;
    quantity!: number | undefined;
    arisE_VALUE!: number | undefined;
    accumulateD_VALUE!: number | undefined;
    kH2020!: number | undefined;
    kH2020_PERCENT!: number | undefined;

    constructor(data?: IInvestChartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.target = data["target"];
            this.quantity = data["quantity"];
            this.arisE_VALUE = data["arisE_VALUE"];
            this.accumulateD_VALUE = data["accumulateD_VALUE"];
            this.kH2020 = data["kH2020"];
            this.kH2020_PERCENT = data["kH2020_PERCENT"];
        }
    }

    static fromJS(data: any): InvestChartDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvestChartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["target"] = this.target;
        data["quantity"] = this.quantity;
        data["arisE_VALUE"] = this.arisE_VALUE;
        data["accumulateD_VALUE"] = this.accumulateD_VALUE;
        data["kH2020"] = this.kH2020;
        data["kH2020_PERCENT"] = this.kH2020_PERCENT;
        return data; 
    }
}

export interface IInvestChartDto {
    target: string | undefined;
    quantity: number | undefined;
    arisE_VALUE: number | undefined;
    accumulateD_VALUE: number | undefined;
    kH2020: number | undefined;
    kH2020_PERCENT: number | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [] as any;
                for (let item of data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [] as any;
                for (let item of data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class IUserLoginBranch implements IIUserLoginBranch {
    addr!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    brancH_CODE!: string | undefined;
    brancH_NAME!: string | undefined;
    brancH_TYPE!: string | undefined;
    checkeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    daO_CODE!: string | undefined;
    daO_NAME!: string | undefined;
    fatheR_ID!: string | undefined;
    id!: string | undefined;
    iS_POTENTIAL!: string | undefined;
    isApprove!: boolean;
    makeR_ID!: string | undefined;
    notes!: string | undefined;
    provice!: string | undefined;
    recorD_STATUS!: string | undefined;
    regioN_ID!: string | undefined;
    taX_NO!: string | undefined;
    tel!: string | undefined;

    constructor(data?: IIUserLoginBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addr = data["addr"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.brancH_CODE = data["brancH_CODE"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.checkeR_ID = data["checkeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.daO_CODE = data["daO_CODE"];
            this.daO_NAME = data["daO_NAME"];
            this.fatheR_ID = data["fatheR_ID"];
            this.id = data["id"];
            this.iS_POTENTIAL = data["iS_POTENTIAL"];
            this.isApprove = data["isApprove"];
            this.makeR_ID = data["makeR_ID"];
            this.notes = data["notes"];
            this.provice = data["provice"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.regioN_ID = data["regioN_ID"];
            this.taX_NO = data["taX_NO"];
            this.tel = data["tel"];
        }
    }

    static fromJS(data: any): IUserLoginBranch {
        data = typeof data === 'object' ? data : {};
        let result = new IUserLoginBranch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addr"] = this.addr;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["brancH_CODE"] = this.brancH_CODE;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["checkeR_ID"] = this.checkeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["daO_CODE"] = this.daO_CODE;
        data["daO_NAME"] = this.daO_NAME;
        data["fatheR_ID"] = this.fatheR_ID;
        data["id"] = this.id;
        data["iS_POTENTIAL"] = this.iS_POTENTIAL;
        data["isApprove"] = this.isApprove;
        data["makeR_ID"] = this.makeR_ID;
        data["notes"] = this.notes;
        data["provice"] = this.provice;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["regioN_ID"] = this.regioN_ID;
        data["taX_NO"] = this.taX_NO;
        data["tel"] = this.tel;
        return data; 
    }
}

export interface IIUserLoginBranch {
    addr: string | undefined;
    approvE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    brancH_CODE: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    checkeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    daO_CODE: string | undefined;
    daO_NAME: string | undefined;
    fatheR_ID: string | undefined;
    id: string | undefined;
    iS_POTENTIAL: string | undefined;
    isApprove: boolean;
    makeR_ID: string | undefined;
    notes: string | undefined;
    provice: string | undefined;
    recorD_STATUS: string | undefined;
    regioN_ID: string | undefined;
    taX_NO: string | undefined;
    tel: string | undefined;
}

export class IValueValidator implements IIValueValidator {
    name!: string | undefined;
    attributes!: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDefault!: boolean;
    isDisabled!: boolean;
    isRightToLeft!: boolean;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDefault = data["isDefault"];
            this.isDisabled = data["isDisabled"];
            this.isRightToLeft = data["isRightToLeft"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDefault"] = this.isDefault;
        data["isDisabled"] = this.isDisabled;
        data["isRightToLeft"] = this.isRightToLeft;
        return data; 
    }
}

export interface ILanguageInfo {
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDefault: boolean;
    isDisabled: boolean;
    isRightToLeft: boolean;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    id!: number;
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    id: number;
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LogoCompanySettingDto implements ILogoCompanySettingDto {
    loginLogo!: string | undefined;
    webLogo!: string | undefined;

    constructor(data?: ILogoCompanySettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginLogo = data["loginLogo"];
            this.webLogo = data["webLogo"];
        }
    }

    static fromJS(data: any): LogoCompanySettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogoCompanySettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginLogo"] = this.loginLogo;
        data["webLogo"] = this.webLogo;
        return data; 
    }
}

export interface ILogoCompanySettingDto {
    loginLogo: string | undefined;
    webLogo: string | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export enum MultiTenancySides {
    Tenant = 1, 
    Host = 2, 
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class NotificationData implements INotificationData {
    type!: string | undefined;
    properties!: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties![key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0, 
    Success = 1, 
    Warn = 2, 
    Error = 3, 
    Fatal = 4, 
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class PagedResultDtoOfCM_ACCOUNT_KT_ENTITY implements IPagedResultDtoOfCM_ACCOUNT_KT_ENTITY {
    totalCount!: number;
    items!: CM_ACCOUNT_KT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_ACCOUNT_KT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_ACCOUNT_KT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_ACCOUNT_KT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_ACCOUNT_KT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_ACCOUNT_KT_ENTITY {
    totalCount: number;
    items: CM_ACCOUNT_KT_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_ALLCODE_ENTITY implements IPagedResultDtoOfCM_ALLCODE_ENTITY {
    totalCount!: number;
    items!: CM_ALLCODE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_ALLCODE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_ALLCODE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_ALLCODE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_ALLCODE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_ALLCODE_ENTITY {
    totalCount: number;
    items: CM_ALLCODE_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_AREAS_ENTITY implements IPagedResultDtoOfCM_AREAS_ENTITY {
    totalCount!: number;
    items!: CM_AREAS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_AREAS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_AREAS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_AREAS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_AREAS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_AREAS_ENTITY {
    totalCount: number;
    items: CM_AREAS_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_BRANCH_ENTITY implements IPagedResultDtoOfCM_BRANCH_ENTITY {
    totalCount!: number;
    items!: CM_BRANCH_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_BRANCH_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_BRANCH_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_BRANCH_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_BRANCH_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_BRANCH_ENTITY {
    totalCount: number;
    items: CM_BRANCH_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_CAR_TYPE_ENTITY implements IPagedResultDtoOfCM_CAR_TYPE_ENTITY {
    totalCount!: number;
    items!: CM_CAR_TYPE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_CAR_TYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_CAR_TYPE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_CAR_TYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_CAR_TYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_CAR_TYPE_ENTITY {
    totalCount: number;
    items: CM_CAR_TYPE_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_DEPARTMENT_ENTITY implements IPagedResultDtoOfCM_DEPARTMENT_ENTITY {
    totalCount!: number;
    items!: CM_DEPARTMENT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DEPARTMENT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_DEPARTMENT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DEPARTMENT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DEPARTMENT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_DEPARTMENT_ENTITY {
    totalCount: number;
    items: CM_DEPARTMENT_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_DEPT_GROUP_ENTITY implements IPagedResultDtoOfCM_DEPT_GROUP_ENTITY {
    totalCount!: number;
    items!: CM_DEPT_GROUP_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DEPT_GROUP_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_DEPT_GROUP_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DEPT_GROUP_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DEPT_GROUP_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_DEPT_GROUP_ENTITY {
    totalCount: number;
    items: CM_DEPT_GROUP_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_DIVISION_ENTITY implements IPagedResultDtoOfCM_DIVISION_ENTITY {
    totalCount!: number;
    items!: CM_DIVISION_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_DIVISION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_DIVISION_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_DIVISION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_DIVISION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_DIVISION_ENTITY {
    totalCount: number;
    items: CM_DIVISION_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_EMPLOYEE_ENTITY implements IPagedResultDtoOfCM_EMPLOYEE_ENTITY {
    totalCount!: number;
    items!: CM_EMPLOYEE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_EMPLOYEE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_EMPLOYEE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_EMPLOYEE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_EMPLOYEE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_EMPLOYEE_ENTITY {
    totalCount: number;
    items: CM_EMPLOYEE_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_GOODS_ENTITY implements IPagedResultDtoOfCM_GOODS_ENTITY {
    totalCount!: number;
    items!: CM_GOODS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_GOODS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_GOODS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_GOODS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_GOODS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_GOODS_ENTITY {
    totalCount: number;
    items: CM_GOODS_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_GOODSTYPE_ENTITY implements IPagedResultDtoOfCM_GOODSTYPE_ENTITY {
    totalCount!: number;
    items!: CM_GOODSTYPE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_GOODSTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_GOODSTYPE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_GOODSTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_GOODSTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_GOODSTYPE_ENTITY {
    totalCount: number;
    items: CM_GOODSTYPE_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY implements IPagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
    totalCount!: number;
    items!: CM_GOODSTYPE_REAL_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_GOODSTYPE_REAL_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_GOODSTYPE_REAL_ENTITY {
    totalCount: number;
    items: CM_GOODSTYPE_REAL_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_INSU_COMPANY_ENTITY implements IPagedResultDtoOfCM_INSU_COMPANY_ENTITY {
    totalCount!: number;
    items!: CM_INSU_COMPANY_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_INSU_COMPANY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_INSU_COMPANY_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_INSU_COMPANY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_INSU_COMPANY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_INSU_COMPANY_ENTITY {
    totalCount: number;
    items: CM_INSU_COMPANY_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_KHOI_DT_ENTITY implements IPagedResultDtoOfCM_KHOI_DT_ENTITY {
    totalCount!: number;
    items!: CM_KHOI_DT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_KHOI_DT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_KHOI_DT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_KHOI_DT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_KHOI_DT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_KHOI_DT_ENTITY {
    totalCount: number;
    items: CM_KHOI_DT_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_KHOI_ENTITY implements IPagedResultDtoOfCM_KHOI_ENTITY {
    totalCount!: number;
    items!: CM_KHOI_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_KHOI_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_KHOI_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_KHOI_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_KHOI_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_KHOI_ENTITY {
    totalCount: number;
    items: CM_KHOI_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_MANAGER_REGION_ENTITY implements IPagedResultDtoOfCM_MANAGER_REGION_ENTITY {
    totalCount!: number;
    items!: CM_MANAGER_REGION_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_MANAGER_REGION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_MANAGER_REGION_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_MANAGER_REGION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_MANAGER_REGION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_MANAGER_REGION_ENTITY {
    totalCount: number;
    items: CM_MANAGER_REGION_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_MODEL_ENTITY implements IPagedResultDtoOfCM_MODEL_ENTITY {
    totalCount!: number;
    items!: CM_MODEL_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_MODEL_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_MODEL_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_MODEL_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_MODEL_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_MODEL_ENTITY {
    totalCount: number;
    items: CM_MODEL_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_REGION_ENTITY implements IPagedResultDtoOfCM_REGION_ENTITY {
    totalCount!: number;
    items!: CM_REGION_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_REGION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_REGION_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_REGION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_REGION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_REGION_ENTITY {
    totalCount: number;
    items: CM_REGION_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_REJECT_LOG_ENTITY implements IPagedResultDtoOfCM_REJECT_LOG_ENTITY {
    totalCount!: number;
    items!: CM_REJECT_LOG_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_REJECT_LOG_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_REJECT_LOG_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_REJECT_LOG_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_REJECT_LOG_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_REJECT_LOG_ENTITY {
    totalCount: number;
    items: CM_REJECT_LOG_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY implements IPagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
    totalCount!: number;
    items!: CM_REPORT_TEMPLATE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_REPORT_TEMPLATE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_REPORT_TEMPLATE_ENTITY {
    totalCount: number;
    items: CM_REPORT_TEMPLATE_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_SECUR_INFO_ENTITY implements IPagedResultDtoOfCM_SECUR_INFO_ENTITY {
    totalCount!: number;
    items!: CM_SECUR_INFO_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_SECUR_INFO_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_SECUR_INFO_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_SECUR_INFO_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_SECUR_INFO_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_SECUR_INFO_ENTITY {
    totalCount: number;
    items: CM_SECUR_INFO_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_SUPPLIER_ENTITY implements IPagedResultDtoOfCM_SUPPLIER_ENTITY {
    totalCount!: number;
    items!: CM_SUPPLIER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_SUPPLIER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_SUPPLIER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_SUPPLIER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_SUPPLIER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_SUPPLIER_ENTITY {
    totalCount: number;
    items: CM_SUPPLIER_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY implements IPagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
    totalCount!: number;
    items!: CM_SUPPLIERTYPE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_SUPPLIERTYPE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_SUPPLIERTYPE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_SUPPLIERTYPE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_SUPPLIERTYPE_ENTITY {
    totalCount: number;
    items: CM_SUPPLIERTYPE_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_TERM_ENTITY implements IPagedResultDtoOfCM_TERM_ENTITY {
    totalCount!: number;
    items!: CM_TERM_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_TERM_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_TERM_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_TERM_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_TERM_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_TERM_ENTITY {
    totalCount: number;
    items: CM_TERM_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_UNIT_ENTITY implements IPagedResultDtoOfCM_UNIT_ENTITY {
    totalCount!: number;
    items!: CM_UNIT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_UNIT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_UNIT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_UNIT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_UNIT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_UNIT_ENTITY {
    totalCount: number;
    items: CM_UNIT_ENTITY[] | undefined;
}

export class PagedResultDtoOfCM_WORKFLOW_ENTITY implements IPagedResultDtoOfCM_WORKFLOW_ENTITY {
    totalCount!: number;
    items!: CM_WORKFLOW_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfCM_WORKFLOW_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CM_WORKFLOW_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCM_WORKFLOW_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCM_WORKFLOW_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCM_WORKFLOW_ENTITY {
    totalCount: number;
    items: CM_WORKFLOW_ENTITY[] | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class PagedResultDtoOfREA_ALLCODE_ENTITY implements IPagedResultDtoOfREA_ALLCODE_ENTITY {
    totalCount!: number;
    items!: REA_ALLCODE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_ALLCODE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_ALLCODE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_ALLCODE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_ALLCODE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_ALLCODE_ENTITY {
    totalCount: number;
    items: REA_ALLCODE_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY implements IPagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY {
    totalCount!: number;
    items!: REA_AUTHORIZED_PERSON_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_AUTHORIZED_PERSON_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_AUTHORIZED_PERSON_ENTITY {
    totalCount: number;
    items: REA_AUTHORIZED_PERSON_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_CONTRACT_ENTITY implements IPagedResultDtoOfREA_CONTRACT_ENTITY {
    totalCount!: number;
    items!: REA_CONTRACT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_CONTRACT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_CONTRACT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_CONTRACT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_CONTRACT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_CONTRACT_ENTITY {
    totalCount: number;
    items: REA_CONTRACT_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY implements IPagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY {
    totalCount!: number;
    items!: REA_INVESTMENT_PROPERTY_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_INVESTMENT_PROPERTY_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_INVESTMENT_PROPERTY_ENTITY {
    totalCount: number;
    items: REA_INVESTMENT_PROPERTY_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_LAND_AREA_ENTITY implements IPagedResultDtoOfREA_LAND_AREA_ENTITY {
    totalCount!: number;
    items!: REA_LAND_AREA_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_LAND_AREA_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_LAND_AREA_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_LAND_AREA_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_LAND_AREA_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_LAND_AREA_ENTITY {
    totalCount: number;
    items: REA_LAND_AREA_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_MORTGAGE_ENTITY implements IPagedResultDtoOfREA_MORTGAGE_ENTITY {
    totalCount!: number;
    items!: REA_MORTGAGE_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_MORTGAGE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_MORTGAGE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_MORTGAGE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_MORTGAGE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_MORTGAGE_ENTITY {
    totalCount: number;
    items: REA_MORTGAGE_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY implements IPagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY {
    totalCount!: number;
    items!: REA_OUTSIDE_SHAREHOLDER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_OUTSIDE_SHAREHOLDER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_OUTSIDE_SHAREHOLDER_ENTITY {
    totalCount: number;
    items: REA_OUTSIDE_SHAREHOLDER_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_OWNER_ENTITY implements IPagedResultDtoOfREA_OWNER_ENTITY {
    totalCount!: number;
    items!: REA_OWNER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_OWNER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_OWNER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_OWNER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_OWNER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_OWNER_ENTITY {
    totalCount: number;
    items: REA_OWNER_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_PROJECT_ENTITY implements IPagedResultDtoOfREA_PROJECT_ENTITY {
    totalCount!: number;
    items!: REA_PROJECT_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_PROJECT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_PROJECT_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_PROJECT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_PROJECT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_PROJECT_ENTITY {
    totalCount: number;
    items: REA_PROJECT_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_SHAREHOLDER_ENTITY implements IPagedResultDtoOfREA_SHAREHOLDER_ENTITY {
    totalCount!: number;
    items!: REA_SHAREHOLDER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_SHAREHOLDER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_SHAREHOLDER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_SHAREHOLDER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_SHAREHOLDER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_SHAREHOLDER_ENTITY {
    totalCount: number;
    items: REA_SHAREHOLDER_ENTITY[] | undefined;
}

export class PagedResultDtoOfREA_SODO_ENTITY implements IPagedResultDtoOfREA_SODO_ENTITY {
    totalCount!: number;
    items!: REA_SODO_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfREA_SODO_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(REA_SODO_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfREA_SODO_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfREA_SODO_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfREA_SODO_ENTITY {
    totalCount: number;
    items: REA_SODO_ENTITY[] | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PagedResultDtoOfSYS_PARAMETERS_ENTITY implements IPagedResultDtoOfSYS_PARAMETERS_ENTITY {
    totalCount!: number;
    items!: SYS_PARAMETERS_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfSYS_PARAMETERS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SYS_PARAMETERS_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSYS_PARAMETERS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSYS_PARAMETERS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSYS_PARAMETERS_ENTITY {
    totalCount: number;
    items: SYS_PARAMETERS_ENTITY[] | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class PagedResultDtoOfTL_MENU_ENTITY implements IPagedResultDtoOfTL_MENU_ENTITY {
    totalCount!: number;
    items!: TL_MENU_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfTL_MENU_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TL_MENU_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTL_MENU_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTL_MENU_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTL_MENU_ENTITY {
    totalCount: number;
    items: TL_MENU_ENTITY[] | undefined;
}

export class PagedResultDtoOfTL_USER_ENTITY implements IPagedResultDtoOfTL_USER_ENTITY {
    totalCount!: number;
    items!: TL_USER_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfTL_USER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TL_USER_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTL_USER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTL_USER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTL_USER_ENTITY {
    totalCount: number;
    items: TL_USER_ENTITY[] | undefined;
}

export class PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY implements IPagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
    totalCount!: number;
    items!: TLUSER_GETBY_BRANCHID_ENTITY[] | undefined;

    constructor(data?: IPagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TLUSER_GETBY_BRANCHID_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTLUSER_GETBY_BRANCHID_ENTITY {
    totalCount: number;
    items: TLUSER_GETBY_BRANCHID_ENTITY[] | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum PaymentPeriodType {
    Monthly = 30, 
    Annual = 365, 
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    environment!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.environment = data["environment"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["environment"] = this.environment;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    environment: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class REA_ALLCODE_ENTITY implements IREA_ALLCODE_ENTITY {
    id!: number | undefined;
    cdname!: string | undefined;
    cdval!: string | undefined;
    content!: string | undefined;
    cdtype!: string | undefined;
    lstodr!: number | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_ALLCODE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cdname = data["cdname"];
            this.cdval = data["cdval"];
            this.content = data["content"];
            this.cdtype = data["cdtype"];
            this.lstodr = data["lstodr"];
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_ALLCODE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_ALLCODE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cdname"] = this.cdname;
        data["cdval"] = this.cdval;
        data["content"] = this.content;
        data["cdtype"] = this.cdtype;
        data["lstodr"] = this.lstodr;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_ALLCODE_ENTITY {
    id: number | undefined;
    cdname: string | undefined;
    cdval: string | undefined;
    content: string | undefined;
    cdtype: string | undefined;
    lstodr: number | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_AUTHORIZED_PERSON_ENTITY implements IREA_AUTHORIZED_PERSON_ENTITY {
    a_PERSON_ID!: string | undefined;
    a_PERSON_NAME!: string | undefined;
    a_PERSON_BIRTH_DT!: moment.Moment | undefined;
    a_PERSON_CODE!: string | undefined;
    a_PERSON_CODE_PROVIDED_DT!: moment.Moment | undefined;
    a_PERSON_ADDRESS!: string | undefined;
    a_PERSON_DEP_PEOPLE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_AUTHORIZED_PERSON_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.a_PERSON_ID = data["a_PERSON_ID"];
            this.a_PERSON_NAME = data["a_PERSON_NAME"];
            this.a_PERSON_BIRTH_DT = data["a_PERSON_BIRTH_DT"] ? moment(data["a_PERSON_BIRTH_DT"].toString()) : <any>undefined;
            this.a_PERSON_CODE = data["a_PERSON_CODE"];
            this.a_PERSON_CODE_PROVIDED_DT = data["a_PERSON_CODE_PROVIDED_DT"] ? moment(data["a_PERSON_CODE_PROVIDED_DT"].toString()) : <any>undefined;
            this.a_PERSON_ADDRESS = data["a_PERSON_ADDRESS"];
            this.a_PERSON_DEP_PEOPLE = data["a_PERSON_DEP_PEOPLE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_AUTHORIZED_PERSON_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_AUTHORIZED_PERSON_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a_PERSON_ID"] = this.a_PERSON_ID;
        data["a_PERSON_NAME"] = this.a_PERSON_NAME;
        data["a_PERSON_BIRTH_DT"] = this.a_PERSON_BIRTH_DT ? this.a_PERSON_BIRTH_DT.toISOString() : <any>undefined;
        data["a_PERSON_CODE"] = this.a_PERSON_CODE;
        data["a_PERSON_CODE_PROVIDED_DT"] = this.a_PERSON_CODE_PROVIDED_DT ? this.a_PERSON_CODE_PROVIDED_DT.toISOString() : <any>undefined;
        data["a_PERSON_ADDRESS"] = this.a_PERSON_ADDRESS;
        data["a_PERSON_DEP_PEOPLE"] = this.a_PERSON_DEP_PEOPLE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_AUTHORIZED_PERSON_ENTITY {
    a_PERSON_ID: string | undefined;
    a_PERSON_NAME: string | undefined;
    a_PERSON_BIRTH_DT: moment.Moment | undefined;
    a_PERSON_CODE: string | undefined;
    a_PERSON_CODE_PROVIDED_DT: moment.Moment | undefined;
    a_PERSON_ADDRESS: string | undefined;
    a_PERSON_DEP_PEOPLE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_CONTRACT_ENTITY implements IREA_CONTRACT_ENTITY {
    contracT_ANNEXES!: CONTRACT_ANNEX_ENTITY[] | undefined;
    contracT_ITEMS!: CONTRACT_ITEM_ENTITY[] | undefined;
    contracT_ID!: string | undefined;
    contracT_SIGN_DT!: moment.Moment | undefined;
    contracT_CONTENT!: string | undefined;
    contracT_PARTNER_ID!: string | undefined;
    contracT_STATUS!: string | undefined;
    contracT_TERMINATE_DT!: moment.Moment | undefined;
    contracT_TERMINATE_REASON!: string | undefined;
    contracT_REJECT_REASON!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    contracT_STATUS_NAME!: string | undefined;
    deleteD_ITEM_ID_LIST!: string[] | undefined;
    deleteD_ANNEX_ID_LIST!: string[] | undefined;
    deleteD_ITEM_PRICE_ID_LIST!: string[] | undefined;
    totaL_REVENUE!: number;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_CONTRACT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["contracT_ANNEXES"] && data["contracT_ANNEXES"].constructor === Array) {
                this.contracT_ANNEXES = [] as any;
                for (let item of data["contracT_ANNEXES"])
                    this.contracT_ANNEXES!.push(CONTRACT_ANNEX_ENTITY.fromJS(item));
            }
            if (data["contracT_ITEMS"] && data["contracT_ITEMS"].constructor === Array) {
                this.contracT_ITEMS = [] as any;
                for (let item of data["contracT_ITEMS"])
                    this.contracT_ITEMS!.push(CONTRACT_ITEM_ENTITY.fromJS(item));
            }
            this.contracT_ID = data["contracT_ID"];
            this.contracT_SIGN_DT = data["contracT_SIGN_DT"] ? moment(data["contracT_SIGN_DT"].toString()) : <any>undefined;
            this.contracT_CONTENT = data["contracT_CONTENT"];
            this.contracT_PARTNER_ID = data["contracT_PARTNER_ID"];
            this.contracT_STATUS = data["contracT_STATUS"];
            this.contracT_TERMINATE_DT = data["contracT_TERMINATE_DT"] ? moment(data["contracT_TERMINATE_DT"].toString()) : <any>undefined;
            this.contracT_TERMINATE_REASON = data["contracT_TERMINATE_REASON"];
            this.contracT_REJECT_REASON = data["contracT_REJECT_REASON"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.contracT_STATUS_NAME = data["contracT_STATUS_NAME"];
            if (data["deleteD_ITEM_ID_LIST"] && data["deleteD_ITEM_ID_LIST"].constructor === Array) {
                this.deleteD_ITEM_ID_LIST = [] as any;
                for (let item of data["deleteD_ITEM_ID_LIST"])
                    this.deleteD_ITEM_ID_LIST!.push(item);
            }
            if (data["deleteD_ANNEX_ID_LIST"] && data["deleteD_ANNEX_ID_LIST"].constructor === Array) {
                this.deleteD_ANNEX_ID_LIST = [] as any;
                for (let item of data["deleteD_ANNEX_ID_LIST"])
                    this.deleteD_ANNEX_ID_LIST!.push(item);
            }
            if (data["deleteD_ITEM_PRICE_ID_LIST"] && data["deleteD_ITEM_PRICE_ID_LIST"].constructor === Array) {
                this.deleteD_ITEM_PRICE_ID_LIST = [] as any;
                for (let item of data["deleteD_ITEM_PRICE_ID_LIST"])
                    this.deleteD_ITEM_PRICE_ID_LIST!.push(item);
            }
            this.totaL_REVENUE = data["totaL_REVENUE"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_CONTRACT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_CONTRACT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contracT_ANNEXES && this.contracT_ANNEXES.constructor === Array) {
            data["contracT_ANNEXES"] = [];
            for (let item of this.contracT_ANNEXES)
                data["contracT_ANNEXES"].push(item.toJSON());
        }
        if (this.contracT_ITEMS && this.contracT_ITEMS.constructor === Array) {
            data["contracT_ITEMS"] = [];
            for (let item of this.contracT_ITEMS)
                data["contracT_ITEMS"].push(item.toJSON());
        }
        data["contracT_ID"] = this.contracT_ID;
        data["contracT_SIGN_DT"] = this.contracT_SIGN_DT ? this.contracT_SIGN_DT.toISOString() : <any>undefined;
        data["contracT_CONTENT"] = this.contracT_CONTENT;
        data["contracT_PARTNER_ID"] = this.contracT_PARTNER_ID;
        data["contracT_STATUS"] = this.contracT_STATUS;
        data["contracT_TERMINATE_DT"] = this.contracT_TERMINATE_DT ? this.contracT_TERMINATE_DT.toISOString() : <any>undefined;
        data["contracT_TERMINATE_REASON"] = this.contracT_TERMINATE_REASON;
        data["contracT_REJECT_REASON"] = this.contracT_REJECT_REASON;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["contracT_STATUS_NAME"] = this.contracT_STATUS_NAME;
        if (this.deleteD_ITEM_ID_LIST && this.deleteD_ITEM_ID_LIST.constructor === Array) {
            data["deleteD_ITEM_ID_LIST"] = [];
            for (let item of this.deleteD_ITEM_ID_LIST)
                data["deleteD_ITEM_ID_LIST"].push(item);
        }
        if (this.deleteD_ANNEX_ID_LIST && this.deleteD_ANNEX_ID_LIST.constructor === Array) {
            data["deleteD_ANNEX_ID_LIST"] = [];
            for (let item of this.deleteD_ANNEX_ID_LIST)
                data["deleteD_ANNEX_ID_LIST"].push(item);
        }
        if (this.deleteD_ITEM_PRICE_ID_LIST && this.deleteD_ITEM_PRICE_ID_LIST.constructor === Array) {
            data["deleteD_ITEM_PRICE_ID_LIST"] = [];
            for (let item of this.deleteD_ITEM_PRICE_ID_LIST)
                data["deleteD_ITEM_PRICE_ID_LIST"].push(item);
        }
        data["totaL_REVENUE"] = this.totaL_REVENUE;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_CONTRACT_ENTITY {
    contracT_ANNEXES: CONTRACT_ANNEX_ENTITY[] | undefined;
    contracT_ITEMS: CONTRACT_ITEM_ENTITY[] | undefined;
    contracT_ID: string | undefined;
    contracT_SIGN_DT: moment.Moment | undefined;
    contracT_CONTENT: string | undefined;
    contracT_PARTNER_ID: string | undefined;
    contracT_STATUS: string | undefined;
    contracT_TERMINATE_DT: moment.Moment | undefined;
    contracT_TERMINATE_REASON: string | undefined;
    contracT_REJECT_REASON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    contracT_STATUS_NAME: string | undefined;
    deleteD_ITEM_ID_LIST: string[] | undefined;
    deleteD_ANNEX_ID_LIST: string[] | undefined;
    deleteD_ITEM_PRICE_ID_LIST: string[] | undefined;
    totaL_REVENUE: number;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_FILE_ENTITY implements IREA_FILE_ENTITY {
    filE_ID!: string | undefined;
    entitY_ID!: string | undefined;
    entitY_TYPE!: string | undefined;
    filE_NAME!: string | undefined;
    filE_PATH!: string | undefined;
    filE_TYPE!: string | undefined;
    filE_DESCRIPTION!: string | undefined;
    filE_ATTACH_DT!: moment.Moment | undefined;
    makeR_ID!: string | undefined;
    filE_CONTENT!: Stream;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_FILE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filE_ID = data["filE_ID"];
            this.entitY_ID = data["entitY_ID"];
            this.entitY_TYPE = data["entitY_TYPE"];
            this.filE_NAME = data["filE_NAME"];
            this.filE_PATH = data["filE_PATH"];
            this.filE_TYPE = data["filE_TYPE"];
            this.filE_DESCRIPTION = data["filE_DESCRIPTION"];
            this.filE_ATTACH_DT = data["filE_ATTACH_DT"] ? moment(data["filE_ATTACH_DT"].toString()) : <any>undefined;
            this.makeR_ID = data["makeR_ID"];
            this.filE_CONTENT = data["filE_CONTENT"] ? Stream.fromJS(data["filE_CONTENT"]) : <any>undefined;
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_FILE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_FILE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filE_ID"] = this.filE_ID;
        data["entitY_ID"] = this.entitY_ID;
        data["entitY_TYPE"] = this.entitY_TYPE;
        data["filE_NAME"] = this.filE_NAME;
        data["filE_PATH"] = this.filE_PATH;
        data["filE_TYPE"] = this.filE_TYPE;
        data["filE_DESCRIPTION"] = this.filE_DESCRIPTION;
        data["filE_ATTACH_DT"] = this.filE_ATTACH_DT ? this.filE_ATTACH_DT.toISOString() : <any>undefined;
        data["makeR_ID"] = this.makeR_ID;
        data["filE_CONTENT"] = this.filE_CONTENT ? this.filE_CONTENT.toJSON() : <any>undefined;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_FILE_ENTITY {
    filE_ID: string | undefined;
    entitY_ID: string | undefined;
    entitY_TYPE: string | undefined;
    filE_NAME: string | undefined;
    filE_PATH: string | undefined;
    filE_TYPE: string | undefined;
    filE_DESCRIPTION: string | undefined;
    filE_ATTACH_DT: moment.Moment | undefined;
    makeR_ID: string | undefined;
    filE_CONTENT: Stream;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_FLOOR_MANAGEMENT_ENTITY implements IREA_FLOOR_MANAGEMENT_ENTITY {
    flooR_MANAGEMENT_ID!: string | undefined;
    invesT_PROP_ID!: string | undefined;
    flooR_DESCRIPTION!: string | undefined;
    flooR_AREA!: number;
    notes!: string | undefined;

    constructor(data?: IREA_FLOOR_MANAGEMENT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.flooR_MANAGEMENT_ID = data["flooR_MANAGEMENT_ID"];
            this.invesT_PROP_ID = data["invesT_PROP_ID"];
            this.flooR_DESCRIPTION = data["flooR_DESCRIPTION"];
            this.flooR_AREA = data["flooR_AREA"];
            this.notes = data["notes"];
        }
    }

    static fromJS(data: any): REA_FLOOR_MANAGEMENT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_FLOOR_MANAGEMENT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flooR_MANAGEMENT_ID"] = this.flooR_MANAGEMENT_ID;
        data["invesT_PROP_ID"] = this.invesT_PROP_ID;
        data["flooR_DESCRIPTION"] = this.flooR_DESCRIPTION;
        data["flooR_AREA"] = this.flooR_AREA;
        data["notes"] = this.notes;
        return data; 
    }
}

export interface IREA_FLOOR_MANAGEMENT_ENTITY {
    flooR_MANAGEMENT_ID: string | undefined;
    invesT_PROP_ID: string | undefined;
    flooR_DESCRIPTION: string | undefined;
    flooR_AREA: number;
    notes: string | undefined;
}

export class REA_INVESTMENT_PROPERTY_ENTITY implements IREA_INVESTMENT_PROPERTY_ENTITY {
    propertY_ID!: string | undefined;
    invesT_PROP_ID!: string | undefined;
    projecT_ID!: string | undefined;
    retaL_PARTNER_ID!: string | undefined;
    invesT_PROP_LOCATION!: string | undefined;
    invesT_PROP_NAME!: string | undefined;
    invesT_PROP_CAMPUS_AREA!: number;
    invesT_PROP_BUILD_AREA!: number;
    invesT_PROP_BUSINESS_AREA!: number;
    invesT_PROP_STATUS!: string | undefined;
    invesT_PROP_PREDICT_COMPLETE_DT!: moment.Moment | undefined;
    invesT_PROP_GCN_STATUS!: string | undefined;
    invesT_PROP_LEGAL_STATUS!: string | undefined;
    invesT_PROP_SODO_PROVIDE_DT!: moment.Moment | undefined;
    rejecT_REASON!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    flooR_LIST!: REA_FLOOR_MANAGEMENT_ENTITY[] | undefined;
    propertY_INFORMATION!: REA_PROPERTY_INFORMATION;
    deleteD_FLOOR_ID_LIST!: string[] | undefined;

    constructor(data?: IREA_INVESTMENT_PROPERTY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertY_ID = data["propertY_ID"];
            this.invesT_PROP_ID = data["invesT_PROP_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.retaL_PARTNER_ID = data["retaL_PARTNER_ID"];
            this.invesT_PROP_LOCATION = data["invesT_PROP_LOCATION"];
            this.invesT_PROP_NAME = data["invesT_PROP_NAME"];
            this.invesT_PROP_CAMPUS_AREA = data["invesT_PROP_CAMPUS_AREA"];
            this.invesT_PROP_BUILD_AREA = data["invesT_PROP_BUILD_AREA"];
            this.invesT_PROP_BUSINESS_AREA = data["invesT_PROP_BUSINESS_AREA"];
            this.invesT_PROP_STATUS = data["invesT_PROP_STATUS"];
            this.invesT_PROP_PREDICT_COMPLETE_DT = data["invesT_PROP_PREDICT_COMPLETE_DT"] ? moment(data["invesT_PROP_PREDICT_COMPLETE_DT"].toString()) : <any>undefined;
            this.invesT_PROP_GCN_STATUS = data["invesT_PROP_GCN_STATUS"];
            this.invesT_PROP_LEGAL_STATUS = data["invesT_PROP_LEGAL_STATUS"];
            this.invesT_PROP_SODO_PROVIDE_DT = data["invesT_PROP_SODO_PROVIDE_DT"] ? moment(data["invesT_PROP_SODO_PROVIDE_DT"].toString()) : <any>undefined;
            this.rejecT_REASON = data["rejecT_REASON"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            if (data["flooR_LIST"] && data["flooR_LIST"].constructor === Array) {
                this.flooR_LIST = [] as any;
                for (let item of data["flooR_LIST"])
                    this.flooR_LIST!.push(REA_FLOOR_MANAGEMENT_ENTITY.fromJS(item));
            }
            this.propertY_INFORMATION = data["propertY_INFORMATION"] ? REA_PROPERTY_INFORMATION.fromJS(data["propertY_INFORMATION"]) : <any>undefined;
            if (data["deleteD_FLOOR_ID_LIST"] && data["deleteD_FLOOR_ID_LIST"].constructor === Array) {
                this.deleteD_FLOOR_ID_LIST = [] as any;
                for (let item of data["deleteD_FLOOR_ID_LIST"])
                    this.deleteD_FLOOR_ID_LIST!.push(item);
            }
        }
    }

    static fromJS(data: any): REA_INVESTMENT_PROPERTY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_INVESTMENT_PROPERTY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertY_ID"] = this.propertY_ID;
        data["invesT_PROP_ID"] = this.invesT_PROP_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["retaL_PARTNER_ID"] = this.retaL_PARTNER_ID;
        data["invesT_PROP_LOCATION"] = this.invesT_PROP_LOCATION;
        data["invesT_PROP_NAME"] = this.invesT_PROP_NAME;
        data["invesT_PROP_CAMPUS_AREA"] = this.invesT_PROP_CAMPUS_AREA;
        data["invesT_PROP_BUILD_AREA"] = this.invesT_PROP_BUILD_AREA;
        data["invesT_PROP_BUSINESS_AREA"] = this.invesT_PROP_BUSINESS_AREA;
        data["invesT_PROP_STATUS"] = this.invesT_PROP_STATUS;
        data["invesT_PROP_PREDICT_COMPLETE_DT"] = this.invesT_PROP_PREDICT_COMPLETE_DT ? this.invesT_PROP_PREDICT_COMPLETE_DT.toISOString() : <any>undefined;
        data["invesT_PROP_GCN_STATUS"] = this.invesT_PROP_GCN_STATUS;
        data["invesT_PROP_LEGAL_STATUS"] = this.invesT_PROP_LEGAL_STATUS;
        data["invesT_PROP_SODO_PROVIDE_DT"] = this.invesT_PROP_SODO_PROVIDE_DT ? this.invesT_PROP_SODO_PROVIDE_DT.toISOString() : <any>undefined;
        data["rejecT_REASON"] = this.rejecT_REASON;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        if (this.flooR_LIST && this.flooR_LIST.constructor === Array) {
            data["flooR_LIST"] = [];
            for (let item of this.flooR_LIST)
                data["flooR_LIST"].push(item.toJSON());
        }
        data["propertY_INFORMATION"] = this.propertY_INFORMATION ? this.propertY_INFORMATION.toJSON() : <any>undefined;
        if (this.deleteD_FLOOR_ID_LIST && this.deleteD_FLOOR_ID_LIST.constructor === Array) {
            data["deleteD_FLOOR_ID_LIST"] = [];
            for (let item of this.deleteD_FLOOR_ID_LIST)
                data["deleteD_FLOOR_ID_LIST"].push(item);
        }
        return data; 
    }
}

export interface IREA_INVESTMENT_PROPERTY_ENTITY {
    propertY_ID: string | undefined;
    invesT_PROP_ID: string | undefined;
    projecT_ID: string | undefined;
    retaL_PARTNER_ID: string | undefined;
    invesT_PROP_LOCATION: string | undefined;
    invesT_PROP_NAME: string | undefined;
    invesT_PROP_CAMPUS_AREA: number;
    invesT_PROP_BUILD_AREA: number;
    invesT_PROP_BUSINESS_AREA: number;
    invesT_PROP_STATUS: string | undefined;
    invesT_PROP_PREDICT_COMPLETE_DT: moment.Moment | undefined;
    invesT_PROP_GCN_STATUS: string | undefined;
    invesT_PROP_LEGAL_STATUS: string | undefined;
    invesT_PROP_SODO_PROVIDE_DT: moment.Moment | undefined;
    rejecT_REASON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    flooR_LIST: REA_FLOOR_MANAGEMENT_ENTITY[] | undefined;
    propertY_INFORMATION: REA_PROPERTY_INFORMATION;
    deleteD_FLOOR_ID_LIST: string[] | undefined;
}

export class REA_LAND_AREA_ENTITY implements IREA_LAND_AREA_ENTITY {
    lanD_AREA_ID!: string | undefined;
    projecT_ID!: string | undefined;
    investoR_ID!: string | undefined;
    lanD_AREA_NAME!: string | undefined;
    lanD_AREA_SCALE!: number;
    lanD_AREA_LOCATION!: string | undefined;
    lanD_AREA_LIABILITY!: string | undefined;
    rejecT_REASON!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    attacheD_IMAGE!: REA_FILE_ENTITY;
    valuation!: REA_VALUATION_ENTITY;
    usE_REGISTRATION_LIST!: REA_USE_REGISTRATION_ENTITY[] | undefined;
    deleteD_USE_REGISTRATION_ID_LIST!: string[] | undefined;

    constructor(data?: IREA_LAND_AREA_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lanD_AREA_ID = data["lanD_AREA_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.investoR_ID = data["investoR_ID"];
            this.lanD_AREA_NAME = data["lanD_AREA_NAME"];
            this.lanD_AREA_SCALE = data["lanD_AREA_SCALE"];
            this.lanD_AREA_LOCATION = data["lanD_AREA_LOCATION"];
            this.lanD_AREA_LIABILITY = data["lanD_AREA_LIABILITY"];
            this.rejecT_REASON = data["rejecT_REASON"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.attacheD_IMAGE = data["attacheD_IMAGE"] ? REA_FILE_ENTITY.fromJS(data["attacheD_IMAGE"]) : <any>undefined;
            this.valuation = data["valuation"] ? REA_VALUATION_ENTITY.fromJS(data["valuation"]) : <any>undefined;
            if (data["usE_REGISTRATION_LIST"] && data["usE_REGISTRATION_LIST"].constructor === Array) {
                this.usE_REGISTRATION_LIST = [] as any;
                for (let item of data["usE_REGISTRATION_LIST"])
                    this.usE_REGISTRATION_LIST!.push(REA_USE_REGISTRATION_ENTITY.fromJS(item));
            }
            if (data["deleteD_USE_REGISTRATION_ID_LIST"] && data["deleteD_USE_REGISTRATION_ID_LIST"].constructor === Array) {
                this.deleteD_USE_REGISTRATION_ID_LIST = [] as any;
                for (let item of data["deleteD_USE_REGISTRATION_ID_LIST"])
                    this.deleteD_USE_REGISTRATION_ID_LIST!.push(item);
            }
        }
    }

    static fromJS(data: any): REA_LAND_AREA_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_LAND_AREA_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lanD_AREA_ID"] = this.lanD_AREA_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["investoR_ID"] = this.investoR_ID;
        data["lanD_AREA_NAME"] = this.lanD_AREA_NAME;
        data["lanD_AREA_SCALE"] = this.lanD_AREA_SCALE;
        data["lanD_AREA_LOCATION"] = this.lanD_AREA_LOCATION;
        data["lanD_AREA_LIABILITY"] = this.lanD_AREA_LIABILITY;
        data["rejecT_REASON"] = this.rejecT_REASON;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["attacheD_IMAGE"] = this.attacheD_IMAGE ? this.attacheD_IMAGE.toJSON() : <any>undefined;
        data["valuation"] = this.valuation ? this.valuation.toJSON() : <any>undefined;
        if (this.usE_REGISTRATION_LIST && this.usE_REGISTRATION_LIST.constructor === Array) {
            data["usE_REGISTRATION_LIST"] = [];
            for (let item of this.usE_REGISTRATION_LIST)
                data["usE_REGISTRATION_LIST"].push(item.toJSON());
        }
        if (this.deleteD_USE_REGISTRATION_ID_LIST && this.deleteD_USE_REGISTRATION_ID_LIST.constructor === Array) {
            data["deleteD_USE_REGISTRATION_ID_LIST"] = [];
            for (let item of this.deleteD_USE_REGISTRATION_ID_LIST)
                data["deleteD_USE_REGISTRATION_ID_LIST"].push(item);
        }
        return data; 
    }
}

export interface IREA_LAND_AREA_ENTITY {
    lanD_AREA_ID: string | undefined;
    projecT_ID: string | undefined;
    investoR_ID: string | undefined;
    lanD_AREA_NAME: string | undefined;
    lanD_AREA_SCALE: number;
    lanD_AREA_LOCATION: string | undefined;
    lanD_AREA_LIABILITY: string | undefined;
    rejecT_REASON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    attacheD_IMAGE: REA_FILE_ENTITY;
    valuation: REA_VALUATION_ENTITY;
    usE_REGISTRATION_LIST: REA_USE_REGISTRATION_ENTITY[] | undefined;
    deleteD_USE_REGISTRATION_ID_LIST: string[] | undefined;
}

export class REA_MORTGAGE_CHANGE_HISTORY_ENTITY implements IREA_MORTGAGE_CHANGE_HISTORY_ENTITY {
    mortgagE_CHANGE_ID!: string | undefined;
    mortgagE_ID!: string | undefined;
    mortgagE_CHANGE_FIELD!: string | undefined;
    mortgagE_CHANGE_BEFORE_VALUE!: string | undefined;
    mortgagE_CHANGE_AFTER_VALUE!: string | undefined;
    modifiteR_ID!: string | undefined;
    modifY_DT!: moment.Moment | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_MORTGAGE_CHANGE_HISTORY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mortgagE_CHANGE_ID = data["mortgagE_CHANGE_ID"];
            this.mortgagE_ID = data["mortgagE_ID"];
            this.mortgagE_CHANGE_FIELD = data["mortgagE_CHANGE_FIELD"];
            this.mortgagE_CHANGE_BEFORE_VALUE = data["mortgagE_CHANGE_BEFORE_VALUE"];
            this.mortgagE_CHANGE_AFTER_VALUE = data["mortgagE_CHANGE_AFTER_VALUE"];
            this.modifiteR_ID = data["modifiteR_ID"];
            this.modifY_DT = data["modifY_DT"] ? moment(data["modifY_DT"].toString()) : <any>undefined;
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_MORTGAGE_CHANGE_HISTORY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_MORTGAGE_CHANGE_HISTORY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mortgagE_CHANGE_ID"] = this.mortgagE_CHANGE_ID;
        data["mortgagE_ID"] = this.mortgagE_ID;
        data["mortgagE_CHANGE_FIELD"] = this.mortgagE_CHANGE_FIELD;
        data["mortgagE_CHANGE_BEFORE_VALUE"] = this.mortgagE_CHANGE_BEFORE_VALUE;
        data["mortgagE_CHANGE_AFTER_VALUE"] = this.mortgagE_CHANGE_AFTER_VALUE;
        data["modifiteR_ID"] = this.modifiteR_ID;
        data["modifY_DT"] = this.modifY_DT ? this.modifY_DT.toISOString() : <any>undefined;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_MORTGAGE_CHANGE_HISTORY_ENTITY {
    mortgagE_CHANGE_ID: string | undefined;
    mortgagE_ID: string | undefined;
    mortgagE_CHANGE_FIELD: string | undefined;
    mortgagE_CHANGE_BEFORE_VALUE: string | undefined;
    mortgagE_CHANGE_AFTER_VALUE: string | undefined;
    modifiteR_ID: string | undefined;
    modifY_DT: moment.Moment | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_MORTGAGE_ENTITY implements IREA_MORTGAGE_ENTITY {
    mortgagE_ID!: string | undefined;
    mortgagE_TYPE!: string | undefined;
    mortgagE_NAME!: string | undefined;
    mortgagE_TERM!: number;
    mortgagE_SIGN_DT!: moment.Moment;
    mortgagE_DUE_DATE!: moment.Moment;
    mortgagE_INTEREST_RATE!: number;
    mortgagE_ISSUE_VALUE!: number;
    mortgagE_COVERAGE_RATIO!: number;
    mortgagE_CHANGE_CONDITION!: string | undefined;
    rejecT_REASON!: string | undefined;
    mortgagE_STATUS!: string | undefined;
    mortgagE_OWNER_ID!: string | undefined;
    mortgagE_PUBLISHER_ID!: string | undefined;
    legaL_ENTITY_TYPE!: string | undefined;
    legaL_ENTITY_REF_ID!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    remaiN_DEBT!: number;
    mortgagE_INITIAL_COVERAGE_RATIO!: string | undefined;
    mortgagE_CURRENT_COVERAGE_RATIO!: string | undefined;
    numbeR_OF_MORTGAGE_PROPERTIES!: number;
    mortgagE_TYPE_NAME!: string | undefined;
    mortgagE_STATUS_NAME!: string | undefined;
    mortgagE_ITEM_LIST!: REA_MORTGAGE_ITEM_ENTITY[] | undefined;
    mortgagE_SHARE_LIST!: REA_MORTGAGE_SHARE_ENTITY[] | undefined;
    releasE_HISTORY_LIST!: REA_MORTGAGE_RELEASE_HISTORY_ENTITY[] | undefined;
    changE_HISTORY_LIST!: REA_MORTGAGE_CHANGE_HISTORY_ENTITY[] | undefined;
    deleteD_MORTGAGE_ITEM_ID_LIST!: string[] | undefined;
    deleteD_MORTGAGE_SHARE_ID_LIST!: string[] | undefined;
    deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST!: string[] | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_MORTGAGE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mortgagE_ID = data["mortgagE_ID"];
            this.mortgagE_TYPE = data["mortgagE_TYPE"];
            this.mortgagE_NAME = data["mortgagE_NAME"];
            this.mortgagE_TERM = data["mortgagE_TERM"];
            this.mortgagE_SIGN_DT = data["mortgagE_SIGN_DT"] ? moment(data["mortgagE_SIGN_DT"].toString()) : <any>undefined;
            this.mortgagE_DUE_DATE = data["mortgagE_DUE_DATE"] ? moment(data["mortgagE_DUE_DATE"].toString()) : <any>undefined;
            this.mortgagE_INTEREST_RATE = data["mortgagE_INTEREST_RATE"];
            this.mortgagE_ISSUE_VALUE = data["mortgagE_ISSUE_VALUE"];
            this.mortgagE_COVERAGE_RATIO = data["mortgagE_COVERAGE_RATIO"];
            this.mortgagE_CHANGE_CONDITION = data["mortgagE_CHANGE_CONDITION"];
            this.rejecT_REASON = data["rejecT_REASON"];
            this.mortgagE_STATUS = data["mortgagE_STATUS"];
            this.mortgagE_OWNER_ID = data["mortgagE_OWNER_ID"];
            this.mortgagE_PUBLISHER_ID = data["mortgagE_PUBLISHER_ID"];
            this.legaL_ENTITY_TYPE = data["legaL_ENTITY_TYPE"];
            this.legaL_ENTITY_REF_ID = data["legaL_ENTITY_REF_ID"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.remaiN_DEBT = data["remaiN_DEBT"];
            this.mortgagE_INITIAL_COVERAGE_RATIO = data["mortgagE_INITIAL_COVERAGE_RATIO"];
            this.mortgagE_CURRENT_COVERAGE_RATIO = data["mortgagE_CURRENT_COVERAGE_RATIO"];
            this.numbeR_OF_MORTGAGE_PROPERTIES = data["numbeR_OF_MORTGAGE_PROPERTIES"];
            this.mortgagE_TYPE_NAME = data["mortgagE_TYPE_NAME"];
            this.mortgagE_STATUS_NAME = data["mortgagE_STATUS_NAME"];
            if (data["mortgagE_ITEM_LIST"] && data["mortgagE_ITEM_LIST"].constructor === Array) {
                this.mortgagE_ITEM_LIST = [] as any;
                for (let item of data["mortgagE_ITEM_LIST"])
                    this.mortgagE_ITEM_LIST!.push(REA_MORTGAGE_ITEM_ENTITY.fromJS(item));
            }
            if (data["mortgagE_SHARE_LIST"] && data["mortgagE_SHARE_LIST"].constructor === Array) {
                this.mortgagE_SHARE_LIST = [] as any;
                for (let item of data["mortgagE_SHARE_LIST"])
                    this.mortgagE_SHARE_LIST!.push(REA_MORTGAGE_SHARE_ENTITY.fromJS(item));
            }
            if (data["releasE_HISTORY_LIST"] && data["releasE_HISTORY_LIST"].constructor === Array) {
                this.releasE_HISTORY_LIST = [] as any;
                for (let item of data["releasE_HISTORY_LIST"])
                    this.releasE_HISTORY_LIST!.push(REA_MORTGAGE_RELEASE_HISTORY_ENTITY.fromJS(item));
            }
            if (data["changE_HISTORY_LIST"] && data["changE_HISTORY_LIST"].constructor === Array) {
                this.changE_HISTORY_LIST = [] as any;
                for (let item of data["changE_HISTORY_LIST"])
                    this.changE_HISTORY_LIST!.push(REA_MORTGAGE_CHANGE_HISTORY_ENTITY.fromJS(item));
            }
            if (data["deleteD_MORTGAGE_ITEM_ID_LIST"] && data["deleteD_MORTGAGE_ITEM_ID_LIST"].constructor === Array) {
                this.deleteD_MORTGAGE_ITEM_ID_LIST = [] as any;
                for (let item of data["deleteD_MORTGAGE_ITEM_ID_LIST"])
                    this.deleteD_MORTGAGE_ITEM_ID_LIST!.push(item);
            }
            if (data["deleteD_MORTGAGE_SHARE_ID_LIST"] && data["deleteD_MORTGAGE_SHARE_ID_LIST"].constructor === Array) {
                this.deleteD_MORTGAGE_SHARE_ID_LIST = [] as any;
                for (let item of data["deleteD_MORTGAGE_SHARE_ID_LIST"])
                    this.deleteD_MORTGAGE_SHARE_ID_LIST!.push(item);
            }
            if (data["deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST"] && data["deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST"].constructor === Array) {
                this.deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST = [] as any;
                for (let item of data["deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST"])
                    this.deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST!.push(item);
            }
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_MORTGAGE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_MORTGAGE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mortgagE_ID"] = this.mortgagE_ID;
        data["mortgagE_TYPE"] = this.mortgagE_TYPE;
        data["mortgagE_NAME"] = this.mortgagE_NAME;
        data["mortgagE_TERM"] = this.mortgagE_TERM;
        data["mortgagE_SIGN_DT"] = this.mortgagE_SIGN_DT ? this.mortgagE_SIGN_DT.toISOString() : <any>undefined;
        data["mortgagE_DUE_DATE"] = this.mortgagE_DUE_DATE ? this.mortgagE_DUE_DATE.toISOString() : <any>undefined;
        data["mortgagE_INTEREST_RATE"] = this.mortgagE_INTEREST_RATE;
        data["mortgagE_ISSUE_VALUE"] = this.mortgagE_ISSUE_VALUE;
        data["mortgagE_COVERAGE_RATIO"] = this.mortgagE_COVERAGE_RATIO;
        data["mortgagE_CHANGE_CONDITION"] = this.mortgagE_CHANGE_CONDITION;
        data["rejecT_REASON"] = this.rejecT_REASON;
        data["mortgagE_STATUS"] = this.mortgagE_STATUS;
        data["mortgagE_OWNER_ID"] = this.mortgagE_OWNER_ID;
        data["mortgagE_PUBLISHER_ID"] = this.mortgagE_PUBLISHER_ID;
        data["legaL_ENTITY_TYPE"] = this.legaL_ENTITY_TYPE;
        data["legaL_ENTITY_REF_ID"] = this.legaL_ENTITY_REF_ID;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["remaiN_DEBT"] = this.remaiN_DEBT;
        data["mortgagE_INITIAL_COVERAGE_RATIO"] = this.mortgagE_INITIAL_COVERAGE_RATIO;
        data["mortgagE_CURRENT_COVERAGE_RATIO"] = this.mortgagE_CURRENT_COVERAGE_RATIO;
        data["numbeR_OF_MORTGAGE_PROPERTIES"] = this.numbeR_OF_MORTGAGE_PROPERTIES;
        data["mortgagE_TYPE_NAME"] = this.mortgagE_TYPE_NAME;
        data["mortgagE_STATUS_NAME"] = this.mortgagE_STATUS_NAME;
        if (this.mortgagE_ITEM_LIST && this.mortgagE_ITEM_LIST.constructor === Array) {
            data["mortgagE_ITEM_LIST"] = [];
            for (let item of this.mortgagE_ITEM_LIST)
                data["mortgagE_ITEM_LIST"].push(item.toJSON());
        }
        if (this.mortgagE_SHARE_LIST && this.mortgagE_SHARE_LIST.constructor === Array) {
            data["mortgagE_SHARE_LIST"] = [];
            for (let item of this.mortgagE_SHARE_LIST)
                data["mortgagE_SHARE_LIST"].push(item.toJSON());
        }
        if (this.releasE_HISTORY_LIST && this.releasE_HISTORY_LIST.constructor === Array) {
            data["releasE_HISTORY_LIST"] = [];
            for (let item of this.releasE_HISTORY_LIST)
                data["releasE_HISTORY_LIST"].push(item.toJSON());
        }
        if (this.changE_HISTORY_LIST && this.changE_HISTORY_LIST.constructor === Array) {
            data["changE_HISTORY_LIST"] = [];
            for (let item of this.changE_HISTORY_LIST)
                data["changE_HISTORY_LIST"].push(item.toJSON());
        }
        if (this.deleteD_MORTGAGE_ITEM_ID_LIST && this.deleteD_MORTGAGE_ITEM_ID_LIST.constructor === Array) {
            data["deleteD_MORTGAGE_ITEM_ID_LIST"] = [];
            for (let item of this.deleteD_MORTGAGE_ITEM_ID_LIST)
                data["deleteD_MORTGAGE_ITEM_ID_LIST"].push(item);
        }
        if (this.deleteD_MORTGAGE_SHARE_ID_LIST && this.deleteD_MORTGAGE_SHARE_ID_LIST.constructor === Array) {
            data["deleteD_MORTGAGE_SHARE_ID_LIST"] = [];
            for (let item of this.deleteD_MORTGAGE_SHARE_ID_LIST)
                data["deleteD_MORTGAGE_SHARE_ID_LIST"].push(item);
        }
        if (this.deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST && this.deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST.constructor === Array) {
            data["deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST"] = [];
            for (let item of this.deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST)
                data["deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST"].push(item);
        }
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_MORTGAGE_ENTITY {
    mortgagE_ID: string | undefined;
    mortgagE_TYPE: string | undefined;
    mortgagE_NAME: string | undefined;
    mortgagE_TERM: number;
    mortgagE_SIGN_DT: moment.Moment;
    mortgagE_DUE_DATE: moment.Moment;
    mortgagE_INTEREST_RATE: number;
    mortgagE_ISSUE_VALUE: number;
    mortgagE_COVERAGE_RATIO: number;
    mortgagE_CHANGE_CONDITION: string | undefined;
    rejecT_REASON: string | undefined;
    mortgagE_STATUS: string | undefined;
    mortgagE_OWNER_ID: string | undefined;
    mortgagE_PUBLISHER_ID: string | undefined;
    legaL_ENTITY_TYPE: string | undefined;
    legaL_ENTITY_REF_ID: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    remaiN_DEBT: number;
    mortgagE_INITIAL_COVERAGE_RATIO: string | undefined;
    mortgagE_CURRENT_COVERAGE_RATIO: string | undefined;
    numbeR_OF_MORTGAGE_PROPERTIES: number;
    mortgagE_TYPE_NAME: string | undefined;
    mortgagE_STATUS_NAME: string | undefined;
    mortgagE_ITEM_LIST: REA_MORTGAGE_ITEM_ENTITY[] | undefined;
    mortgagE_SHARE_LIST: REA_MORTGAGE_SHARE_ENTITY[] | undefined;
    releasE_HISTORY_LIST: REA_MORTGAGE_RELEASE_HISTORY_ENTITY[] | undefined;
    changE_HISTORY_LIST: REA_MORTGAGE_CHANGE_HISTORY_ENTITY[] | undefined;
    deleteD_MORTGAGE_ITEM_ID_LIST: string[] | undefined;
    deleteD_MORTGAGE_SHARE_ID_LIST: string[] | undefined;
    deleteD_MORTGAGE_RELEASE_HISTORY_ID_LIST: string[] | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_MORTGAGE_ITEM_ENTITY implements IREA_MORTGAGE_ITEM_ENTITY {
    morgagE_ITEM_ID!: string | undefined;
    mortgagE_ID!: string | undefined;
    valuation!: REA_VALUATION_ENTITY;
    mortgagE_STATUS!: string | undefined;
    mortagE_ITEM_IS_SHARED!: boolean;
    mortgagE_ITEM_STATUS!: string | undefined;
    notes!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    modifieR_ID!: string | undefined;
    modifY_DT!: moment.Moment | undefined;
    mortgagE_STATUS_NAME!: string | undefined;
    mortgagE_ITEM_STATUS_NAME!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_MORTGAGE_ITEM_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.morgagE_ITEM_ID = data["morgagE_ITEM_ID"];
            this.mortgagE_ID = data["mortgagE_ID"];
            this.valuation = data["valuation"] ? REA_VALUATION_ENTITY.fromJS(data["valuation"]) : <any>undefined;
            this.mortgagE_STATUS = data["mortgagE_STATUS"];
            this.mortagE_ITEM_IS_SHARED = data["mortagE_ITEM_IS_SHARED"];
            this.mortgagE_ITEM_STATUS = data["mortgagE_ITEM_STATUS"];
            this.notes = data["notes"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.modifieR_ID = data["modifieR_ID"];
            this.modifY_DT = data["modifY_DT"] ? moment(data["modifY_DT"].toString()) : <any>undefined;
            this.mortgagE_STATUS_NAME = data["mortgagE_STATUS_NAME"];
            this.mortgagE_ITEM_STATUS_NAME = data["mortgagE_ITEM_STATUS_NAME"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_MORTGAGE_ITEM_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_MORTGAGE_ITEM_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["morgagE_ITEM_ID"] = this.morgagE_ITEM_ID;
        data["mortgagE_ID"] = this.mortgagE_ID;
        data["valuation"] = this.valuation ? this.valuation.toJSON() : <any>undefined;
        data["mortgagE_STATUS"] = this.mortgagE_STATUS;
        data["mortagE_ITEM_IS_SHARED"] = this.mortagE_ITEM_IS_SHARED;
        data["mortgagE_ITEM_STATUS"] = this.mortgagE_ITEM_STATUS;
        data["notes"] = this.notes;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["modifieR_ID"] = this.modifieR_ID;
        data["modifY_DT"] = this.modifY_DT ? this.modifY_DT.toISOString() : <any>undefined;
        data["mortgagE_STATUS_NAME"] = this.mortgagE_STATUS_NAME;
        data["mortgagE_ITEM_STATUS_NAME"] = this.mortgagE_ITEM_STATUS_NAME;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_MORTGAGE_ITEM_ENTITY {
    morgagE_ITEM_ID: string | undefined;
    mortgagE_ID: string | undefined;
    valuation: REA_VALUATION_ENTITY;
    mortgagE_STATUS: string | undefined;
    mortagE_ITEM_IS_SHARED: boolean;
    mortgagE_ITEM_STATUS: string | undefined;
    notes: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    modifieR_ID: string | undefined;
    modifY_DT: moment.Moment | undefined;
    mortgagE_STATUS_NAME: string | undefined;
    mortgagE_ITEM_STATUS_NAME: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_MORTGAGE_RELEASE_HISTORY_ENTITY implements IREA_MORTGAGE_RELEASE_HISTORY_ENTITY {
    reA_MORTGAGE_RELEASE_ID!: string | undefined;
    mortgagE_ID!: string | undefined;
    mortgagE_RELEASE_VALUE!: number;
    mortgagE_RELEASE_DATE!: moment.Moment | undefined;
    makeR_ID!: string | undefined;
    updatE_DT!: moment.Moment | undefined;
    notes!: string | undefined;
    remaiN_DEBT!: number | undefined;

    constructor(data?: IREA_MORTGAGE_RELEASE_HISTORY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reA_MORTGAGE_RELEASE_ID = data["reA_MORTGAGE_RELEASE_ID"];
            this.mortgagE_ID = data["mortgagE_ID"];
            this.mortgagE_RELEASE_VALUE = data["mortgagE_RELEASE_VALUE"];
            this.mortgagE_RELEASE_DATE = data["mortgagE_RELEASE_DATE"] ? moment(data["mortgagE_RELEASE_DATE"].toString()) : <any>undefined;
            this.makeR_ID = data["makeR_ID"];
            this.updatE_DT = data["updatE_DT"] ? moment(data["updatE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.remaiN_DEBT = data["remaiN_DEBT"];
        }
    }

    static fromJS(data: any): REA_MORTGAGE_RELEASE_HISTORY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_MORTGAGE_RELEASE_HISTORY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reA_MORTGAGE_RELEASE_ID"] = this.reA_MORTGAGE_RELEASE_ID;
        data["mortgagE_ID"] = this.mortgagE_ID;
        data["mortgagE_RELEASE_VALUE"] = this.mortgagE_RELEASE_VALUE;
        data["mortgagE_RELEASE_DATE"] = this.mortgagE_RELEASE_DATE ? this.mortgagE_RELEASE_DATE.toISOString() : <any>undefined;
        data["makeR_ID"] = this.makeR_ID;
        data["updatE_DT"] = this.updatE_DT ? this.updatE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["remaiN_DEBT"] = this.remaiN_DEBT;
        return data; 
    }
}

export interface IREA_MORTGAGE_RELEASE_HISTORY_ENTITY {
    reA_MORTGAGE_RELEASE_ID: string | undefined;
    mortgagE_ID: string | undefined;
    mortgagE_RELEASE_VALUE: number;
    mortgagE_RELEASE_DATE: moment.Moment | undefined;
    makeR_ID: string | undefined;
    updatE_DT: moment.Moment | undefined;
    notes: string | undefined;
    remaiN_DEBT: number | undefined;
}

export class REA_MORTGAGE_SHARE_ENTITY implements IREA_MORTGAGE_SHARE_ENTITY {
    mortgagE_SHARE_ID!: string | undefined;
    mortgagE_NAME!: string | undefined;
    mortgagE_ID!: string | undefined;
    valuation!: REA_VALUATION_ENTITY;
    mortgagE_SHARE_REF_ID!: string | undefined;
    shareholdeR_ID!: string | undefined;
    mortgagE_SHARE_IS_SHARED!: boolean;
    mortgagE_SHARE_QUANTITY!: number;
    mortgagE_SHARE_TOTAL_VALUATION_VALUE!: number;
    mortgagE_STATUS!: string | undefined;
    mortgagE_SHARE_STATUS!: string | undefined;
    notes!: string | undefined;
    mortgagE_STATUS_NAME!: string | undefined;
    mortgagE_ITEM_STATUS_NAME!: string | undefined;

    constructor(data?: IREA_MORTGAGE_SHARE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mortgagE_SHARE_ID = data["mortgagE_SHARE_ID"];
            this.mortgagE_NAME = data["mortgagE_NAME"];
            this.mortgagE_ID = data["mortgagE_ID"];
            this.valuation = data["valuation"] ? REA_VALUATION_ENTITY.fromJS(data["valuation"]) : <any>undefined;
            this.mortgagE_SHARE_REF_ID = data["mortgagE_SHARE_REF_ID"];
            this.shareholdeR_ID = data["shareholdeR_ID"];
            this.mortgagE_SHARE_IS_SHARED = data["mortgagE_SHARE_IS_SHARED"];
            this.mortgagE_SHARE_QUANTITY = data["mortgagE_SHARE_QUANTITY"];
            this.mortgagE_SHARE_TOTAL_VALUATION_VALUE = data["mortgagE_SHARE_TOTAL_VALUATION_VALUE"];
            this.mortgagE_STATUS = data["mortgagE_STATUS"];
            this.mortgagE_SHARE_STATUS = data["mortgagE_SHARE_STATUS"];
            this.notes = data["notes"];
            this.mortgagE_STATUS_NAME = data["mortgagE_STATUS_NAME"];
            this.mortgagE_ITEM_STATUS_NAME = data["mortgagE_ITEM_STATUS_NAME"];
        }
    }

    static fromJS(data: any): REA_MORTGAGE_SHARE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_MORTGAGE_SHARE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mortgagE_SHARE_ID"] = this.mortgagE_SHARE_ID;
        data["mortgagE_NAME"] = this.mortgagE_NAME;
        data["mortgagE_ID"] = this.mortgagE_ID;
        data["valuation"] = this.valuation ? this.valuation.toJSON() : <any>undefined;
        data["mortgagE_SHARE_REF_ID"] = this.mortgagE_SHARE_REF_ID;
        data["shareholdeR_ID"] = this.shareholdeR_ID;
        data["mortgagE_SHARE_IS_SHARED"] = this.mortgagE_SHARE_IS_SHARED;
        data["mortgagE_SHARE_QUANTITY"] = this.mortgagE_SHARE_QUANTITY;
        data["mortgagE_SHARE_TOTAL_VALUATION_VALUE"] = this.mortgagE_SHARE_TOTAL_VALUATION_VALUE;
        data["mortgagE_STATUS"] = this.mortgagE_STATUS;
        data["mortgagE_SHARE_STATUS"] = this.mortgagE_SHARE_STATUS;
        data["notes"] = this.notes;
        data["mortgagE_STATUS_NAME"] = this.mortgagE_STATUS_NAME;
        data["mortgagE_ITEM_STATUS_NAME"] = this.mortgagE_ITEM_STATUS_NAME;
        return data; 
    }
}

export interface IREA_MORTGAGE_SHARE_ENTITY {
    mortgagE_SHARE_ID: string | undefined;
    mortgagE_NAME: string | undefined;
    mortgagE_ID: string | undefined;
    valuation: REA_VALUATION_ENTITY;
    mortgagE_SHARE_REF_ID: string | undefined;
    shareholdeR_ID: string | undefined;
    mortgagE_SHARE_IS_SHARED: boolean;
    mortgagE_SHARE_QUANTITY: number;
    mortgagE_SHARE_TOTAL_VALUATION_VALUE: number;
    mortgagE_STATUS: string | undefined;
    mortgagE_SHARE_STATUS: string | undefined;
    notes: string | undefined;
    mortgagE_STATUS_NAME: string | undefined;
    mortgagE_ITEM_STATUS_NAME: string | undefined;
}

export class REA_OUTSIDE_SHAREHOLDER_ENTITY implements IREA_OUTSIDE_SHAREHOLDER_ENTITY {
    o_SHAREHOLDER_ID!: string | undefined;
    o_SHAREHOLDER_NAME!: string | undefined;
    o_SHAREHOLDER_CODE!: string | undefined;
    o_SHAREHOLDER_ADDRESS!: string | undefined;
    o_SHAREHOLDER_EMAIL!: string | undefined;
    o_SHAREHOLDER_PHONE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_OUTSIDE_SHAREHOLDER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.o_SHAREHOLDER_ID = data["o_SHAREHOLDER_ID"];
            this.o_SHAREHOLDER_NAME = data["o_SHAREHOLDER_NAME"];
            this.o_SHAREHOLDER_CODE = data["o_SHAREHOLDER_CODE"];
            this.o_SHAREHOLDER_ADDRESS = data["o_SHAREHOLDER_ADDRESS"];
            this.o_SHAREHOLDER_EMAIL = data["o_SHAREHOLDER_EMAIL"];
            this.o_SHAREHOLDER_PHONE = data["o_SHAREHOLDER_PHONE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_OUTSIDE_SHAREHOLDER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_OUTSIDE_SHAREHOLDER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["o_SHAREHOLDER_ID"] = this.o_SHAREHOLDER_ID;
        data["o_SHAREHOLDER_NAME"] = this.o_SHAREHOLDER_NAME;
        data["o_SHAREHOLDER_CODE"] = this.o_SHAREHOLDER_CODE;
        data["o_SHAREHOLDER_ADDRESS"] = this.o_SHAREHOLDER_ADDRESS;
        data["o_SHAREHOLDER_EMAIL"] = this.o_SHAREHOLDER_EMAIL;
        data["o_SHAREHOLDER_PHONE"] = this.o_SHAREHOLDER_PHONE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_OUTSIDE_SHAREHOLDER_ENTITY {
    o_SHAREHOLDER_ID: string | undefined;
    o_SHAREHOLDER_NAME: string | undefined;
    o_SHAREHOLDER_CODE: string | undefined;
    o_SHAREHOLDER_ADDRESS: string | undefined;
    o_SHAREHOLDER_EMAIL: string | undefined;
    o_SHAREHOLDER_PHONE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_OWNER_ENTITY implements IREA_OWNER_ENTITY {
    owneR_ID!: string | undefined;
    owneR_NAME!: string | undefined;
    owneR_TYPE!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    owneR_TYPE_NAME!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_OWNER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.owneR_ID = data["owneR_ID"];
            this.owneR_NAME = data["owneR_NAME"];
            this.owneR_TYPE = data["owneR_TYPE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.owneR_TYPE_NAME = data["owneR_TYPE_NAME"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_OWNER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_OWNER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["owneR_ID"] = this.owneR_ID;
        data["owneR_NAME"] = this.owneR_NAME;
        data["owneR_TYPE"] = this.owneR_TYPE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["owneR_TYPE_NAME"] = this.owneR_TYPE_NAME;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_OWNER_ENTITY {
    owneR_ID: string | undefined;
    owneR_NAME: string | undefined;
    owneR_TYPE: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    owneR_TYPE_NAME: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_PROJECT_COOPERATE_STRUCTURE_ENTITY implements IREA_PROJECT_COOPERATE_STRUCTURE_ENTITY {
    cooperatE_STRUCTURE_ID!: string | undefined;
    projecT_ID!: string | undefined;
    entitY_TYPE!: string | undefined;
    entitY_ID!: string | undefined;
    cooperatE_STRUCTURE_METHOD!: string | undefined;
    cooperatE_STRUCTURE_OWN_RATE!: string | undefined;
    entitY_TYPE_NAME!: string | undefined;
    entitY_NAME!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_PROJECT_COOPERATE_STRUCTURE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cooperatE_STRUCTURE_ID = data["cooperatE_STRUCTURE_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.entitY_TYPE = data["entitY_TYPE"];
            this.entitY_ID = data["entitY_ID"];
            this.cooperatE_STRUCTURE_METHOD = data["cooperatE_STRUCTURE_METHOD"];
            this.cooperatE_STRUCTURE_OWN_RATE = data["cooperatE_STRUCTURE_OWN_RATE"];
            this.entitY_TYPE_NAME = data["entitY_TYPE_NAME"];
            this.entitY_NAME = data["entitY_NAME"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_PROJECT_COOPERATE_STRUCTURE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_COOPERATE_STRUCTURE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cooperatE_STRUCTURE_ID"] = this.cooperatE_STRUCTURE_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["entitY_TYPE"] = this.entitY_TYPE;
        data["entitY_ID"] = this.entitY_ID;
        data["cooperatE_STRUCTURE_METHOD"] = this.cooperatE_STRUCTURE_METHOD;
        data["cooperatE_STRUCTURE_OWN_RATE"] = this.cooperatE_STRUCTURE_OWN_RATE;
        data["entitY_TYPE_NAME"] = this.entitY_TYPE_NAME;
        data["entitY_NAME"] = this.entitY_NAME;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_PROJECT_COOPERATE_STRUCTURE_ENTITY {
    cooperatE_STRUCTURE_ID: string | undefined;
    projecT_ID: string | undefined;
    entitY_TYPE: string | undefined;
    entitY_ID: string | undefined;
    cooperatE_STRUCTURE_METHOD: string | undefined;
    cooperatE_STRUCTURE_OWN_RATE: string | undefined;
    entitY_TYPE_NAME: string | undefined;
    entitY_NAME: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_PROJECT_ENTITY implements IREA_PROJECT_ENTITY {
    projecT_ID!: string | undefined;
    provincE_ID!: string | undefined;
    investoR_ID!: string | undefined;
    projecT_NAME!: string | undefined;
    projecT_TYPE!: string | undefined;
    projecT_COMPLETE_STATUS!: string | undefined;
    projecT_SCALE!: number;
    projecT_LOCATION!: string | undefined;
    projecT_SALE_MANAGEMENT_PARTY!: string | undefined;
    rejecT_REASON!: string | undefined;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    projecT_TYPE_NAME!: string | undefined;
    projecT_COMPLETE_STATUS_NAME!: string | undefined;
    attacheD_IMAGES!: REA_FILE_ENTITY[] | undefined;
    owN_LIST!: REA_PROJECT_OWN_STRUCTURE_ENTITY[] | undefined;
    cooperatE_LIST!: REA_PROJECT_COOPERATE_STRUCTURE_ENTITY[] | undefined;
    propertY_LIST!: REA_PROJECT_PROPERTY_ENTITY[] | undefined;
    exploitatioN_LIST!: REA_PROJECT_EXPLOITATION_ENTITY[] | undefined;
    legaL_STATUS!: REA_PROJECT_LEGAL_STATUS_ENTITY;
    valuation!: REA_VALUATION_ENTITY;
    registratioN_LIST!: REA_USE_REGISTRATION_ENTITY[] | undefined;
    progress!: REA_PROJECT_PROGRESS_ENTITY[] | undefined;
    deleteD_OWN_ID_LIST!: string[] | undefined;
    deleteD_COOPERATE_ID_LIST!: string[] | undefined;
    deleteD_PROPERTY_ID_LIST!: string[] | undefined;
    deleteD_EXPLOITATION_ID_LIST!: string[] | undefined;
    deleteD_USE_REGISTRATION_ID_LIST!: string[] | undefined;
    deleteD_PROGRESS_ID_LIST!: string[] | undefined;

    constructor(data?: IREA_PROJECT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projecT_ID = data["projecT_ID"];
            this.provincE_ID = data["provincE_ID"];
            this.investoR_ID = data["investoR_ID"];
            this.projecT_NAME = data["projecT_NAME"];
            this.projecT_TYPE = data["projecT_TYPE"];
            this.projecT_COMPLETE_STATUS = data["projecT_COMPLETE_STATUS"];
            this.projecT_SCALE = data["projecT_SCALE"];
            this.projecT_LOCATION = data["projecT_LOCATION"];
            this.projecT_SALE_MANAGEMENT_PARTY = data["projecT_SALE_MANAGEMENT_PARTY"];
            this.rejecT_REASON = data["rejecT_REASON"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.projecT_TYPE_NAME = data["projecT_TYPE_NAME"];
            this.projecT_COMPLETE_STATUS_NAME = data["projecT_COMPLETE_STATUS_NAME"];
            if (data["attacheD_IMAGES"] && data["attacheD_IMAGES"].constructor === Array) {
                this.attacheD_IMAGES = [] as any;
                for (let item of data["attacheD_IMAGES"])
                    this.attacheD_IMAGES!.push(REA_FILE_ENTITY.fromJS(item));
            }
            if (data["owN_LIST"] && data["owN_LIST"].constructor === Array) {
                this.owN_LIST = [] as any;
                for (let item of data["owN_LIST"])
                    this.owN_LIST!.push(REA_PROJECT_OWN_STRUCTURE_ENTITY.fromJS(item));
            }
            if (data["cooperatE_LIST"] && data["cooperatE_LIST"].constructor === Array) {
                this.cooperatE_LIST = [] as any;
                for (let item of data["cooperatE_LIST"])
                    this.cooperatE_LIST!.push(REA_PROJECT_COOPERATE_STRUCTURE_ENTITY.fromJS(item));
            }
            if (data["propertY_LIST"] && data["propertY_LIST"].constructor === Array) {
                this.propertY_LIST = [] as any;
                for (let item of data["propertY_LIST"])
                    this.propertY_LIST!.push(REA_PROJECT_PROPERTY_ENTITY.fromJS(item));
            }
            if (data["exploitatioN_LIST"] && data["exploitatioN_LIST"].constructor === Array) {
                this.exploitatioN_LIST = [] as any;
                for (let item of data["exploitatioN_LIST"])
                    this.exploitatioN_LIST!.push(REA_PROJECT_EXPLOITATION_ENTITY.fromJS(item));
            }
            this.legaL_STATUS = data["legaL_STATUS"] ? REA_PROJECT_LEGAL_STATUS_ENTITY.fromJS(data["legaL_STATUS"]) : <any>undefined;
            this.valuation = data["valuation"] ? REA_VALUATION_ENTITY.fromJS(data["valuation"]) : <any>undefined;
            if (data["registratioN_LIST"] && data["registratioN_LIST"].constructor === Array) {
                this.registratioN_LIST = [] as any;
                for (let item of data["registratioN_LIST"])
                    this.registratioN_LIST!.push(REA_USE_REGISTRATION_ENTITY.fromJS(item));
            }
            if (data["progress"] && data["progress"].constructor === Array) {
                this.progress = [] as any;
                for (let item of data["progress"])
                    this.progress!.push(REA_PROJECT_PROGRESS_ENTITY.fromJS(item));
            }
            if (data["deleteD_OWN_ID_LIST"] && data["deleteD_OWN_ID_LIST"].constructor === Array) {
                this.deleteD_OWN_ID_LIST = [] as any;
                for (let item of data["deleteD_OWN_ID_LIST"])
                    this.deleteD_OWN_ID_LIST!.push(item);
            }
            if (data["deleteD_COOPERATE_ID_LIST"] && data["deleteD_COOPERATE_ID_LIST"].constructor === Array) {
                this.deleteD_COOPERATE_ID_LIST = [] as any;
                for (let item of data["deleteD_COOPERATE_ID_LIST"])
                    this.deleteD_COOPERATE_ID_LIST!.push(item);
            }
            if (data["deleteD_PROPERTY_ID_LIST"] && data["deleteD_PROPERTY_ID_LIST"].constructor === Array) {
                this.deleteD_PROPERTY_ID_LIST = [] as any;
                for (let item of data["deleteD_PROPERTY_ID_LIST"])
                    this.deleteD_PROPERTY_ID_LIST!.push(item);
            }
            if (data["deleteD_EXPLOITATION_ID_LIST"] && data["deleteD_EXPLOITATION_ID_LIST"].constructor === Array) {
                this.deleteD_EXPLOITATION_ID_LIST = [] as any;
                for (let item of data["deleteD_EXPLOITATION_ID_LIST"])
                    this.deleteD_EXPLOITATION_ID_LIST!.push(item);
            }
            if (data["deleteD_USE_REGISTRATION_ID_LIST"] && data["deleteD_USE_REGISTRATION_ID_LIST"].constructor === Array) {
                this.deleteD_USE_REGISTRATION_ID_LIST = [] as any;
                for (let item of data["deleteD_USE_REGISTRATION_ID_LIST"])
                    this.deleteD_USE_REGISTRATION_ID_LIST!.push(item);
            }
            if (data["deleteD_PROGRESS_ID_LIST"] && data["deleteD_PROGRESS_ID_LIST"].constructor === Array) {
                this.deleteD_PROGRESS_ID_LIST = [] as any;
                for (let item of data["deleteD_PROGRESS_ID_LIST"])
                    this.deleteD_PROGRESS_ID_LIST!.push(item);
            }
        }
    }

    static fromJS(data: any): REA_PROJECT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projecT_ID"] = this.projecT_ID;
        data["provincE_ID"] = this.provincE_ID;
        data["investoR_ID"] = this.investoR_ID;
        data["projecT_NAME"] = this.projecT_NAME;
        data["projecT_TYPE"] = this.projecT_TYPE;
        data["projecT_COMPLETE_STATUS"] = this.projecT_COMPLETE_STATUS;
        data["projecT_SCALE"] = this.projecT_SCALE;
        data["projecT_LOCATION"] = this.projecT_LOCATION;
        data["projecT_SALE_MANAGEMENT_PARTY"] = this.projecT_SALE_MANAGEMENT_PARTY;
        data["rejecT_REASON"] = this.rejecT_REASON;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["projecT_TYPE_NAME"] = this.projecT_TYPE_NAME;
        data["projecT_COMPLETE_STATUS_NAME"] = this.projecT_COMPLETE_STATUS_NAME;
        if (this.attacheD_IMAGES && this.attacheD_IMAGES.constructor === Array) {
            data["attacheD_IMAGES"] = [];
            for (let item of this.attacheD_IMAGES)
                data["attacheD_IMAGES"].push(item.toJSON());
        }
        if (this.owN_LIST && this.owN_LIST.constructor === Array) {
            data["owN_LIST"] = [];
            for (let item of this.owN_LIST)
                data["owN_LIST"].push(item.toJSON());
        }
        if (this.cooperatE_LIST && this.cooperatE_LIST.constructor === Array) {
            data["cooperatE_LIST"] = [];
            for (let item of this.cooperatE_LIST)
                data["cooperatE_LIST"].push(item.toJSON());
        }
        if (this.propertY_LIST && this.propertY_LIST.constructor === Array) {
            data["propertY_LIST"] = [];
            for (let item of this.propertY_LIST)
                data["propertY_LIST"].push(item.toJSON());
        }
        if (this.exploitatioN_LIST && this.exploitatioN_LIST.constructor === Array) {
            data["exploitatioN_LIST"] = [];
            for (let item of this.exploitatioN_LIST)
                data["exploitatioN_LIST"].push(item.toJSON());
        }
        data["legaL_STATUS"] = this.legaL_STATUS ? this.legaL_STATUS.toJSON() : <any>undefined;
        data["valuation"] = this.valuation ? this.valuation.toJSON() : <any>undefined;
        if (this.registratioN_LIST && this.registratioN_LIST.constructor === Array) {
            data["registratioN_LIST"] = [];
            for (let item of this.registratioN_LIST)
                data["registratioN_LIST"].push(item.toJSON());
        }
        if (this.progress && this.progress.constructor === Array) {
            data["progress"] = [];
            for (let item of this.progress)
                data["progress"].push(item.toJSON());
        }
        if (this.deleteD_OWN_ID_LIST && this.deleteD_OWN_ID_LIST.constructor === Array) {
            data["deleteD_OWN_ID_LIST"] = [];
            for (let item of this.deleteD_OWN_ID_LIST)
                data["deleteD_OWN_ID_LIST"].push(item);
        }
        if (this.deleteD_COOPERATE_ID_LIST && this.deleteD_COOPERATE_ID_LIST.constructor === Array) {
            data["deleteD_COOPERATE_ID_LIST"] = [];
            for (let item of this.deleteD_COOPERATE_ID_LIST)
                data["deleteD_COOPERATE_ID_LIST"].push(item);
        }
        if (this.deleteD_PROPERTY_ID_LIST && this.deleteD_PROPERTY_ID_LIST.constructor === Array) {
            data["deleteD_PROPERTY_ID_LIST"] = [];
            for (let item of this.deleteD_PROPERTY_ID_LIST)
                data["deleteD_PROPERTY_ID_LIST"].push(item);
        }
        if (this.deleteD_EXPLOITATION_ID_LIST && this.deleteD_EXPLOITATION_ID_LIST.constructor === Array) {
            data["deleteD_EXPLOITATION_ID_LIST"] = [];
            for (let item of this.deleteD_EXPLOITATION_ID_LIST)
                data["deleteD_EXPLOITATION_ID_LIST"].push(item);
        }
        if (this.deleteD_USE_REGISTRATION_ID_LIST && this.deleteD_USE_REGISTRATION_ID_LIST.constructor === Array) {
            data["deleteD_USE_REGISTRATION_ID_LIST"] = [];
            for (let item of this.deleteD_USE_REGISTRATION_ID_LIST)
                data["deleteD_USE_REGISTRATION_ID_LIST"].push(item);
        }
        if (this.deleteD_PROGRESS_ID_LIST && this.deleteD_PROGRESS_ID_LIST.constructor === Array) {
            data["deleteD_PROGRESS_ID_LIST"] = [];
            for (let item of this.deleteD_PROGRESS_ID_LIST)
                data["deleteD_PROGRESS_ID_LIST"].push(item);
        }
        return data; 
    }
}

export interface IREA_PROJECT_ENTITY {
    projecT_ID: string | undefined;
    provincE_ID: string | undefined;
    investoR_ID: string | undefined;
    projecT_NAME: string | undefined;
    projecT_TYPE: string | undefined;
    projecT_COMPLETE_STATUS: string | undefined;
    projecT_SCALE: number;
    projecT_LOCATION: string | undefined;
    projecT_SALE_MANAGEMENT_PARTY: string | undefined;
    rejecT_REASON: string | undefined;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    projecT_TYPE_NAME: string | undefined;
    projecT_COMPLETE_STATUS_NAME: string | undefined;
    attacheD_IMAGES: REA_FILE_ENTITY[] | undefined;
    owN_LIST: REA_PROJECT_OWN_STRUCTURE_ENTITY[] | undefined;
    cooperatE_LIST: REA_PROJECT_COOPERATE_STRUCTURE_ENTITY[] | undefined;
    propertY_LIST: REA_PROJECT_PROPERTY_ENTITY[] | undefined;
    exploitatioN_LIST: REA_PROJECT_EXPLOITATION_ENTITY[] | undefined;
    legaL_STATUS: REA_PROJECT_LEGAL_STATUS_ENTITY;
    valuation: REA_VALUATION_ENTITY;
    registratioN_LIST: REA_USE_REGISTRATION_ENTITY[] | undefined;
    progress: REA_PROJECT_PROGRESS_ENTITY[] | undefined;
    deleteD_OWN_ID_LIST: string[] | undefined;
    deleteD_COOPERATE_ID_LIST: string[] | undefined;
    deleteD_PROPERTY_ID_LIST: string[] | undefined;
    deleteD_EXPLOITATION_ID_LIST: string[] | undefined;
    deleteD_USE_REGISTRATION_ID_LIST: string[] | undefined;
    deleteD_PROGRESS_ID_LIST: string[] | undefined;
}

export class REA_PROJECT_EXPLOITATION_ENTITY implements IREA_PROJECT_EXPLOITATION_ENTITY {
    exP_ID!: string | undefined;
    projecT_ID!: string | undefined;
    areA_ID!: string | undefined;
    exP_PARTY!: string | undefined;
    exP_CONTRACT_NO!: string | undefined;
    exP_CONTRACT_NAME!: string | undefined;
    exP_CONTRACT_SIGN_DT!: moment.Moment | undefined;
    exP_CONTACT_EXPIRE_DT!: moment.Moment | undefined;
    exP_USE_AREA!: number;
    exP_USE_PURPOSE!: string | undefined;
    exP_REVENUE_PER_YEAR!: string | undefined;
    notes!: string | undefined;
    areA_NAME!: string | undefined;
    attacheD_IMAGE!: REA_FILE_ENTITY;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_PROJECT_EXPLOITATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exP_ID = data["exP_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.areA_ID = data["areA_ID"];
            this.exP_PARTY = data["exP_PARTY"];
            this.exP_CONTRACT_NO = data["exP_CONTRACT_NO"];
            this.exP_CONTRACT_NAME = data["exP_CONTRACT_NAME"];
            this.exP_CONTRACT_SIGN_DT = data["exP_CONTRACT_SIGN_DT"] ? moment(data["exP_CONTRACT_SIGN_DT"].toString()) : <any>undefined;
            this.exP_CONTACT_EXPIRE_DT = data["exP_CONTACT_EXPIRE_DT"] ? moment(data["exP_CONTACT_EXPIRE_DT"].toString()) : <any>undefined;
            this.exP_USE_AREA = data["exP_USE_AREA"];
            this.exP_USE_PURPOSE = data["exP_USE_PURPOSE"];
            this.exP_REVENUE_PER_YEAR = data["exP_REVENUE_PER_YEAR"];
            this.notes = data["notes"];
            this.areA_NAME = data["areA_NAME"];
            this.attacheD_IMAGE = data["attacheD_IMAGE"] ? REA_FILE_ENTITY.fromJS(data["attacheD_IMAGE"]) : <any>undefined;
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_PROJECT_EXPLOITATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_EXPLOITATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exP_ID"] = this.exP_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["areA_ID"] = this.areA_ID;
        data["exP_PARTY"] = this.exP_PARTY;
        data["exP_CONTRACT_NO"] = this.exP_CONTRACT_NO;
        data["exP_CONTRACT_NAME"] = this.exP_CONTRACT_NAME;
        data["exP_CONTRACT_SIGN_DT"] = this.exP_CONTRACT_SIGN_DT ? this.exP_CONTRACT_SIGN_DT.toISOString() : <any>undefined;
        data["exP_CONTACT_EXPIRE_DT"] = this.exP_CONTACT_EXPIRE_DT ? this.exP_CONTACT_EXPIRE_DT.toISOString() : <any>undefined;
        data["exP_USE_AREA"] = this.exP_USE_AREA;
        data["exP_USE_PURPOSE"] = this.exP_USE_PURPOSE;
        data["exP_REVENUE_PER_YEAR"] = this.exP_REVENUE_PER_YEAR;
        data["notes"] = this.notes;
        data["areA_NAME"] = this.areA_NAME;
        data["attacheD_IMAGE"] = this.attacheD_IMAGE ? this.attacheD_IMAGE.toJSON() : <any>undefined;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_PROJECT_EXPLOITATION_ENTITY {
    exP_ID: string | undefined;
    projecT_ID: string | undefined;
    areA_ID: string | undefined;
    exP_PARTY: string | undefined;
    exP_CONTRACT_NO: string | undefined;
    exP_CONTRACT_NAME: string | undefined;
    exP_CONTRACT_SIGN_DT: moment.Moment | undefined;
    exP_CONTACT_EXPIRE_DT: moment.Moment | undefined;
    exP_USE_AREA: number;
    exP_USE_PURPOSE: string | undefined;
    exP_REVENUE_PER_YEAR: string | undefined;
    notes: string | undefined;
    areA_NAME: string | undefined;
    attacheD_IMAGE: REA_FILE_ENTITY;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_PROJECT_LEGAL_STATUS_ENTITY implements IREA_PROJECT_LEGAL_STATUS_ENTITY {
    legaL_STATUS_ID!: string | undefined;
    propjecT_ID!: string | undefined;
    legaL_STATUS_INVESTMENT!: string | undefined;
    legaL_STATUS_LAND!: string | undefined;
    legaL_STATUS_PLANNING!: string | undefined;
    legaL_STATUS_CONSTRUCTION!: string | undefined;
    legaL_STATUS_DEPLOY_ABILITY!: string | undefined;
    legaL_STATUS_DEPLOY_DT!: string | undefined;
    legaL_STATUS_PROJECT_STATUS!: string | undefined;
    legaL_STATUS_SALE_PLAN!: string | undefined;
    legaL_STATUS_PRODUCT_TYPE!: string | undefined;
    legaL_STATUS_UNIT_PRICE!: number;

    constructor(data?: IREA_PROJECT_LEGAL_STATUS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legaL_STATUS_ID = data["legaL_STATUS_ID"];
            this.propjecT_ID = data["propjecT_ID"];
            this.legaL_STATUS_INVESTMENT = data["legaL_STATUS_INVESTMENT"];
            this.legaL_STATUS_LAND = data["legaL_STATUS_LAND"];
            this.legaL_STATUS_PLANNING = data["legaL_STATUS_PLANNING"];
            this.legaL_STATUS_CONSTRUCTION = data["legaL_STATUS_CONSTRUCTION"];
            this.legaL_STATUS_DEPLOY_ABILITY = data["legaL_STATUS_DEPLOY_ABILITY"];
            this.legaL_STATUS_DEPLOY_DT = data["legaL_STATUS_DEPLOY_DT"];
            this.legaL_STATUS_PROJECT_STATUS = data["legaL_STATUS_PROJECT_STATUS"];
            this.legaL_STATUS_SALE_PLAN = data["legaL_STATUS_SALE_PLAN"];
            this.legaL_STATUS_PRODUCT_TYPE = data["legaL_STATUS_PRODUCT_TYPE"];
            this.legaL_STATUS_UNIT_PRICE = data["legaL_STATUS_UNIT_PRICE"];
        }
    }

    static fromJS(data: any): REA_PROJECT_LEGAL_STATUS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_LEGAL_STATUS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legaL_STATUS_ID"] = this.legaL_STATUS_ID;
        data["propjecT_ID"] = this.propjecT_ID;
        data["legaL_STATUS_INVESTMENT"] = this.legaL_STATUS_INVESTMENT;
        data["legaL_STATUS_LAND"] = this.legaL_STATUS_LAND;
        data["legaL_STATUS_PLANNING"] = this.legaL_STATUS_PLANNING;
        data["legaL_STATUS_CONSTRUCTION"] = this.legaL_STATUS_CONSTRUCTION;
        data["legaL_STATUS_DEPLOY_ABILITY"] = this.legaL_STATUS_DEPLOY_ABILITY;
        data["legaL_STATUS_DEPLOY_DT"] = this.legaL_STATUS_DEPLOY_DT;
        data["legaL_STATUS_PROJECT_STATUS"] = this.legaL_STATUS_PROJECT_STATUS;
        data["legaL_STATUS_SALE_PLAN"] = this.legaL_STATUS_SALE_PLAN;
        data["legaL_STATUS_PRODUCT_TYPE"] = this.legaL_STATUS_PRODUCT_TYPE;
        data["legaL_STATUS_UNIT_PRICE"] = this.legaL_STATUS_UNIT_PRICE;
        return data; 
    }
}

export interface IREA_PROJECT_LEGAL_STATUS_ENTITY {
    legaL_STATUS_ID: string | undefined;
    propjecT_ID: string | undefined;
    legaL_STATUS_INVESTMENT: string | undefined;
    legaL_STATUS_LAND: string | undefined;
    legaL_STATUS_PLANNING: string | undefined;
    legaL_STATUS_CONSTRUCTION: string | undefined;
    legaL_STATUS_DEPLOY_ABILITY: string | undefined;
    legaL_STATUS_DEPLOY_DT: string | undefined;
    legaL_STATUS_PROJECT_STATUS: string | undefined;
    legaL_STATUS_SALE_PLAN: string | undefined;
    legaL_STATUS_PRODUCT_TYPE: string | undefined;
    legaL_STATUS_UNIT_PRICE: number;
}

export class REA_PROJECT_OWN_STRUCTURE_ENTITY implements IREA_PROJECT_OWN_STRUCTURE_ENTITY {
    owN_STRUCTURE_ID!: string | undefined;
    projecT_ID!: string | undefined;
    owN_COMPANY_ID!: string | undefined;
    shareholdeR_ID!: string | undefined;
    owN_STRUCTURE_SHARES!: number;
    owN_STRUCTURE_SHARE_VALUE!: number;
    owN_COMPANY_NAME!: string | undefined;
    shareholdeR_NAME!: string | undefined;
    owN_RATIO!: number;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_PROJECT_OWN_STRUCTURE_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.owN_STRUCTURE_ID = data["owN_STRUCTURE_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.owN_COMPANY_ID = data["owN_COMPANY_ID"];
            this.shareholdeR_ID = data["shareholdeR_ID"];
            this.owN_STRUCTURE_SHARES = data["owN_STRUCTURE_SHARES"];
            this.owN_STRUCTURE_SHARE_VALUE = data["owN_STRUCTURE_SHARE_VALUE"];
            this.owN_COMPANY_NAME = data["owN_COMPANY_NAME"];
            this.shareholdeR_NAME = data["shareholdeR_NAME"];
            this.owN_RATIO = data["owN_RATIO"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_PROJECT_OWN_STRUCTURE_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_OWN_STRUCTURE_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["owN_STRUCTURE_ID"] = this.owN_STRUCTURE_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["owN_COMPANY_ID"] = this.owN_COMPANY_ID;
        data["shareholdeR_ID"] = this.shareholdeR_ID;
        data["owN_STRUCTURE_SHARES"] = this.owN_STRUCTURE_SHARES;
        data["owN_STRUCTURE_SHARE_VALUE"] = this.owN_STRUCTURE_SHARE_VALUE;
        data["owN_COMPANY_NAME"] = this.owN_COMPANY_NAME;
        data["shareholdeR_NAME"] = this.shareholdeR_NAME;
        data["owN_RATIO"] = this.owN_RATIO;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_PROJECT_OWN_STRUCTURE_ENTITY {
    owN_STRUCTURE_ID: string | undefined;
    projecT_ID: string | undefined;
    owN_COMPANY_ID: string | undefined;
    shareholdeR_ID: string | undefined;
    owN_STRUCTURE_SHARES: number;
    owN_STRUCTURE_SHARE_VALUE: number;
    owN_COMPANY_NAME: string | undefined;
    shareholdeR_NAME: string | undefined;
    owN_RATIO: number;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_PROJECT_PROGRESS_ENTITY implements IREA_PROJECT_PROGRESS_ENTITY {
    projecT_PROGRESS_ID!: string | undefined;
    projecT_ID!: string | undefined;
    projecT_PROGRESS_DT!: moment.Moment | undefined;
    projecT_PROGRESS_CONTENT!: string | undefined;
    projecT_PROGRESS_ON_BUILD_VALUE!: number;
    notes!: string | undefined;
    attacheD_FILE!: REA_FILE_ENTITY;

    constructor(data?: IREA_PROJECT_PROGRESS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projecT_PROGRESS_ID = data["projecT_PROGRESS_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.projecT_PROGRESS_DT = data["projecT_PROGRESS_DT"] ? moment(data["projecT_PROGRESS_DT"].toString()) : <any>undefined;
            this.projecT_PROGRESS_CONTENT = data["projecT_PROGRESS_CONTENT"];
            this.projecT_PROGRESS_ON_BUILD_VALUE = data["projecT_PROGRESS_ON_BUILD_VALUE"];
            this.notes = data["notes"];
            this.attacheD_FILE = data["attacheD_FILE"] ? REA_FILE_ENTITY.fromJS(data["attacheD_FILE"]) : <any>undefined;
        }
    }

    static fromJS(data: any): REA_PROJECT_PROGRESS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_PROGRESS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projecT_PROGRESS_ID"] = this.projecT_PROGRESS_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["projecT_PROGRESS_DT"] = this.projecT_PROGRESS_DT ? this.projecT_PROGRESS_DT.toISOString() : <any>undefined;
        data["projecT_PROGRESS_CONTENT"] = this.projecT_PROGRESS_CONTENT;
        data["projecT_PROGRESS_ON_BUILD_VALUE"] = this.projecT_PROGRESS_ON_BUILD_VALUE;
        data["notes"] = this.notes;
        data["attacheD_FILE"] = this.attacheD_FILE ? this.attacheD_FILE.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IREA_PROJECT_PROGRESS_ENTITY {
    projecT_PROGRESS_ID: string | undefined;
    projecT_ID: string | undefined;
    projecT_PROGRESS_DT: moment.Moment | undefined;
    projecT_PROGRESS_CONTENT: string | undefined;
    projecT_PROGRESS_ON_BUILD_VALUE: number;
    notes: string | undefined;
    attacheD_FILE: REA_FILE_ENTITY;
}

export class REA_PROJECT_PROPERTY_ENTITY implements IREA_PROJECT_PROPERTY_ENTITY {
    projecT_PROP_ID!: string | undefined;
    projecT_ID!: string | undefined;
    areA_ID!: string | undefined;
    projecT_PROP_NAME!: string | undefined;
    projecT_PROP_DESCRIPTION!: string | undefined;
    projecT_PROP_AREA!: number;
    notes!: string | undefined;
    areA_NAME!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_PROJECT_PROPERTY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projecT_PROP_ID = data["projecT_PROP_ID"];
            this.projecT_ID = data["projecT_ID"];
            this.areA_ID = data["areA_ID"];
            this.projecT_PROP_NAME = data["projecT_PROP_NAME"];
            this.projecT_PROP_DESCRIPTION = data["projecT_PROP_DESCRIPTION"];
            this.projecT_PROP_AREA = data["projecT_PROP_AREA"];
            this.notes = data["notes"];
            this.areA_NAME = data["areA_NAME"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_PROJECT_PROPERTY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROJECT_PROPERTY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projecT_PROP_ID"] = this.projecT_PROP_ID;
        data["projecT_ID"] = this.projecT_ID;
        data["areA_ID"] = this.areA_ID;
        data["projecT_PROP_NAME"] = this.projecT_PROP_NAME;
        data["projecT_PROP_DESCRIPTION"] = this.projecT_PROP_DESCRIPTION;
        data["projecT_PROP_AREA"] = this.projecT_PROP_AREA;
        data["notes"] = this.notes;
        data["areA_NAME"] = this.areA_NAME;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_PROJECT_PROPERTY_ENTITY {
    projecT_PROP_ID: string | undefined;
    projecT_ID: string | undefined;
    areA_ID: string | undefined;
    projecT_PROP_NAME: string | undefined;
    projecT_PROP_DESCRIPTION: string | undefined;
    projecT_PROP_AREA: number;
    notes: string | undefined;
    areA_NAME: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_PROPERTY_INFORMATION implements IREA_PROPERTY_INFORMATION {
    propertY_NAME!: string | undefined;
    propertY_LEVEL_1!: string | undefined;
    propertY_LEVEL_2!: string | undefined;
    propertY_DESCRIPTION!: string | undefined;
    propertY_ORIGIN_PRICE!: string | undefined;
    propertY_COMPANY_NAME!: string | undefined;
    propertY_DEPRECIATION_STATUS!: string | undefined;

    constructor(data?: IREA_PROPERTY_INFORMATION) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertY_NAME = data["propertY_NAME"];
            this.propertY_LEVEL_1 = data["propertY_LEVEL_1"];
            this.propertY_LEVEL_2 = data["propertY_LEVEL_2"];
            this.propertY_DESCRIPTION = data["propertY_DESCRIPTION"];
            this.propertY_ORIGIN_PRICE = data["propertY_ORIGIN_PRICE"];
            this.propertY_COMPANY_NAME = data["propertY_COMPANY_NAME"];
            this.propertY_DEPRECIATION_STATUS = data["propertY_DEPRECIATION_STATUS"];
        }
    }

    static fromJS(data: any): REA_PROPERTY_INFORMATION {
        data = typeof data === 'object' ? data : {};
        let result = new REA_PROPERTY_INFORMATION();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertY_NAME"] = this.propertY_NAME;
        data["propertY_LEVEL_1"] = this.propertY_LEVEL_1;
        data["propertY_LEVEL_2"] = this.propertY_LEVEL_2;
        data["propertY_DESCRIPTION"] = this.propertY_DESCRIPTION;
        data["propertY_ORIGIN_PRICE"] = this.propertY_ORIGIN_PRICE;
        data["propertY_COMPANY_NAME"] = this.propertY_COMPANY_NAME;
        data["propertY_DEPRECIATION_STATUS"] = this.propertY_DEPRECIATION_STATUS;
        return data; 
    }
}

export interface IREA_PROPERTY_INFORMATION {
    propertY_NAME: string | undefined;
    propertY_LEVEL_1: string | undefined;
    propertY_LEVEL_2: string | undefined;
    propertY_DESCRIPTION: string | undefined;
    propertY_ORIGIN_PRICE: string | undefined;
    propertY_COMPANY_NAME: string | undefined;
    propertY_DEPRECIATION_STATUS: string | undefined;
}

export class REA_SHAREHOLDER_ENTITY implements IREA_SHAREHOLDER_ENTITY {
    shareholdeR_ID!: string | undefined;
    company!: CM_COMPANY_ENTITY;
    shareholdeR_TYPE!: string | undefined;
    shareholdeR_REF_ID!: string | undefined;
    shareholdeR_NAME!: string | undefined;
    shareholdeR_COUNT!: number;
    shareholdeR_VALUE!: number;
    notes!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    shareholdeR_TYPE_NAME!: string | undefined;
    mortgagE_LIST!: REA_MORTGAGE_SHARE_ENTITY[] | undefined;

    constructor(data?: IREA_SHAREHOLDER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shareholdeR_ID = data["shareholdeR_ID"];
            this.company = data["company"] ? CM_COMPANY_ENTITY.fromJS(data["company"]) : <any>undefined;
            this.shareholdeR_TYPE = data["shareholdeR_TYPE"];
            this.shareholdeR_REF_ID = data["shareholdeR_REF_ID"];
            this.shareholdeR_NAME = data["shareholdeR_NAME"];
            this.shareholdeR_COUNT = data["shareholdeR_COUNT"];
            this.shareholdeR_VALUE = data["shareholdeR_VALUE"];
            this.notes = data["notes"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.shareholdeR_TYPE_NAME = data["shareholdeR_TYPE_NAME"];
            if (data["mortgagE_LIST"] && data["mortgagE_LIST"].constructor === Array) {
                this.mortgagE_LIST = [] as any;
                for (let item of data["mortgagE_LIST"])
                    this.mortgagE_LIST!.push(REA_MORTGAGE_SHARE_ENTITY.fromJS(item));
            }
        }
    }

    static fromJS(data: any): REA_SHAREHOLDER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SHAREHOLDER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shareholdeR_ID"] = this.shareholdeR_ID;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["shareholdeR_TYPE"] = this.shareholdeR_TYPE;
        data["shareholdeR_REF_ID"] = this.shareholdeR_REF_ID;
        data["shareholdeR_NAME"] = this.shareholdeR_NAME;
        data["shareholdeR_COUNT"] = this.shareholdeR_COUNT;
        data["shareholdeR_VALUE"] = this.shareholdeR_VALUE;
        data["notes"] = this.notes;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["shareholdeR_TYPE_NAME"] = this.shareholdeR_TYPE_NAME;
        if (this.mortgagE_LIST && this.mortgagE_LIST.constructor === Array) {
            data["mortgagE_LIST"] = [];
            for (let item of this.mortgagE_LIST)
                data["mortgagE_LIST"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IREA_SHAREHOLDER_ENTITY {
    shareholdeR_ID: string | undefined;
    company: CM_COMPANY_ENTITY;
    shareholdeR_TYPE: string | undefined;
    shareholdeR_REF_ID: string | undefined;
    shareholdeR_NAME: string | undefined;
    shareholdeR_COUNT: number;
    shareholdeR_VALUE: number;
    notes: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    shareholdeR_TYPE_NAME: string | undefined;
    mortgagE_LIST: REA_MORTGAGE_SHARE_ENTITY[] | undefined;
}

export class REA_SODO_ADVANCE_PAYMENT_ENTITY implements IREA_SODO_ADVANCE_PAYMENT_ENTITY {
    sodO_ADVANCE_PAYMENT_ID!: string | undefined;
    sodO_ID!: string | undefined;
    advancE_RECIPIENT_ID!: string | undefined;
    sodO_ADVANCE_PAYMENT_MONEY!: number;
    sodO_ADVANCE_PAYMENT_DT!: moment.Moment | undefined;
    governmenT_COMPENSATE_MONEY!: number;
    sodO_ADVANCE_PAYMENT_RETURN!: number;
    notes!: string | undefined;
    sodO_ADVANCE_PAYMENT_REMAIN_MONEY!: number;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_ADVANCE_PAYMENT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_ADVANCE_PAYMENT_ID = data["sodO_ADVANCE_PAYMENT_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.advancE_RECIPIENT_ID = data["advancE_RECIPIENT_ID"];
            this.sodO_ADVANCE_PAYMENT_MONEY = data["sodO_ADVANCE_PAYMENT_MONEY"];
            this.sodO_ADVANCE_PAYMENT_DT = data["sodO_ADVANCE_PAYMENT_DT"] ? moment(data["sodO_ADVANCE_PAYMENT_DT"].toString()) : <any>undefined;
            this.governmenT_COMPENSATE_MONEY = data["governmenT_COMPENSATE_MONEY"];
            this.sodO_ADVANCE_PAYMENT_RETURN = data["sodO_ADVANCE_PAYMENT_RETURN"];
            this.notes = data["notes"];
            this.sodO_ADVANCE_PAYMENT_REMAIN_MONEY = data["sodO_ADVANCE_PAYMENT_REMAIN_MONEY"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_ADVANCE_PAYMENT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_ADVANCE_PAYMENT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_ADVANCE_PAYMENT_ID"] = this.sodO_ADVANCE_PAYMENT_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["advancE_RECIPIENT_ID"] = this.advancE_RECIPIENT_ID;
        data["sodO_ADVANCE_PAYMENT_MONEY"] = this.sodO_ADVANCE_PAYMENT_MONEY;
        data["sodO_ADVANCE_PAYMENT_DT"] = this.sodO_ADVANCE_PAYMENT_DT ? this.sodO_ADVANCE_PAYMENT_DT.toISOString() : <any>undefined;
        data["governmenT_COMPENSATE_MONEY"] = this.governmenT_COMPENSATE_MONEY;
        data["sodO_ADVANCE_PAYMENT_RETURN"] = this.sodO_ADVANCE_PAYMENT_RETURN;
        data["notes"] = this.notes;
        data["sodO_ADVANCE_PAYMENT_REMAIN_MONEY"] = this.sodO_ADVANCE_PAYMENT_REMAIN_MONEY;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_ADVANCE_PAYMENT_ENTITY {
    sodO_ADVANCE_PAYMENT_ID: string | undefined;
    sodO_ID: string | undefined;
    advancE_RECIPIENT_ID: string | undefined;
    sodO_ADVANCE_PAYMENT_MONEY: number;
    sodO_ADVANCE_PAYMENT_DT: moment.Moment | undefined;
    governmenT_COMPENSATE_MONEY: number;
    sodO_ADVANCE_PAYMENT_RETURN: number;
    notes: string | undefined;
    sodO_ADVANCE_PAYMENT_REMAIN_MONEY: number;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_BRIEF_1_ENTITY implements IREA_SODO_BRIEF_1_ENTITY {
    sodO_BRIEF_1_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_BRIEF_1_HDCNQSDD!: boolean;
    sodO_BRIEF_1_GCQDCNST!: boolean;
    sodO_BRIEF_1_BBTTDTH!: boolean;
    sodO_BRIEF_1_DC!: boolean;
    others!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_BRIEF_1_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_BRIEF_1_ID = data["sodO_BRIEF_1_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_BRIEF_1_HDCNQSDD = data["sodO_BRIEF_1_HDCNQSDD"];
            this.sodO_BRIEF_1_GCQDCNST = data["sodO_BRIEF_1_GCQDCNST"];
            this.sodO_BRIEF_1_BBTTDTH = data["sodO_BRIEF_1_BBTTDTH"];
            this.sodO_BRIEF_1_DC = data["sodO_BRIEF_1_DC"];
            this.others = data["others"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_BRIEF_1_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_BRIEF_1_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_BRIEF_1_ID"] = this.sodO_BRIEF_1_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_BRIEF_1_HDCNQSDD"] = this.sodO_BRIEF_1_HDCNQSDD;
        data["sodO_BRIEF_1_GCQDCNST"] = this.sodO_BRIEF_1_GCQDCNST;
        data["sodO_BRIEF_1_BBTTDTH"] = this.sodO_BRIEF_1_BBTTDTH;
        data["sodO_BRIEF_1_DC"] = this.sodO_BRIEF_1_DC;
        data["others"] = this.others;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_BRIEF_1_ENTITY {
    sodO_BRIEF_1_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_BRIEF_1_HDCNQSDD: boolean;
    sodO_BRIEF_1_GCQDCNST: boolean;
    sodO_BRIEF_1_BBTTDTH: boolean;
    sodO_BRIEF_1_DC: boolean;
    others: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_BRIEF_2_ENTITY implements IREA_SODO_BRIEF_2_ENTITY {
    sodO_BRIEF_2_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_BRIEF_2_HDUQCN!: boolean;
    sodO_BRIEF_2_HDCNVT!: boolean;
    sodO_BRIEF_2_GCQVDTCC!: boolean;
    sodO_BRIEF_2_DC!: boolean;
    others!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_BRIEF_2_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_BRIEF_2_ID = data["sodO_BRIEF_2_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_BRIEF_2_HDUQCN = data["sodO_BRIEF_2_HDUQCN"];
            this.sodO_BRIEF_2_HDCNVT = data["sodO_BRIEF_2_HDCNVT"];
            this.sodO_BRIEF_2_GCQVDTCC = data["sodO_BRIEF_2_GCQVDTCC"];
            this.sodO_BRIEF_2_DC = data["sodO_BRIEF_2_DC"];
            this.others = data["others"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_BRIEF_2_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_BRIEF_2_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_BRIEF_2_ID"] = this.sodO_BRIEF_2_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_BRIEF_2_HDUQCN"] = this.sodO_BRIEF_2_HDUQCN;
        data["sodO_BRIEF_2_HDCNVT"] = this.sodO_BRIEF_2_HDCNVT;
        data["sodO_BRIEF_2_GCQVDTCC"] = this.sodO_BRIEF_2_GCQVDTCC;
        data["sodO_BRIEF_2_DC"] = this.sodO_BRIEF_2_DC;
        data["others"] = this.others;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_BRIEF_2_ENTITY {
    sodO_BRIEF_2_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_BRIEF_2_HDUQCN: boolean;
    sodO_BRIEF_2_HDCNVT: boolean;
    sodO_BRIEF_2_GCQVDTCC: boolean;
    sodO_BRIEF_2_DC: boolean;
    others: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_BRIEF_3_ENTITY implements IREA_SODO_BRIEF_3_ENTITY {
    sodO_BRIEF_3_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_BRIEF_3_GUQ!: boolean;
    sodO_BRIEF_3_BBBGD!: boolean;
    sodO_BRIEF_3_DC!: boolean;
    sodO_BRIEF_3_BBTTDTH!: boolean;
    others!: boolean;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_BRIEF_3_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_BRIEF_3_ID = data["sodO_BRIEF_3_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_BRIEF_3_GUQ = data["sodO_BRIEF_3_GUQ"];
            this.sodO_BRIEF_3_BBBGD = data["sodO_BRIEF_3_BBBGD"];
            this.sodO_BRIEF_3_DC = data["sodO_BRIEF_3_DC"];
            this.sodO_BRIEF_3_BBTTDTH = data["sodO_BRIEF_3_BBTTDTH"];
            this.others = data["others"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_BRIEF_3_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_BRIEF_3_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_BRIEF_3_ID"] = this.sodO_BRIEF_3_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_BRIEF_3_GUQ"] = this.sodO_BRIEF_3_GUQ;
        data["sodO_BRIEF_3_BBBGD"] = this.sodO_BRIEF_3_BBBGD;
        data["sodO_BRIEF_3_DC"] = this.sodO_BRIEF_3_DC;
        data["sodO_BRIEF_3_BBTTDTH"] = this.sodO_BRIEF_3_BBTTDTH;
        data["others"] = this.others;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_BRIEF_3_ENTITY {
    sodO_BRIEF_3_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_BRIEF_3_GUQ: boolean;
    sodO_BRIEF_3_BBBGD: boolean;
    sodO_BRIEF_3_DC: boolean;
    sodO_BRIEF_3_BBTTDTH: boolean;
    others: boolean;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_BRIEF_4_ENTITY implements IREA_SODO_BRIEF_4_ENTITY {
    sodO_BRIEF_4_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_BRIEF_4_VB!: boolean;
    sodO_BRIEF_4_BBGND!: boolean;
    sodO_BRIEF_4_DI_CHUC!: boolean;
    sodO_BRIEF_4_BBTTDTH!: boolean;
    others!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_BRIEF_4_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_BRIEF_4_ID = data["sodO_BRIEF_4_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_BRIEF_4_VB = data["sodO_BRIEF_4_VB"];
            this.sodO_BRIEF_4_BBGND = data["sodO_BRIEF_4_BBGND"];
            this.sodO_BRIEF_4_DI_CHUC = data["sodO_BRIEF_4_DI_CHUC"];
            this.sodO_BRIEF_4_BBTTDTH = data["sodO_BRIEF_4_BBTTDTH"];
            this.others = data["others"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_BRIEF_4_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_BRIEF_4_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_BRIEF_4_ID"] = this.sodO_BRIEF_4_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_BRIEF_4_VB"] = this.sodO_BRIEF_4_VB;
        data["sodO_BRIEF_4_BBGND"] = this.sodO_BRIEF_4_BBGND;
        data["sodO_BRIEF_4_DI_CHUC"] = this.sodO_BRIEF_4_DI_CHUC;
        data["sodO_BRIEF_4_BBTTDTH"] = this.sodO_BRIEF_4_BBTTDTH;
        data["others"] = this.others;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_BRIEF_4_ENTITY {
    sodO_BRIEF_4_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_BRIEF_4_VB: boolean;
    sodO_BRIEF_4_BBGND: boolean;
    sodO_BRIEF_4_DI_CHUC: boolean;
    sodO_BRIEF_4_BBTTDTH: boolean;
    others: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_BRIEF_5_ENTITY implements IREA_SODO_BRIEF_5_ENTITY {
    sodO_BRIEF_5_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_BRIEF_5_TTDTH!: boolean;
    sodO_BRIEF_5_DC!: boolean;
    sodO_BRIEF_5_BBCKTT!: boolean;
    sodO_BRIEF_5_BBMTTN!: boolean;
    sodO_BRIEF_5_HDCNTS!: boolean;
    others!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_BRIEF_5_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_BRIEF_5_ID = data["sodO_BRIEF_5_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_BRIEF_5_TTDTH = data["sodO_BRIEF_5_TTDTH"];
            this.sodO_BRIEF_5_DC = data["sodO_BRIEF_5_DC"];
            this.sodO_BRIEF_5_BBCKTT = data["sodO_BRIEF_5_BBCKTT"];
            this.sodO_BRIEF_5_BBMTTN = data["sodO_BRIEF_5_BBMTTN"];
            this.sodO_BRIEF_5_HDCNTS = data["sodO_BRIEF_5_HDCNTS"];
            this.others = data["others"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_BRIEF_5_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_BRIEF_5_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_BRIEF_5_ID"] = this.sodO_BRIEF_5_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_BRIEF_5_TTDTH"] = this.sodO_BRIEF_5_TTDTH;
        data["sodO_BRIEF_5_DC"] = this.sodO_BRIEF_5_DC;
        data["sodO_BRIEF_5_BBCKTT"] = this.sodO_BRIEF_5_BBCKTT;
        data["sodO_BRIEF_5_BBMTTN"] = this.sodO_BRIEF_5_BBMTTN;
        data["sodO_BRIEF_5_HDCNTS"] = this.sodO_BRIEF_5_HDCNTS;
        data["others"] = this.others;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_BRIEF_5_ENTITY {
    sodO_BRIEF_5_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_BRIEF_5_TTDTH: boolean;
    sodO_BRIEF_5_DC: boolean;
    sodO_BRIEF_5_BBCKTT: boolean;
    sodO_BRIEF_5_BBMTTN: boolean;
    sodO_BRIEF_5_HDCNTS: boolean;
    others: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_CO_OWNER_ENTITY implements IREA_SODO_CO_OWNER_ENTITY {
    sodO_CO_OWNER_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_CO_OWNER_NAME!: string | undefined;
    notes!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_CO_OWNER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_CO_OWNER_ID = data["sodO_CO_OWNER_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_CO_OWNER_NAME = data["sodO_CO_OWNER_NAME"];
            this.notes = data["notes"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_CO_OWNER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_CO_OWNER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_CO_OWNER_ID"] = this.sodO_CO_OWNER_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_CO_OWNER_NAME"] = this.sodO_CO_OWNER_NAME;
        data["notes"] = this.notes;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_CO_OWNER_ENTITY {
    sodO_CO_OWNER_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_CO_OWNER_NAME: string | undefined;
    notes: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_COMPENSATION_ENTITY implements IREA_SODO_COMPENSATION_ENTITY {
    sodO_COMPENSATION_ID!: string | undefined;
    sodO_ID!: string | undefined;
    olD_SODO_ID!: string | undefined;
    sodO_LAND_PLOT_ID!: string | undefined;
    monneY_RECEIVER_ID!: string | undefined;
    sodO_COMPENSATION_AREA!: number;
    sodO_COMPENSATION_TRANSFER_MONEY!: number;
    sodO_COMPENSATION_MONEY!: number;
    sodO_COMPENSATION_REMAIN_AREA!: number;
    sodO_COMPENSATION_MONEY_DIFFERENCE!: number;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_COMPENSATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_COMPENSATION_ID = data["sodO_COMPENSATION_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.olD_SODO_ID = data["olD_SODO_ID"];
            this.sodO_LAND_PLOT_ID = data["sodO_LAND_PLOT_ID"];
            this.monneY_RECEIVER_ID = data["monneY_RECEIVER_ID"];
            this.sodO_COMPENSATION_AREA = data["sodO_COMPENSATION_AREA"];
            this.sodO_COMPENSATION_TRANSFER_MONEY = data["sodO_COMPENSATION_TRANSFER_MONEY"];
            this.sodO_COMPENSATION_MONEY = data["sodO_COMPENSATION_MONEY"];
            this.sodO_COMPENSATION_REMAIN_AREA = data["sodO_COMPENSATION_REMAIN_AREA"];
            this.sodO_COMPENSATION_MONEY_DIFFERENCE = data["sodO_COMPENSATION_MONEY_DIFFERENCE"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_COMPENSATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_COMPENSATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_COMPENSATION_ID"] = this.sodO_COMPENSATION_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["olD_SODO_ID"] = this.olD_SODO_ID;
        data["sodO_LAND_PLOT_ID"] = this.sodO_LAND_PLOT_ID;
        data["monneY_RECEIVER_ID"] = this.monneY_RECEIVER_ID;
        data["sodO_COMPENSATION_AREA"] = this.sodO_COMPENSATION_AREA;
        data["sodO_COMPENSATION_TRANSFER_MONEY"] = this.sodO_COMPENSATION_TRANSFER_MONEY;
        data["sodO_COMPENSATION_MONEY"] = this.sodO_COMPENSATION_MONEY;
        data["sodO_COMPENSATION_REMAIN_AREA"] = this.sodO_COMPENSATION_REMAIN_AREA;
        data["sodO_COMPENSATION_MONEY_DIFFERENCE"] = this.sodO_COMPENSATION_MONEY_DIFFERENCE;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_COMPENSATION_ENTITY {
    sodO_COMPENSATION_ID: string | undefined;
    sodO_ID: string | undefined;
    olD_SODO_ID: string | undefined;
    sodO_LAND_PLOT_ID: string | undefined;
    monneY_RECEIVER_ID: string | undefined;
    sodO_COMPENSATION_AREA: number;
    sodO_COMPENSATION_TRANSFER_MONEY: number;
    sodO_COMPENSATION_MONEY: number;
    sodO_COMPENSATION_REMAIN_AREA: number;
    sodO_COMPENSATION_MONEY_DIFFERENCE: number;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_CONTRACT_ENTITY implements IREA_SODO_CONTRACT_ENTITY {
    sodO_CONTRACT_ID!: string | undefined;
    sodO_ID!: string | undefined;
    partneR_ID!: string | undefined;
    sodO_CONTRACT_SIGN_DT!: moment.Moment | undefined;
    sodO_CONTRACT_CONTENT!: string | undefined;
    sodO_CONTRACT_VALUE!: number;
    sodO_CONTRACT_RELEASED_VALUE!: number;
    sodO_REMAIN_DEBT!: number;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_CONTRACT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_CONTRACT_ID = data["sodO_CONTRACT_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.partneR_ID = data["partneR_ID"];
            this.sodO_CONTRACT_SIGN_DT = data["sodO_CONTRACT_SIGN_DT"] ? moment(data["sodO_CONTRACT_SIGN_DT"].toString()) : <any>undefined;
            this.sodO_CONTRACT_CONTENT = data["sodO_CONTRACT_CONTENT"];
            this.sodO_CONTRACT_VALUE = data["sodO_CONTRACT_VALUE"];
            this.sodO_CONTRACT_RELEASED_VALUE = data["sodO_CONTRACT_RELEASED_VALUE"];
            this.sodO_REMAIN_DEBT = data["sodO_REMAIN_DEBT"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_CONTRACT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_CONTRACT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_CONTRACT_ID"] = this.sodO_CONTRACT_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["partneR_ID"] = this.partneR_ID;
        data["sodO_CONTRACT_SIGN_DT"] = this.sodO_CONTRACT_SIGN_DT ? this.sodO_CONTRACT_SIGN_DT.toISOString() : <any>undefined;
        data["sodO_CONTRACT_CONTENT"] = this.sodO_CONTRACT_CONTENT;
        data["sodO_CONTRACT_VALUE"] = this.sodO_CONTRACT_VALUE;
        data["sodO_CONTRACT_RELEASED_VALUE"] = this.sodO_CONTRACT_RELEASED_VALUE;
        data["sodO_REMAIN_DEBT"] = this.sodO_REMAIN_DEBT;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_CONTRACT_ENTITY {
    sodO_CONTRACT_ID: string | undefined;
    sodO_ID: string | undefined;
    partneR_ID: string | undefined;
    sodO_CONTRACT_SIGN_DT: moment.Moment | undefined;
    sodO_CONTRACT_CONTENT: string | undefined;
    sodO_CONTRACT_VALUE: number;
    sodO_CONTRACT_RELEASED_VALUE: number;
    sodO_REMAIN_DEBT: number;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_ENTITY implements IREA_SODO_ENTITY {
    sodO_PUBLISH_NUMBER!: string | undefined;
    projecT_ID!: string | undefined;
    owneR_INFO_OR_ID!: string | undefined;
    authorizeD_PERSON_ID!: string | undefined;
    areA_ID!: string | undefined;
    sodO_TRANSFER_STATUS!: string | undefined;
    sodO_SO_VAO_SO!: string | undefined;
    sodO_BACODE_SERI!: string | undefined;
    sodO_INSIDE_AREA!: number;
    sodO_OUTSIDE_AREA!: number;
    sodO_TYPE!: string | undefined;
    sodO_USE_TYPE!: string | undefined;
    sodO_AUTHORIZE_DT!: moment.Moment | undefined;
    sodO_ORIGIN_INFORMATION!: string | undefined;
    sodO_PROVIDE_DT!: moment.Moment | undefined;
    sodO_ADDRESS!: string | undefined;
    sodO_PHYSIC_STATUS!: string | undefined;
    sodO_USE_STATUS!: string | undefined;
    sodO_PROVIDE_LOCATION!: string | undefined;
    sodO_COMPENSATE_CONFIRMATION!: boolean;
    rejecT_REASON!: string | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    sodO_TYPE_NAME!: string | undefined;
    sodO_TRANSFER_STATUS_NAME!: string | undefined;
    sodO_USE_TYPE_NAME!: string | undefined;
    sodO_PHYSIC_STATUS_NAME!: string | undefined;
    sodO_USE_STATUS_NAME!: string | undefined;
    sodO_TOTAL_AREA!: number;
    cO_OWNER_LIST!: REA_SODO_CO_OWNER_ENTITY[] | undefined;
    paY_LIST!: REA_SODO_PAY_ENTITY[] | undefined;
    lanD_PLOT_LIST!: REA_SODO_LAND_PLOT_ENTITY[] | undefined;
    compensatioN_LIST!: REA_SODO_COMPENSATION_ENTITY[] | undefined;
    storE_LOCATION_LIST!: REA_SODO_STORE_LOCATION_ENTITY[] | undefined;
    advancE_PAYMENT_LIST!: REA_SODO_ADVANCE_PAYMENT_ENTITY[] | undefined;
    fileS_LIST!: REA_FILE_ENTITY[] | undefined;
    contract!: REA_SODO_CONTRACT_ENTITY;
    brieF_1!: REA_SODO_BRIEF_1_ENTITY;
    brieF_2!: REA_SODO_BRIEF_2_ENTITY;
    brieF_3!: REA_SODO_BRIEF_3_ENTITY;
    brieF_4!: REA_SODO_BRIEF_4_ENTITY;
    brieF_5!: REA_SODO_BRIEF_5_ENTITY;
    deleteD_CO_OWNER_ID_LIST!: string[] | undefined;
    deleteD_PAY_ID_LIST!: string[] | undefined;
    deleteD_LAND_PLOT_ID_LIST!: string[] | undefined;
    deleteD_COMPENSATION_ID_LIST!: string[] | undefined;
    deleteD_STORE_LOCATION_ID_LIST!: string[] | undefined;
    deleteD_ADVANCE_PAYMENT_ID_LIST!: string[] | undefined;
    deleteD_FILE_ID_LIST!: string[] | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IREA_SODO_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_PUBLISH_NUMBER = data["sodO_PUBLISH_NUMBER"];
            this.projecT_ID = data["projecT_ID"];
            this.owneR_INFO_OR_ID = data["owneR_INFO_OR_ID"];
            this.authorizeD_PERSON_ID = data["authorizeD_PERSON_ID"];
            this.areA_ID = data["areA_ID"];
            this.sodO_TRANSFER_STATUS = data["sodO_TRANSFER_STATUS"];
            this.sodO_SO_VAO_SO = data["sodO_SO_VAO_SO"];
            this.sodO_BACODE_SERI = data["sodO_BACODE_SERI"];
            this.sodO_INSIDE_AREA = data["sodO_INSIDE_AREA"];
            this.sodO_OUTSIDE_AREA = data["sodO_OUTSIDE_AREA"];
            this.sodO_TYPE = data["sodO_TYPE"];
            this.sodO_USE_TYPE = data["sodO_USE_TYPE"];
            this.sodO_AUTHORIZE_DT = data["sodO_AUTHORIZE_DT"] ? moment(data["sodO_AUTHORIZE_DT"].toString()) : <any>undefined;
            this.sodO_ORIGIN_INFORMATION = data["sodO_ORIGIN_INFORMATION"];
            this.sodO_PROVIDE_DT = data["sodO_PROVIDE_DT"] ? moment(data["sodO_PROVIDE_DT"].toString()) : <any>undefined;
            this.sodO_ADDRESS = data["sodO_ADDRESS"];
            this.sodO_PHYSIC_STATUS = data["sodO_PHYSIC_STATUS"];
            this.sodO_USE_STATUS = data["sodO_USE_STATUS"];
            this.sodO_PROVIDE_LOCATION = data["sodO_PROVIDE_LOCATION"];
            this.sodO_COMPENSATE_CONFIRMATION = data["sodO_COMPENSATE_CONFIRMATION"];
            this.rejecT_REASON = data["rejecT_REASON"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.sodO_TYPE_NAME = data["sodO_TYPE_NAME"];
            this.sodO_TRANSFER_STATUS_NAME = data["sodO_TRANSFER_STATUS_NAME"];
            this.sodO_USE_TYPE_NAME = data["sodO_USE_TYPE_NAME"];
            this.sodO_PHYSIC_STATUS_NAME = data["sodO_PHYSIC_STATUS_NAME"];
            this.sodO_USE_STATUS_NAME = data["sodO_USE_STATUS_NAME"];
            this.sodO_TOTAL_AREA = data["sodO_TOTAL_AREA"];
            if (data["cO_OWNER_LIST"] && data["cO_OWNER_LIST"].constructor === Array) {
                this.cO_OWNER_LIST = [] as any;
                for (let item of data["cO_OWNER_LIST"])
                    this.cO_OWNER_LIST!.push(REA_SODO_CO_OWNER_ENTITY.fromJS(item));
            }
            if (data["paY_LIST"] && data["paY_LIST"].constructor === Array) {
                this.paY_LIST = [] as any;
                for (let item of data["paY_LIST"])
                    this.paY_LIST!.push(REA_SODO_PAY_ENTITY.fromJS(item));
            }
            if (data["lanD_PLOT_LIST"] && data["lanD_PLOT_LIST"].constructor === Array) {
                this.lanD_PLOT_LIST = [] as any;
                for (let item of data["lanD_PLOT_LIST"])
                    this.lanD_PLOT_LIST!.push(REA_SODO_LAND_PLOT_ENTITY.fromJS(item));
            }
            if (data["compensatioN_LIST"] && data["compensatioN_LIST"].constructor === Array) {
                this.compensatioN_LIST = [] as any;
                for (let item of data["compensatioN_LIST"])
                    this.compensatioN_LIST!.push(REA_SODO_COMPENSATION_ENTITY.fromJS(item));
            }
            if (data["storE_LOCATION_LIST"] && data["storE_LOCATION_LIST"].constructor === Array) {
                this.storE_LOCATION_LIST = [] as any;
                for (let item of data["storE_LOCATION_LIST"])
                    this.storE_LOCATION_LIST!.push(REA_SODO_STORE_LOCATION_ENTITY.fromJS(item));
            }
            if (data["advancE_PAYMENT_LIST"] && data["advancE_PAYMENT_LIST"].constructor === Array) {
                this.advancE_PAYMENT_LIST = [] as any;
                for (let item of data["advancE_PAYMENT_LIST"])
                    this.advancE_PAYMENT_LIST!.push(REA_SODO_ADVANCE_PAYMENT_ENTITY.fromJS(item));
            }
            if (data["fileS_LIST"] && data["fileS_LIST"].constructor === Array) {
                this.fileS_LIST = [] as any;
                for (let item of data["fileS_LIST"])
                    this.fileS_LIST!.push(REA_FILE_ENTITY.fromJS(item));
            }
            this.contract = data["contract"] ? REA_SODO_CONTRACT_ENTITY.fromJS(data["contract"]) : <any>undefined;
            this.brieF_1 = data["brieF_1"] ? REA_SODO_BRIEF_1_ENTITY.fromJS(data["brieF_1"]) : <any>undefined;
            this.brieF_2 = data["brieF_2"] ? REA_SODO_BRIEF_2_ENTITY.fromJS(data["brieF_2"]) : <any>undefined;
            this.brieF_3 = data["brieF_3"] ? REA_SODO_BRIEF_3_ENTITY.fromJS(data["brieF_3"]) : <any>undefined;
            this.brieF_4 = data["brieF_4"] ? REA_SODO_BRIEF_4_ENTITY.fromJS(data["brieF_4"]) : <any>undefined;
            this.brieF_5 = data["brieF_5"] ? REA_SODO_BRIEF_5_ENTITY.fromJS(data["brieF_5"]) : <any>undefined;
            if (data["deleteD_CO_OWNER_ID_LIST"] && data["deleteD_CO_OWNER_ID_LIST"].constructor === Array) {
                this.deleteD_CO_OWNER_ID_LIST = [] as any;
                for (let item of data["deleteD_CO_OWNER_ID_LIST"])
                    this.deleteD_CO_OWNER_ID_LIST!.push(item);
            }
            if (data["deleteD_PAY_ID_LIST"] && data["deleteD_PAY_ID_LIST"].constructor === Array) {
                this.deleteD_PAY_ID_LIST = [] as any;
                for (let item of data["deleteD_PAY_ID_LIST"])
                    this.deleteD_PAY_ID_LIST!.push(item);
            }
            if (data["deleteD_LAND_PLOT_ID_LIST"] && data["deleteD_LAND_PLOT_ID_LIST"].constructor === Array) {
                this.deleteD_LAND_PLOT_ID_LIST = [] as any;
                for (let item of data["deleteD_LAND_PLOT_ID_LIST"])
                    this.deleteD_LAND_PLOT_ID_LIST!.push(item);
            }
            if (data["deleteD_COMPENSATION_ID_LIST"] && data["deleteD_COMPENSATION_ID_LIST"].constructor === Array) {
                this.deleteD_COMPENSATION_ID_LIST = [] as any;
                for (let item of data["deleteD_COMPENSATION_ID_LIST"])
                    this.deleteD_COMPENSATION_ID_LIST!.push(item);
            }
            if (data["deleteD_STORE_LOCATION_ID_LIST"] && data["deleteD_STORE_LOCATION_ID_LIST"].constructor === Array) {
                this.deleteD_STORE_LOCATION_ID_LIST = [] as any;
                for (let item of data["deleteD_STORE_LOCATION_ID_LIST"])
                    this.deleteD_STORE_LOCATION_ID_LIST!.push(item);
            }
            if (data["deleteD_ADVANCE_PAYMENT_ID_LIST"] && data["deleteD_ADVANCE_PAYMENT_ID_LIST"].constructor === Array) {
                this.deleteD_ADVANCE_PAYMENT_ID_LIST = [] as any;
                for (let item of data["deleteD_ADVANCE_PAYMENT_ID_LIST"])
                    this.deleteD_ADVANCE_PAYMENT_ID_LIST!.push(item);
            }
            if (data["deleteD_FILE_ID_LIST"] && data["deleteD_FILE_ID_LIST"].constructor === Array) {
                this.deleteD_FILE_ID_LIST = [] as any;
                for (let item of data["deleteD_FILE_ID_LIST"])
                    this.deleteD_FILE_ID_LIST!.push(item);
            }
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): REA_SODO_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_PUBLISH_NUMBER"] = this.sodO_PUBLISH_NUMBER;
        data["projecT_ID"] = this.projecT_ID;
        data["owneR_INFO_OR_ID"] = this.owneR_INFO_OR_ID;
        data["authorizeD_PERSON_ID"] = this.authorizeD_PERSON_ID;
        data["areA_ID"] = this.areA_ID;
        data["sodO_TRANSFER_STATUS"] = this.sodO_TRANSFER_STATUS;
        data["sodO_SO_VAO_SO"] = this.sodO_SO_VAO_SO;
        data["sodO_BACODE_SERI"] = this.sodO_BACODE_SERI;
        data["sodO_INSIDE_AREA"] = this.sodO_INSIDE_AREA;
        data["sodO_OUTSIDE_AREA"] = this.sodO_OUTSIDE_AREA;
        data["sodO_TYPE"] = this.sodO_TYPE;
        data["sodO_USE_TYPE"] = this.sodO_USE_TYPE;
        data["sodO_AUTHORIZE_DT"] = this.sodO_AUTHORIZE_DT ? this.sodO_AUTHORIZE_DT.toISOString() : <any>undefined;
        data["sodO_ORIGIN_INFORMATION"] = this.sodO_ORIGIN_INFORMATION;
        data["sodO_PROVIDE_DT"] = this.sodO_PROVIDE_DT ? this.sodO_PROVIDE_DT.toISOString() : <any>undefined;
        data["sodO_ADDRESS"] = this.sodO_ADDRESS;
        data["sodO_PHYSIC_STATUS"] = this.sodO_PHYSIC_STATUS;
        data["sodO_USE_STATUS"] = this.sodO_USE_STATUS;
        data["sodO_PROVIDE_LOCATION"] = this.sodO_PROVIDE_LOCATION;
        data["sodO_COMPENSATE_CONFIRMATION"] = this.sodO_COMPENSATE_CONFIRMATION;
        data["rejecT_REASON"] = this.rejecT_REASON;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["sodO_TYPE_NAME"] = this.sodO_TYPE_NAME;
        data["sodO_TRANSFER_STATUS_NAME"] = this.sodO_TRANSFER_STATUS_NAME;
        data["sodO_USE_TYPE_NAME"] = this.sodO_USE_TYPE_NAME;
        data["sodO_PHYSIC_STATUS_NAME"] = this.sodO_PHYSIC_STATUS_NAME;
        data["sodO_USE_STATUS_NAME"] = this.sodO_USE_STATUS_NAME;
        data["sodO_TOTAL_AREA"] = this.sodO_TOTAL_AREA;
        if (this.cO_OWNER_LIST && this.cO_OWNER_LIST.constructor === Array) {
            data["cO_OWNER_LIST"] = [];
            for (let item of this.cO_OWNER_LIST)
                data["cO_OWNER_LIST"].push(item.toJSON());
        }
        if (this.paY_LIST && this.paY_LIST.constructor === Array) {
            data["paY_LIST"] = [];
            for (let item of this.paY_LIST)
                data["paY_LIST"].push(item.toJSON());
        }
        if (this.lanD_PLOT_LIST && this.lanD_PLOT_LIST.constructor === Array) {
            data["lanD_PLOT_LIST"] = [];
            for (let item of this.lanD_PLOT_LIST)
                data["lanD_PLOT_LIST"].push(item.toJSON());
        }
        if (this.compensatioN_LIST && this.compensatioN_LIST.constructor === Array) {
            data["compensatioN_LIST"] = [];
            for (let item of this.compensatioN_LIST)
                data["compensatioN_LIST"].push(item.toJSON());
        }
        if (this.storE_LOCATION_LIST && this.storE_LOCATION_LIST.constructor === Array) {
            data["storE_LOCATION_LIST"] = [];
            for (let item of this.storE_LOCATION_LIST)
                data["storE_LOCATION_LIST"].push(item.toJSON());
        }
        if (this.advancE_PAYMENT_LIST && this.advancE_PAYMENT_LIST.constructor === Array) {
            data["advancE_PAYMENT_LIST"] = [];
            for (let item of this.advancE_PAYMENT_LIST)
                data["advancE_PAYMENT_LIST"].push(item.toJSON());
        }
        if (this.fileS_LIST && this.fileS_LIST.constructor === Array) {
            data["fileS_LIST"] = [];
            for (let item of this.fileS_LIST)
                data["fileS_LIST"].push(item.toJSON());
        }
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["brieF_1"] = this.brieF_1 ? this.brieF_1.toJSON() : <any>undefined;
        data["brieF_2"] = this.brieF_2 ? this.brieF_2.toJSON() : <any>undefined;
        data["brieF_3"] = this.brieF_3 ? this.brieF_3.toJSON() : <any>undefined;
        data["brieF_4"] = this.brieF_4 ? this.brieF_4.toJSON() : <any>undefined;
        data["brieF_5"] = this.brieF_5 ? this.brieF_5.toJSON() : <any>undefined;
        if (this.deleteD_CO_OWNER_ID_LIST && this.deleteD_CO_OWNER_ID_LIST.constructor === Array) {
            data["deleteD_CO_OWNER_ID_LIST"] = [];
            for (let item of this.deleteD_CO_OWNER_ID_LIST)
                data["deleteD_CO_OWNER_ID_LIST"].push(item);
        }
        if (this.deleteD_PAY_ID_LIST && this.deleteD_PAY_ID_LIST.constructor === Array) {
            data["deleteD_PAY_ID_LIST"] = [];
            for (let item of this.deleteD_PAY_ID_LIST)
                data["deleteD_PAY_ID_LIST"].push(item);
        }
        if (this.deleteD_LAND_PLOT_ID_LIST && this.deleteD_LAND_PLOT_ID_LIST.constructor === Array) {
            data["deleteD_LAND_PLOT_ID_LIST"] = [];
            for (let item of this.deleteD_LAND_PLOT_ID_LIST)
                data["deleteD_LAND_PLOT_ID_LIST"].push(item);
        }
        if (this.deleteD_COMPENSATION_ID_LIST && this.deleteD_COMPENSATION_ID_LIST.constructor === Array) {
            data["deleteD_COMPENSATION_ID_LIST"] = [];
            for (let item of this.deleteD_COMPENSATION_ID_LIST)
                data["deleteD_COMPENSATION_ID_LIST"].push(item);
        }
        if (this.deleteD_STORE_LOCATION_ID_LIST && this.deleteD_STORE_LOCATION_ID_LIST.constructor === Array) {
            data["deleteD_STORE_LOCATION_ID_LIST"] = [];
            for (let item of this.deleteD_STORE_LOCATION_ID_LIST)
                data["deleteD_STORE_LOCATION_ID_LIST"].push(item);
        }
        if (this.deleteD_ADVANCE_PAYMENT_ID_LIST && this.deleteD_ADVANCE_PAYMENT_ID_LIST.constructor === Array) {
            data["deleteD_ADVANCE_PAYMENT_ID_LIST"] = [];
            for (let item of this.deleteD_ADVANCE_PAYMENT_ID_LIST)
                data["deleteD_ADVANCE_PAYMENT_ID_LIST"].push(item);
        }
        if (this.deleteD_FILE_ID_LIST && this.deleteD_FILE_ID_LIST.constructor === Array) {
            data["deleteD_FILE_ID_LIST"] = [];
            for (let item of this.deleteD_FILE_ID_LIST)
                data["deleteD_FILE_ID_LIST"].push(item);
        }
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface IREA_SODO_ENTITY {
    sodO_PUBLISH_NUMBER: string | undefined;
    projecT_ID: string | undefined;
    owneR_INFO_OR_ID: string | undefined;
    authorizeD_PERSON_ID: string | undefined;
    areA_ID: string | undefined;
    sodO_TRANSFER_STATUS: string | undefined;
    sodO_SO_VAO_SO: string | undefined;
    sodO_BACODE_SERI: string | undefined;
    sodO_INSIDE_AREA: number;
    sodO_OUTSIDE_AREA: number;
    sodO_TYPE: string | undefined;
    sodO_USE_TYPE: string | undefined;
    sodO_AUTHORIZE_DT: moment.Moment | undefined;
    sodO_ORIGIN_INFORMATION: string | undefined;
    sodO_PROVIDE_DT: moment.Moment | undefined;
    sodO_ADDRESS: string | undefined;
    sodO_PHYSIC_STATUS: string | undefined;
    sodO_USE_STATUS: string | undefined;
    sodO_PROVIDE_LOCATION: string | undefined;
    sodO_COMPENSATE_CONFIRMATION: boolean;
    rejecT_REASON: string | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    sodO_TYPE_NAME: string | undefined;
    sodO_TRANSFER_STATUS_NAME: string | undefined;
    sodO_USE_TYPE_NAME: string | undefined;
    sodO_PHYSIC_STATUS_NAME: string | undefined;
    sodO_USE_STATUS_NAME: string | undefined;
    sodO_TOTAL_AREA: number;
    cO_OWNER_LIST: REA_SODO_CO_OWNER_ENTITY[] | undefined;
    paY_LIST: REA_SODO_PAY_ENTITY[] | undefined;
    lanD_PLOT_LIST: REA_SODO_LAND_PLOT_ENTITY[] | undefined;
    compensatioN_LIST: REA_SODO_COMPENSATION_ENTITY[] | undefined;
    storE_LOCATION_LIST: REA_SODO_STORE_LOCATION_ENTITY[] | undefined;
    advancE_PAYMENT_LIST: REA_SODO_ADVANCE_PAYMENT_ENTITY[] | undefined;
    fileS_LIST: REA_FILE_ENTITY[] | undefined;
    contract: REA_SODO_CONTRACT_ENTITY;
    brieF_1: REA_SODO_BRIEF_1_ENTITY;
    brieF_2: REA_SODO_BRIEF_2_ENTITY;
    brieF_3: REA_SODO_BRIEF_3_ENTITY;
    brieF_4: REA_SODO_BRIEF_4_ENTITY;
    brieF_5: REA_SODO_BRIEF_5_ENTITY;
    deleteD_CO_OWNER_ID_LIST: string[] | undefined;
    deleteD_PAY_ID_LIST: string[] | undefined;
    deleteD_LAND_PLOT_ID_LIST: string[] | undefined;
    deleteD_COMPENSATION_ID_LIST: string[] | undefined;
    deleteD_STORE_LOCATION_ID_LIST: string[] | undefined;
    deleteD_ADVANCE_PAYMENT_ID_LIST: string[] | undefined;
    deleteD_FILE_ID_LIST: string[] | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class REA_SODO_LAND_PLOT_ENTITY implements IREA_SODO_LAND_PLOT_ENTITY {
    lanD_PLOT_ID!: string | undefined;
    sodO_ID!: string | undefined;
    lanD_PLOT_TO_BAN_DO!: string | undefined;
    lanD_PLOT_NO!: string | undefined;
    lanD_PLOT_AREA!: string | undefined;
    lanD_PLOT_USE_PURPOSE!: string | undefined;
    lanD_PLOT_USE_DT!: moment.Moment | undefined;
    lanD_PLOT_USE_EXPIRATION_DT!: moment.Moment | undefined;
    notes!: string | undefined;
    lanD_PLOT_IS_INSIDE!: boolean;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_LAND_PLOT_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lanD_PLOT_ID = data["lanD_PLOT_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.lanD_PLOT_TO_BAN_DO = data["lanD_PLOT_TO_BAN_DO"];
            this.lanD_PLOT_NO = data["lanD_PLOT_NO"];
            this.lanD_PLOT_AREA = data["lanD_PLOT_AREA"];
            this.lanD_PLOT_USE_PURPOSE = data["lanD_PLOT_USE_PURPOSE"];
            this.lanD_PLOT_USE_DT = data["lanD_PLOT_USE_DT"] ? moment(data["lanD_PLOT_USE_DT"].toString()) : <any>undefined;
            this.lanD_PLOT_USE_EXPIRATION_DT = data["lanD_PLOT_USE_EXPIRATION_DT"] ? moment(data["lanD_PLOT_USE_EXPIRATION_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.lanD_PLOT_IS_INSIDE = data["lanD_PLOT_IS_INSIDE"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_LAND_PLOT_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_LAND_PLOT_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lanD_PLOT_ID"] = this.lanD_PLOT_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["lanD_PLOT_TO_BAN_DO"] = this.lanD_PLOT_TO_BAN_DO;
        data["lanD_PLOT_NO"] = this.lanD_PLOT_NO;
        data["lanD_PLOT_AREA"] = this.lanD_PLOT_AREA;
        data["lanD_PLOT_USE_PURPOSE"] = this.lanD_PLOT_USE_PURPOSE;
        data["lanD_PLOT_USE_DT"] = this.lanD_PLOT_USE_DT ? this.lanD_PLOT_USE_DT.toISOString() : <any>undefined;
        data["lanD_PLOT_USE_EXPIRATION_DT"] = this.lanD_PLOT_USE_EXPIRATION_DT ? this.lanD_PLOT_USE_EXPIRATION_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["lanD_PLOT_IS_INSIDE"] = this.lanD_PLOT_IS_INSIDE;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_LAND_PLOT_ENTITY {
    lanD_PLOT_ID: string | undefined;
    sodO_ID: string | undefined;
    lanD_PLOT_TO_BAN_DO: string | undefined;
    lanD_PLOT_NO: string | undefined;
    lanD_PLOT_AREA: string | undefined;
    lanD_PLOT_USE_PURPOSE: string | undefined;
    lanD_PLOT_USE_DT: moment.Moment | undefined;
    lanD_PLOT_USE_EXPIRATION_DT: moment.Moment | undefined;
    notes: string | undefined;
    lanD_PLOT_IS_INSIDE: boolean;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_PAY_ENTITY implements IREA_SODO_PAY_ENTITY {
    sodO_PAY_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_PAY_BATCH_NAME!: string | undefined;
    sodO_PAY_VALUE!: number;
    sodO_PAY_CONDITION!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_PAY_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_PAY_ID = data["sodO_PAY_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_PAY_BATCH_NAME = data["sodO_PAY_BATCH_NAME"];
            this.sodO_PAY_VALUE = data["sodO_PAY_VALUE"];
            this.sodO_PAY_CONDITION = data["sodO_PAY_CONDITION"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_PAY_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_PAY_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_PAY_ID"] = this.sodO_PAY_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_PAY_BATCH_NAME"] = this.sodO_PAY_BATCH_NAME;
        data["sodO_PAY_VALUE"] = this.sodO_PAY_VALUE;
        data["sodO_PAY_CONDITION"] = this.sodO_PAY_CONDITION;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_PAY_ENTITY {
    sodO_PAY_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_PAY_BATCH_NAME: string | undefined;
    sodO_PAY_VALUE: number;
    sodO_PAY_CONDITION: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_SODO_STORE_LOCATION_ENTITY implements IREA_SODO_STORE_LOCATION_ENTITY {
    sodO_STORE_LOCATION_ID!: string | undefined;
    sodO_ID!: string | undefined;
    sodO_STORE_LOCATION_TYPE!: string | undefined;
    sodO_STORE_LOCATION_DESCRIPTION!: string | undefined;
    sodO_STORE_LOCATION_CHANGE_DT!: moment.Moment | undefined;
    notes!: string | undefined;
    sodO_STORE_LOCATION_TYPE_NAME!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_SODO_STORE_LOCATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sodO_STORE_LOCATION_ID = data["sodO_STORE_LOCATION_ID"];
            this.sodO_ID = data["sodO_ID"];
            this.sodO_STORE_LOCATION_TYPE = data["sodO_STORE_LOCATION_TYPE"];
            this.sodO_STORE_LOCATION_DESCRIPTION = data["sodO_STORE_LOCATION_DESCRIPTION"];
            this.sodO_STORE_LOCATION_CHANGE_DT = data["sodO_STORE_LOCATION_CHANGE_DT"] ? moment(data["sodO_STORE_LOCATION_CHANGE_DT"].toString()) : <any>undefined;
            this.notes = data["notes"];
            this.sodO_STORE_LOCATION_TYPE_NAME = data["sodO_STORE_LOCATION_TYPE_NAME"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_SODO_STORE_LOCATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_SODO_STORE_LOCATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sodO_STORE_LOCATION_ID"] = this.sodO_STORE_LOCATION_ID;
        data["sodO_ID"] = this.sodO_ID;
        data["sodO_STORE_LOCATION_TYPE"] = this.sodO_STORE_LOCATION_TYPE;
        data["sodO_STORE_LOCATION_DESCRIPTION"] = this.sodO_STORE_LOCATION_DESCRIPTION;
        data["sodO_STORE_LOCATION_CHANGE_DT"] = this.sodO_STORE_LOCATION_CHANGE_DT ? this.sodO_STORE_LOCATION_CHANGE_DT.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["sodO_STORE_LOCATION_TYPE_NAME"] = this.sodO_STORE_LOCATION_TYPE_NAME;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_SODO_STORE_LOCATION_ENTITY {
    sodO_STORE_LOCATION_ID: string | undefined;
    sodO_ID: string | undefined;
    sodO_STORE_LOCATION_TYPE: string | undefined;
    sodO_STORE_LOCATION_DESCRIPTION: string | undefined;
    sodO_STORE_LOCATION_CHANGE_DT: moment.Moment | undefined;
    notes: string | undefined;
    sodO_STORE_LOCATION_TYPE_NAME: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_USE_REGISTRATION_ENTITY implements IREA_USE_REGISTRATION_ENTITY {
    usE_REGISTRATION_ID!: string | undefined;
    usE_REGISTRATION_TYPE!: string | undefined;
    usE_REGISTRION_REF_ID!: string | undefined;
    departmenT_ID!: string | undefined;
    registoR_ID!: string | undefined;
    usE_REGISTRATION_DT!: moment.Moment | undefined;
    usE_REGISTRATION_EXPIRE_DT!: moment.Moment | undefined;
    usE_REGISTRATION_USE_PUREPOSE!: string | undefined;
    notes!: string | undefined;
    usE_REGISTRATION_TYPE_NAME!: string | undefined;
    iS_CHANGED!: boolean;
    iS_NEW!: boolean;

    constructor(data?: IREA_USE_REGISTRATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usE_REGISTRATION_ID = data["usE_REGISTRATION_ID"];
            this.usE_REGISTRATION_TYPE = data["usE_REGISTRATION_TYPE"];
            this.usE_REGISTRION_REF_ID = data["usE_REGISTRION_REF_ID"];
            this.departmenT_ID = data["departmenT_ID"];
            this.registoR_ID = data["registoR_ID"];
            this.usE_REGISTRATION_DT = data["usE_REGISTRATION_DT"] ? moment(data["usE_REGISTRATION_DT"].toString()) : <any>undefined;
            this.usE_REGISTRATION_EXPIRE_DT = data["usE_REGISTRATION_EXPIRE_DT"] ? moment(data["usE_REGISTRATION_EXPIRE_DT"].toString()) : <any>undefined;
            this.usE_REGISTRATION_USE_PUREPOSE = data["usE_REGISTRATION_USE_PUREPOSE"];
            this.notes = data["notes"];
            this.usE_REGISTRATION_TYPE_NAME = data["usE_REGISTRATION_TYPE_NAME"];
            this.iS_CHANGED = data["iS_CHANGED"];
            this.iS_NEW = data["iS_NEW"];
        }
    }

    static fromJS(data: any): REA_USE_REGISTRATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_USE_REGISTRATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usE_REGISTRATION_ID"] = this.usE_REGISTRATION_ID;
        data["usE_REGISTRATION_TYPE"] = this.usE_REGISTRATION_TYPE;
        data["usE_REGISTRION_REF_ID"] = this.usE_REGISTRION_REF_ID;
        data["departmenT_ID"] = this.departmenT_ID;
        data["registoR_ID"] = this.registoR_ID;
        data["usE_REGISTRATION_DT"] = this.usE_REGISTRATION_DT ? this.usE_REGISTRATION_DT.toISOString() : <any>undefined;
        data["usE_REGISTRATION_EXPIRE_DT"] = this.usE_REGISTRATION_EXPIRE_DT ? this.usE_REGISTRATION_EXPIRE_DT.toISOString() : <any>undefined;
        data["usE_REGISTRATION_USE_PUREPOSE"] = this.usE_REGISTRATION_USE_PUREPOSE;
        data["notes"] = this.notes;
        data["usE_REGISTRATION_TYPE_NAME"] = this.usE_REGISTRATION_TYPE_NAME;
        data["iS_CHANGED"] = this.iS_CHANGED;
        data["iS_NEW"] = this.iS_NEW;
        return data; 
    }
}

export interface IREA_USE_REGISTRATION_ENTITY {
    usE_REGISTRATION_ID: string | undefined;
    usE_REGISTRATION_TYPE: string | undefined;
    usE_REGISTRION_REF_ID: string | undefined;
    departmenT_ID: string | undefined;
    registoR_ID: string | undefined;
    usE_REGISTRATION_DT: moment.Moment | undefined;
    usE_REGISTRATION_EXPIRE_DT: moment.Moment | undefined;
    usE_REGISTRATION_USE_PUREPOSE: string | undefined;
    notes: string | undefined;
    usE_REGISTRATION_TYPE_NAME: string | undefined;
    iS_CHANGED: boolean;
    iS_NEW: boolean;
}

export class REA_VALUATION_ENTITY implements IREA_VALUATION_ENTITY {
    valuatioN_ID!: string | undefined;
    valuatioN_PARTY_ID!: string | undefined;
    propertY_ID!: string | undefined;
    lanD_USE_FEE!: number;
    valuatioN_BEFORE_VALUE!: number | undefined;
    valuatioN_VALUE!: number;
    valuatioN_METHOD!: string | undefined;
    valuatioN_SALE_PLAN!: string | undefined;
    valuatioN_PRODUCT_TYPE!: string | undefined;
    valuatioN_UNIT_SALE_PRICE!: number;
    valuatioN_DT!: moment.Moment | undefined;

    constructor(data?: IREA_VALUATION_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.valuatioN_ID = data["valuatioN_ID"];
            this.valuatioN_PARTY_ID = data["valuatioN_PARTY_ID"];
            this.propertY_ID = data["propertY_ID"];
            this.lanD_USE_FEE = data["lanD_USE_FEE"];
            this.valuatioN_BEFORE_VALUE = data["valuatioN_BEFORE_VALUE"];
            this.valuatioN_VALUE = data["valuatioN_VALUE"];
            this.valuatioN_METHOD = data["valuatioN_METHOD"];
            this.valuatioN_SALE_PLAN = data["valuatioN_SALE_PLAN"];
            this.valuatioN_PRODUCT_TYPE = data["valuatioN_PRODUCT_TYPE"];
            this.valuatioN_UNIT_SALE_PRICE = data["valuatioN_UNIT_SALE_PRICE"];
            this.valuatioN_DT = data["valuatioN_DT"] ? moment(data["valuatioN_DT"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): REA_VALUATION_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new REA_VALUATION_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valuatioN_ID"] = this.valuatioN_ID;
        data["valuatioN_PARTY_ID"] = this.valuatioN_PARTY_ID;
        data["propertY_ID"] = this.propertY_ID;
        data["lanD_USE_FEE"] = this.lanD_USE_FEE;
        data["valuatioN_BEFORE_VALUE"] = this.valuatioN_BEFORE_VALUE;
        data["valuatioN_VALUE"] = this.valuatioN_VALUE;
        data["valuatioN_METHOD"] = this.valuatioN_METHOD;
        data["valuatioN_SALE_PLAN"] = this.valuatioN_SALE_PLAN;
        data["valuatioN_PRODUCT_TYPE"] = this.valuatioN_PRODUCT_TYPE;
        data["valuatioN_UNIT_SALE_PRICE"] = this.valuatioN_UNIT_SALE_PRICE;
        data["valuatioN_DT"] = this.valuatioN_DT ? this.valuatioN_DT.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IREA_VALUATION_ENTITY {
    valuatioN_ID: string | undefined;
    valuatioN_PARTY_ID: string | undefined;
    propertY_ID: string | undefined;
    lanD_USE_FEE: number;
    valuatioN_BEFORE_VALUE: number | undefined;
    valuatioN_VALUE: number;
    valuatioN_METHOD: string | undefined;
    valuatioN_SALE_PLAN: string | undefined;
    valuatioN_PRODUCT_TYPE: string | undefined;
    valuatioN_UNIT_SALE_PRICE: number;
    valuatioN_DT: moment.Moment | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: moment.Moment;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [] as any;
                for (let item of data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class ReportColumn implements IReportColumn {
    colName!: string | undefined;
    keyName!: string | undefined;

    constructor(data?: IReportColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.colName = data["colName"];
            this.keyName = data["keyName"];
        }
    }

    static fromJS(data: any): ReportColumn {
        data = typeof data === 'object' ? data : {};
        let result = new ReportColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colName"] = this.colName;
        data["keyName"] = this.keyName;
        return data; 
    }
}

export interface IReportColumn {
    colName: string | undefined;
    keyName: string | undefined;
}

export class ReportHtmlInfo implements IReportHtmlInfo {
    htmlString!: string | undefined;
    typeExport!: string | undefined;
    fileName!: string | undefined;
    pageInfo!: string | undefined;

    constructor(data?: IReportHtmlInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.htmlString = data["htmlString"];
            this.typeExport = data["typeExport"];
            this.fileName = data["fileName"];
            this.pageInfo = data["pageInfo"];
        }
    }

    static fromJS(data: any): ReportHtmlInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ReportHtmlInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["htmlString"] = this.htmlString;
        data["typeExport"] = this.typeExport;
        data["fileName"] = this.fileName;
        data["pageInfo"] = this.pageInfo;
        return data; 
    }
}

export interface IReportHtmlInfo {
    htmlString: string | undefined;
    typeExport: string | undefined;
    fileName: string | undefined;
    pageInfo: string | undefined;
}

export class ReportInfo implements IReportInfo {
    storeName!: string | undefined;
    typeExport!: string | undefined;
    pathName!: string | undefined;
    fileName!: string | undefined;
    processMerge!: boolean | undefined;
    parameters!: ReportParameter[] | undefined;
    values!: ReportParameter[] | undefined;

    constructor(data?: IReportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storeName = data["storeName"];
            this.typeExport = data["typeExport"];
            this.pathName = data["pathName"];
            this.fileName = data["fileName"];
            this.processMerge = data["processMerge"];
            if (data["parameters"] && data["parameters"].constructor === Array) {
                this.parameters = [] as any;
                for (let item of data["parameters"])
                    this.parameters!.push(ReportParameter.fromJS(item));
            }
            if (data["values"] && data["values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["values"])
                    this.values!.push(ReportParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ReportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeName"] = this.storeName;
        data["typeExport"] = this.typeExport;
        data["pathName"] = this.pathName;
        data["fileName"] = this.fileName;
        data["processMerge"] = this.processMerge;
        if (this.parameters && this.parameters.constructor === Array) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        if (this.values && this.values.constructor === Array) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReportInfo {
    storeName: string | undefined;
    typeExport: string | undefined;
    pathName: string | undefined;
    fileName: string | undefined;
    processMerge: boolean | undefined;
    parameters: ReportParameter[] | undefined;
    values: ReportParameter[] | undefined;
}

export class ReportParameter implements IReportParameter {
    name!: string | undefined;
    value!: any | undefined;

    constructor(data?: IReportParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): ReportParameter {
        data = typeof data === 'object' ? data : {};
        let result = new ReportParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface IReportParameter {
    name: string | undefined;
    value: any | undefined;
}

export class ReportRow implements IReportRow {
    cells!: any[] | undefined;

    constructor(data?: IReportRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["cells"] && data["cells"].constructor === Array) {
                this.cells = [] as any;
                for (let item of data["cells"])
                    this.cells!.push(item);
            }
        }
    }

    static fromJS(data: any): ReportRow {
        data = typeof data === 'object' ? data : {};
        let result = new ReportRow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.cells && this.cells.constructor === Array) {
            data["cells"] = [];
            for (let item of this.cells)
                data["cells"].push(item);
        }
        return data; 
    }
}

export interface IReportRow {
    cells: any[] | undefined;
}

export class ReportTable implements IReportTable {
    tableName!: string | undefined;
    columns!: ReportColumn[] | undefined;
    rows!: ReportRow[] | undefined;

    constructor(data?: IReportTable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tableName = data["tableName"];
            if (data["columns"] && data["columns"].constructor === Array) {
                this.columns = [] as any;
                for (let item of data["columns"])
                    this.columns!.push(ReportColumn.fromJS(item));
            }
            if (data["rows"] && data["rows"].constructor === Array) {
                this.rows = [] as any;
                for (let item of data["rows"])
                    this.rows!.push(ReportRow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportTable {
        data = typeof data === 'object' ? data : {};
        let result = new ReportTable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tableName"] = this.tableName;
        if (this.columns && this.columns.constructor === Array) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (this.rows && this.rows.constructor === Array) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReportTable {
    tableName: string | undefined;
    columns: ReportColumn[] | undefined;
    rows: ReportRow[] | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: moment.Moment;
    lastModificationTime!: moment.Moment;
    creatorUser!: string | undefined;
    lastModifierUser!: string | undefined;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.creatorUser = data["creatorUser"];
            this.lastModifierUser = data["lastModifierUser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser;
        data["lastModifierUser"] = this.lastModifierUser;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    lastModificationTime: moment.Moment;
    creatorUser: string | undefined;
    lastModifierUser: string | undefined;
    id: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export enum SalesSummaryDatePeriod {
    Daily = 1, 
    Weekly = 2, 
    Monthly = 3, 
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class SettingDto implements ISettingDto {
    defaultRecordsCountPerPage!: number;
    resizableColumns!: boolean;
    isResponsive!: boolean;
    predefinedRecordsCountPerPage!: string | undefined;

    constructor(data?: ISettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultRecordsCountPerPage = data["defaultRecordsCountPerPage"];
            this.resizableColumns = data["resizableColumns"];
            this.isResponsive = data["isResponsive"];
            this.predefinedRecordsCountPerPage = data["predefinedRecordsCountPerPage"];
        }
    }

    static fromJS(data: any): SettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultRecordsCountPerPage"] = this.defaultRecordsCountPerPage;
        data["resizableColumns"] = this.resizableColumns;
        data["isResponsive"] = this.isResponsive;
        data["predefinedRecordsCountPerPage"] = this.predefinedRecordsCountPerPage;
        return data; 
    }
}

export interface ISettingDto {
    defaultRecordsCountPerPage: number;
    resizableColumns: boolean;
    isResponsive: boolean;
    predefinedRecordsCountPerPage: string | undefined;
}

export enum SettingScopes {
    Application = 1, 
    Tenant = 2, 
    User = 4, 
    All = 7, 
}

export class SftpSettingEditDto implements ISftpSettingEditDto {
    sftpurl!: string | undefined;
    sftpUserName!: string | undefined;
    sftpPassword!: string | undefined;
    sftpTransferMode!: string | undefined;
    sftpPortNumber!: string | undefined;
    sftpsFilePath!: string | undefined;
    sftpProtocolType!: string | undefined;
    sftP2URL!: string | undefined;
    sftP2UserName!: string | undefined;
    sftP2Password!: string | undefined;
    sftP2TransferMode!: string | undefined;
    sftP2PortNumber!: string | undefined;
    sftP2SFilePath!: string | undefined;
    sftP2ProtocolType!: string | undefined;

    constructor(data?: ISftpSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sftpurl = data["sftpurl"];
            this.sftpUserName = data["sftpUserName"];
            this.sftpPassword = data["sftpPassword"];
            this.sftpTransferMode = data["sftpTransferMode"];
            this.sftpPortNumber = data["sftpPortNumber"];
            this.sftpsFilePath = data["sftpsFilePath"];
            this.sftpProtocolType = data["sftpProtocolType"];
            this.sftP2URL = data["sftP2URL"];
            this.sftP2UserName = data["sftP2UserName"];
            this.sftP2Password = data["sftP2Password"];
            this.sftP2TransferMode = data["sftP2TransferMode"];
            this.sftP2PortNumber = data["sftP2PortNumber"];
            this.sftP2SFilePath = data["sftP2SFilePath"];
            this.sftP2ProtocolType = data["sftP2ProtocolType"];
        }
    }

    static fromJS(data: any): SftpSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SftpSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sftpurl"] = this.sftpurl;
        data["sftpUserName"] = this.sftpUserName;
        data["sftpPassword"] = this.sftpPassword;
        data["sftpTransferMode"] = this.sftpTransferMode;
        data["sftpPortNumber"] = this.sftpPortNumber;
        data["sftpsFilePath"] = this.sftpsFilePath;
        data["sftpProtocolType"] = this.sftpProtocolType;
        data["sftP2URL"] = this.sftP2URL;
        data["sftP2UserName"] = this.sftP2UserName;
        data["sftP2Password"] = this.sftP2Password;
        data["sftP2TransferMode"] = this.sftP2TransferMode;
        data["sftP2PortNumber"] = this.sftP2PortNumber;
        data["sftP2SFilePath"] = this.sftP2SFilePath;
        data["sftP2ProtocolType"] = this.sftP2ProtocolType;
        return data; 
    }
}

export interface ISftpSettingEditDto {
    sftpurl: string | undefined;
    sftpUserName: string | undefined;
    sftpPassword: string | undefined;
    sftpTransferMode: string | undefined;
    sftpPortNumber: string | undefined;
    sftpsFilePath: string | undefined;
    sftpProtocolType: string | undefined;
    sftP2URL: string | undefined;
    sftP2UserName: string | undefined;
    sftP2Password: string | undefined;
    sftP2TransferMode: string | undefined;
    sftP2PortNumber: string | undefined;
    sftP2SFilePath: string | undefined;
    sftP2ProtocolType: string | undefined;
}

export class Stream implements IStream {
    canRead!: boolean;
    canSeek!: boolean;
    canTimeout!: boolean;
    canWrite!: boolean;
    length!: number;
    position!: number;
    readTimeout!: number;
    writeTimeout!: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canRead = data["canRead"];
            this.canSeek = data["canSeek"];
            this.canTimeout = data["canTimeout"];
            this.canWrite = data["canWrite"];
            this.length = data["length"];
            this.position = data["position"];
            this.readTimeout = data["readTimeout"];
            this.writeTimeout = data["writeTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canRead"] = this.canRead;
        data["canSeek"] = this.canSeek;
        data["canTimeout"] = this.canTimeout;
        data["canWrite"] = this.canWrite;
        data["length"] = this.length;
        data["position"] = this.position;
        data["readTimeout"] = this.readTimeout;
        data["writeTimeout"] = this.writeTimeout;
        return data; 
    }
}

export interface IStream {
    canRead: boolean;
    canSeek: boolean;
    canTimeout: boolean;
    canWrite: boolean;
    length: number;
    position: number;
    readTimeout: number;
    writeTimeout: number;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId!: number;
    stripeToken!: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId!: number;
    stripeToken!: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId!: number;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number;
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1, 
    Stripe = 2, 
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1, 
    Paid = 2, 
    Failed = 3, 
    Cancelled = 4, 
    Completed = 5, 
}

export enum SubscriptionPaymentType {
    Manual = 0, 
    RecurringAutomatic = 1, 
    RecurringManual = 2, 
}

export enum SubscriptionStartType {
    Free = 1, 
    Trial = 2, 
    Paid = 3, 
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class SYS_PARAMETERS_ENTITY implements ISYS_PARAMETERS_ENTITY {
    id!: number | undefined;
    paraKey!: string | undefined;
    paraValue!: string | undefined;
    dataType!: string | undefined;
    description!: string | undefined;
    recorD_STATUS!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    autH_STATUS!: string | undefined;
    checkeR_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ISYS_PARAMETERS_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.paraKey = data["paraKey"];
            this.paraValue = data["paraValue"];
            this.dataType = data["dataType"];
            this.description = data["description"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.autH_STATUS = data["autH_STATUS"];
            this.checkeR_ID = data["checkeR_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): SYS_PARAMETERS_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new SYS_PARAMETERS_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["paraKey"] = this.paraKey;
        data["paraValue"] = this.paraValue;
        data["dataType"] = this.dataType;
        data["description"] = this.description;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["autH_STATUS"] = this.autH_STATUS;
        data["checkeR_ID"] = this.checkeR_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ISYS_PARAMETERS_ENTITY {
    id: number | undefined;
    paraKey: string | undefined;
    paraValue: string | undefined;
    dataType: string | undefined;
    description: string | undefined;
    recorD_STATUS: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    autH_STATUS: string | undefined;
    checkeR_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export enum TenantAvailabilityState {
    Available = 1, 
    InActive = 2, 
    NotFound = 3, 
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: moment.Moment;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    creationTime!: moment.Moment;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: moment.Moment;
    id!: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    id: string;
}

export class TenantNotificationInfo implements ITenantNotificationInfo {
    tenantId!: number | undefined;
    notificationName!: string;
    data!: string | undefined;
    dataTypeName!: string | undefined;
    entityTypeName!: string | undefined;
    entityTypeAssemblyQualifiedName!: string | undefined;
    entityId!: string | undefined;
    severity!: NotificationSeverity;
    creationTime!: moment.Moment;
    creatorUserId!: number | undefined;
    id!: string;

    constructor(data?: ITenantNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"];
            this.dataTypeName = data["dataTypeName"];
            this.entityTypeName = data["entityTypeName"];
            this.entityTypeAssemblyQualifiedName = data["entityTypeAssemblyQualifiedName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data;
        data["dataTypeName"] = this.dataTypeName;
        data["entityTypeName"] = this.entityTypeName;
        data["entityTypeAssemblyQualifiedName"] = this.entityTypeAssemblyQualifiedName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotificationInfo {
    tenantId: number | undefined;
    notificationName: string;
    data: string | undefined;
    dataTypeName: string | undefined;
    entityTypeName: string | undefined;
    entityTypeAssemblyQualifiedName: string | undefined;
    entityId: string | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: string;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean;
    mobileFixedHeader!: boolean;
    headerSkin!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    headerSkin: string | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;
    contentSkin!: string | undefined;
    themeColor!: string | undefined;
    fixedBody!: boolean;
    mobileFixedBody!: boolean;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.themeColor = data["themeColor"];
            this.fixedBody = data["fixedBody"];
            this.mobileFixedBody = data["mobileFixedBody"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["themeColor"] = this.themeColor;
        data["fixedBody"] = this.fixedBody;
        data["mobileFixedBody"] = this.mobileFixedBody;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    themeColor: string | undefined;
    fixedBody: boolean;
    mobileFixedBody: boolean;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    allowAsideHiding!: boolean;
    defaultHiddenAside!: boolean;
    submenuToggle!: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    allowAsideHiding: boolean;
    defaultHiddenAside: boolean;
    submenuToggle: string | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
}

export class TL_MENU_ENTITY implements ITL_MENU_ENTITY {
    menU_ID!: number | undefined;
    menU_NAME!: string | undefined;
    menU_NAME_EL!: string | undefined;
    menU_PARENT!: string | undefined;
    menU_LINK!: string | undefined;
    menU_ORDER!: number | undefined;
    autH_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    checkeR_ID!: string | undefined;
    datE_APPROVE!: moment.Moment | undefined;
    isapprove!: string | undefined;
    isapprovE_FUNC!: string | undefined;
    menU_PERMISSION!: string | undefined;
    menU_ICON!: string | undefined;
    recorD_STATUS!: string | undefined;
    recorD_STATUS_NAME!: string | undefined;
    autH_STATUS_NAME!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    approvE_DT!: moment.Moment | undefined;
    totalCount!: number | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ITL_MENU_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menU_ID = data["menU_ID"];
            this.menU_NAME = data["menU_NAME"];
            this.menU_NAME_EL = data["menU_NAME_EL"];
            this.menU_PARENT = data["menU_PARENT"];
            this.menU_LINK = data["menU_LINK"];
            this.menU_ORDER = data["menU_ORDER"];
            this.autH_STATUS = data["autH_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.checkeR_ID = data["checkeR_ID"];
            this.datE_APPROVE = data["datE_APPROVE"] ? moment(data["datE_APPROVE"].toString()) : <any>undefined;
            this.isapprove = data["isapprove"];
            this.isapprovE_FUNC = data["isapprovE_FUNC"];
            this.menU_PERMISSION = data["menU_PERMISSION"];
            this.menU_ICON = data["menU_ICON"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.recorD_STATUS_NAME = data["recorD_STATUS_NAME"];
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.totalCount = data["totalCount"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): TL_MENU_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new TL_MENU_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menU_ID"] = this.menU_ID;
        data["menU_NAME"] = this.menU_NAME;
        data["menU_NAME_EL"] = this.menU_NAME_EL;
        data["menU_PARENT"] = this.menU_PARENT;
        data["menU_LINK"] = this.menU_LINK;
        data["menU_ORDER"] = this.menU_ORDER;
        data["autH_STATUS"] = this.autH_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["checkeR_ID"] = this.checkeR_ID;
        data["datE_APPROVE"] = this.datE_APPROVE ? this.datE_APPROVE.toISOString() : <any>undefined;
        data["isapprove"] = this.isapprove;
        data["isapprovE_FUNC"] = this.isapprovE_FUNC;
        data["menU_PERMISSION"] = this.menU_PERMISSION;
        data["menU_ICON"] = this.menU_ICON;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["recorD_STATUS_NAME"] = this.recorD_STATUS_NAME;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ITL_MENU_ENTITY {
    menU_ID: number | undefined;
    menU_NAME: string | undefined;
    menU_NAME_EL: string | undefined;
    menU_PARENT: string | undefined;
    menU_LINK: string | undefined;
    menU_ORDER: number | undefined;
    autH_STATUS: string | undefined;
    makeR_ID: string | undefined;
    checkeR_ID: string | undefined;
    datE_APPROVE: moment.Moment | undefined;
    isapprove: string | undefined;
    isapprovE_FUNC: string | undefined;
    menU_PERMISSION: string | undefined;
    menU_ICON: string | undefined;
    recorD_STATUS: string | undefined;
    recorD_STATUS_NAME: string | undefined;
    autH_STATUS_NAME: string | undefined;
    creatE_DT: moment.Moment | undefined;
    approvE_DT: moment.Moment | undefined;
    totalCount: number | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class TL_USER_ENTITY implements ITL_USER_ENTITY {
    tlid!: string | undefined;
    tlnanme!: string | undefined;
    password!: string | undefined;
    tlFullName!: string | undefined;
    tlsubbrid!: string | undefined;
    brancH_ID!: string | undefined;
    brancH_NAME!: string | undefined;
    brancH_TYPE!: string | undefined;
    rolE_ID!: string | undefined;
    roleName!: string | undefined;
    email!: string | undefined;
    level!: string | undefined;
    address!: string | undefined;
    phone!: string | undefined;
    autH_STATUS!: string | undefined;
    markeR_ID!: string | undefined;
    autH_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    isapprove!: string | undefined;
    birthday!: moment.Moment | undefined;
    isfirsttime!: string | undefined;
    secuR_CODE!: string | undefined;
    accessFailedCount!: number;
    authenticationSource!: string | undefined;
    concurrencyStamp!: string | undefined;
    creatorUserId!: number | undefined;
    deleterUserId!: number | undefined;
    emailAddress!: string | undefined;
    emailConfirmationCode!: string | undefined;
    isActive!: boolean;
    isDeleted!: boolean;
    isEmailConfirmed!: boolean;
    isLockoutEnabled!: boolean;
    isPhoneNumberConfirmed!: boolean;
    isTwoFactorEnabled!: boolean;
    lastModifierUserId!: number | undefined;
    lockoutEndDateUtc!: moment.Moment | undefined;
    name!: string | undefined;
    normalizedEmailAddress!: string | undefined;
    normalizedUserName!: string | undefined;
    passwordResetCode!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    securityStamp!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    surname!: string | undefined;
    tenantId!: number | undefined;
    signInToken!: string | undefined;
    signInTokenExpireTimeUtc!: moment.Moment | undefined;
    googleAuthenticatorKey!: string | undefined;
    sendActivationEmail!: boolean;
    id!: number;
    deP_ID!: string | undefined;
    creationTime!: moment.Moment;
    autH_STATUS_NAME!: string | undefined;
    brancH_CODE!: string | undefined;
    khU_VUC!: string | undefined;
    chI_NHANH!: string | undefined;
    pgd!: string | undefined;
    taX_NO!: string | undefined;
    assignedRoleNames!: string[] | undefined;
    setRandomPassword!: boolean | undefined;
    passwordRepeat!: string | undefined;
    totalCount!: number | undefined;
    recorD_STATUS!: string | undefined;
    makeR_ID!: string | undefined;
    creatE_DT!: moment.Moment | undefined;
    checkeR_ID!: string | undefined;
    roles!: string | undefined;
    deP_NAME!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ITL_USER_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tlid = data["tlid"];
            this.tlnanme = data["tlnanme"];
            this.password = data["password"];
            this.tlFullName = data["tlFullName"];
            this.tlsubbrid = data["tlsubbrid"];
            this.brancH_ID = data["brancH_ID"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.rolE_ID = data["rolE_ID"];
            this.roleName = data["roleName"];
            this.email = data["email"];
            this.level = data["level"];
            this.address = data["address"];
            this.phone = data["phone"];
            this.autH_STATUS = data["autH_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_ID = data["autH_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.isapprove = data["isapprove"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.isfirsttime = data["isfirsttime"];
            this.secuR_CODE = data["secuR_CODE"];
            this.accessFailedCount = data["accessFailedCount"];
            this.authenticationSource = data["authenticationSource"];
            this.concurrencyStamp = data["concurrencyStamp"];
            this.creatorUserId = data["creatorUserId"];
            this.deleterUserId = data["deleterUserId"];
            this.emailAddress = data["emailAddress"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.lastModifierUserId = data["lastModifierUserId"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.name = data["name"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.normalizedUserName = data["normalizedUserName"];
            this.passwordResetCode = data["passwordResetCode"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.securityStamp = data["securityStamp"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.surname = data["surname"];
            this.tenantId = data["tenantId"];
            this.signInToken = data["signInToken"];
            this.signInTokenExpireTimeUtc = data["signInTokenExpireTimeUtc"] ? moment(data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.googleAuthenticatorKey = data["googleAuthenticatorKey"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.id = data["id"];
            this.deP_ID = data["deP_ID"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.autH_STATUS_NAME = data["autH_STATUS_NAME"];
            this.brancH_CODE = data["brancH_CODE"];
            this.khU_VUC = data["khU_VUC"];
            this.chI_NHANH = data["chI_NHANH"];
            this.pgd = data["pgd"];
            this.taX_NO = data["taX_NO"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.setRandomPassword = data["setRandomPassword"];
            this.passwordRepeat = data["passwordRepeat"];
            this.totalCount = data["totalCount"];
            this.recorD_STATUS = data["recorD_STATUS"];
            this.makeR_ID = data["makeR_ID"];
            this.creatE_DT = data["creatE_DT"] ? moment(data["creatE_DT"].toString()) : <any>undefined;
            this.checkeR_ID = data["checkeR_ID"];
            this.roles = data["roles"];
            this.deP_NAME = data["deP_NAME"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): TL_USER_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new TL_USER_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlid"] = this.tlid;
        data["tlnanme"] = this.tlnanme;
        data["password"] = this.password;
        data["tlFullName"] = this.tlFullName;
        data["tlsubbrid"] = this.tlsubbrid;
        data["brancH_ID"] = this.brancH_ID;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["rolE_ID"] = this.rolE_ID;
        data["roleName"] = this.roleName;
        data["email"] = this.email;
        data["level"] = this.level;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["autH_STATUS"] = this.autH_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_ID"] = this.autH_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["isapprove"] = this.isapprove;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["isfirsttime"] = this.isfirsttime;
        data["secuR_CODE"] = this.secuR_CODE;
        data["accessFailedCount"] = this.accessFailedCount;
        data["authenticationSource"] = this.authenticationSource;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["creatorUserId"] = this.creatorUserId;
        data["deleterUserId"] = this.deleterUserId;
        data["emailAddress"] = this.emailAddress;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["normalizedUserName"] = this.normalizedUserName;
        data["passwordResetCode"] = this.passwordResetCode;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["securityStamp"] = this.securityStamp;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["surname"] = this.surname;
        data["tenantId"] = this.tenantId;
        data["signInToken"] = this.signInToken;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["id"] = this.id;
        data["deP_ID"] = this.deP_ID;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["autH_STATUS_NAME"] = this.autH_STATUS_NAME;
        data["brancH_CODE"] = this.brancH_CODE;
        data["khU_VUC"] = this.khU_VUC;
        data["chI_NHANH"] = this.chI_NHANH;
        data["pgd"] = this.pgd;
        data["taX_NO"] = this.taX_NO;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["setRandomPassword"] = this.setRandomPassword;
        data["passwordRepeat"] = this.passwordRepeat;
        data["totalCount"] = this.totalCount;
        data["recorD_STATUS"] = this.recorD_STATUS;
        data["makeR_ID"] = this.makeR_ID;
        data["creatE_DT"] = this.creatE_DT ? this.creatE_DT.toISOString() : <any>undefined;
        data["checkeR_ID"] = this.checkeR_ID;
        data["roles"] = this.roles;
        data["deP_NAME"] = this.deP_NAME;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ITL_USER_ENTITY {
    tlid: string | undefined;
    tlnanme: string | undefined;
    password: string | undefined;
    tlFullName: string | undefined;
    tlsubbrid: string | undefined;
    brancH_ID: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    rolE_ID: string | undefined;
    roleName: string | undefined;
    email: string | undefined;
    level: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    autH_STATUS: string | undefined;
    markeR_ID: string | undefined;
    autH_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isapprove: string | undefined;
    birthday: moment.Moment | undefined;
    isfirsttime: string | undefined;
    secuR_CODE: string | undefined;
    accessFailedCount: number;
    authenticationSource: string | undefined;
    concurrencyStamp: string | undefined;
    creatorUserId: number | undefined;
    deleterUserId: number | undefined;
    emailAddress: string | undefined;
    emailConfirmationCode: string | undefined;
    isActive: boolean;
    isDeleted: boolean;
    isEmailConfirmed: boolean;
    isLockoutEnabled: boolean;
    isPhoneNumberConfirmed: boolean;
    isTwoFactorEnabled: boolean;
    lastModifierUserId: number | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    name: string | undefined;
    normalizedEmailAddress: string | undefined;
    normalizedUserName: string | undefined;
    passwordResetCode: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    securityStamp: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    surname: string | undefined;
    tenantId: number | undefined;
    signInToken: string | undefined;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    googleAuthenticatorKey: string | undefined;
    sendActivationEmail: boolean;
    id: number;
    deP_ID: string | undefined;
    creationTime: moment.Moment;
    autH_STATUS_NAME: string | undefined;
    brancH_CODE: string | undefined;
    khU_VUC: string | undefined;
    chI_NHANH: string | undefined;
    pgd: string | undefined;
    taX_NO: string | undefined;
    assignedRoleNames: string[] | undefined;
    setRandomPassword: boolean | undefined;
    passwordRepeat: string | undefined;
    totalCount: number | undefined;
    recorD_STATUS: string | undefined;
    makeR_ID: string | undefined;
    creatE_DT: moment.Moment | undefined;
    checkeR_ID: string | undefined;
    roles: string | undefined;
    deP_NAME: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class TL_USER_SearchResult implements ITL_USER_SearchResult {
    tlnanme!: string | undefined;
    approvE_DT!: moment.Moment;
    tlFullName!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    address!: string | undefined;
    result!: string | undefined;

    constructor(data?: ITL_USER_SearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tlnanme = data["tlnanme"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.tlFullName = data["tlFullName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.address = data["address"];
            this.result = data["result"];
        }
    }

    static fromJS(data: any): TL_USER_SearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TL_USER_SearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlnanme"] = this.tlnanme;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["tlFullName"] = this.tlFullName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["result"] = this.result;
        return data; 
    }
}

export interface ITL_USER_SearchResult {
    tlnanme: string | undefined;
    approvE_DT: moment.Moment;
    tlFullName: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    result: string | undefined;
}

export class TLUSER_GETBY_BRANCHID_ENTITY implements ITLUSER_GETBY_BRANCHID_ENTITY {
    tlid!: string | undefined;
    tlnanme!: string | undefined;
    password!: string | undefined;
    tlFullName!: string | undefined;
    tlsubbrid!: string | undefined;
    brancH_NAME!: string | undefined;
    brancH_TYPE!: string | undefined;
    roleName!: string | undefined;
    emailAddress!: string | undefined;
    roles!: string | undefined;
    rolE_ID!: number | undefined;
    email!: string | undefined;
    address!: string | undefined;
    phone!: string | undefined;
    autH_STATUS!: string | undefined;
    markeR_ID!: string | undefined;
    autH_ID!: string | undefined;
    approvE_DT!: moment.Moment | undefined;
    isapprove!: string | undefined;
    birthday!: moment.Moment | undefined;
    isfirsttime!: string | undefined;
    secuR_CODE!: string | undefined;
    totalCount!: number | undefined;
    rolE_ID_STRING!: string | undefined;
    top!: number | undefined;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: ITLUSER_GETBY_BRANCHID_ENTITY) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tlid = data["tlid"];
            this.tlnanme = data["tlnanme"];
            this.password = data["password"];
            this.tlFullName = data["tlFullName"];
            this.tlsubbrid = data["tlsubbrid"];
            this.brancH_NAME = data["brancH_NAME"];
            this.brancH_TYPE = data["brancH_TYPE"];
            this.roleName = data["roleName"];
            this.emailAddress = data["emailAddress"];
            this.roles = data["roles"];
            this.rolE_ID = data["rolE_ID"];
            this.email = data["email"];
            this.address = data["address"];
            this.phone = data["phone"];
            this.autH_STATUS = data["autH_STATUS"];
            this.markeR_ID = data["markeR_ID"];
            this.autH_ID = data["autH_ID"];
            this.approvE_DT = data["approvE_DT"] ? moment(data["approvE_DT"].toString()) : <any>undefined;
            this.isapprove = data["isapprove"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.isfirsttime = data["isfirsttime"];
            this.secuR_CODE = data["secuR_CODE"];
            this.totalCount = data["totalCount"];
            this.rolE_ID_STRING = data["rolE_ID_STRING"];
            this.top = data["top"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): TLUSER_GETBY_BRANCHID_ENTITY {
        data = typeof data === 'object' ? data : {};
        let result = new TLUSER_GETBY_BRANCHID_ENTITY();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tlid"] = this.tlid;
        data["tlnanme"] = this.tlnanme;
        data["password"] = this.password;
        data["tlFullName"] = this.tlFullName;
        data["tlsubbrid"] = this.tlsubbrid;
        data["brancH_NAME"] = this.brancH_NAME;
        data["brancH_TYPE"] = this.brancH_TYPE;
        data["roleName"] = this.roleName;
        data["emailAddress"] = this.emailAddress;
        data["roles"] = this.roles;
        data["rolE_ID"] = this.rolE_ID;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["autH_STATUS"] = this.autH_STATUS;
        data["markeR_ID"] = this.markeR_ID;
        data["autH_ID"] = this.autH_ID;
        data["approvE_DT"] = this.approvE_DT ? this.approvE_DT.toISOString() : <any>undefined;
        data["isapprove"] = this.isapprove;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["isfirsttime"] = this.isfirsttime;
        data["secuR_CODE"] = this.secuR_CODE;
        data["totalCount"] = this.totalCount;
        data["rolE_ID_STRING"] = this.rolE_ID_STRING;
        data["top"] = this.top;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }
}

export interface ITLUSER_GETBY_BRANCHID_ENTITY {
    tlid: string | undefined;
    tlnanme: string | undefined;
    password: string | undefined;
    tlFullName: string | undefined;
    tlsubbrid: string | undefined;
    brancH_NAME: string | undefined;
    brancH_TYPE: string | undefined;
    roleName: string | undefined;
    emailAddress: string | undefined;
    roles: string | undefined;
    rolE_ID: number | undefined;
    email: string | undefined;
    address: string | undefined;
    phone: string | undefined;
    autH_STATUS: string | undefined;
    markeR_ID: string | undefined;
    autH_ID: string | undefined;
    approvE_DT: moment.Moment | undefined;
    isapprove: string | undefined;
    birthday: moment.Moment | undefined;
    isfirsttime: string | undefined;
    secuR_CODE: string | undefined;
    totalCount: number | undefined;
    rolE_ID_STRING: string | undefined;
    top: number | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    mode!: string | undefined;
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mode = data["mode"];
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mode"] = this.mode;
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    mode: string | undefined;
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number;
    y!: number;
    width!: number;
    height!: number;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number;
    y: number;
    width: number;
    height: number;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class UPLOAD_W_T_RESULT implements IUPLOAD_W_T_RESULT {
    result!: string | undefined;
    message!: string | undefined;
    cM_ATTACH_FILE_ENTITY!: CM_ATTACH_FILE_ENTITY;

    constructor(data?: IUPLOAD_W_T_RESULT) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.message = data["message"];
            this.cM_ATTACH_FILE_ENTITY = data["cM_ATTACH_FILE_ENTITY"] ? CM_ATTACH_FILE_ENTITY.fromJS(data["cM_ATTACH_FILE_ENTITY"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UPLOAD_W_T_RESULT {
        data = typeof data === 'object' ? data : {};
        let result = new UPLOAD_W_T_RESULT();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["message"] = this.message;
        data["cM_ATTACH_FILE_ENTITY"] = this.cM_ATTACH_FILE_ENTITY ? this.cM_ATTACH_FILE_ENTITY.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUPLOAD_W_T_RESULT {
    result: string | undefined;
    message: string | undefined;
    cM_ATTACH_FILE_ENTITY: CM_ATTACH_FILE_ENTITY;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string | undefined;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    passwordRepeat!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;
    isEmailConfirmed!: boolean;
    subbrId!: string | undefined;
    deP_ID!: string | undefined;
    markerId!: string | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.passwordRepeat = data["passwordRepeat"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.subbrId = data["subbrId"];
            this.deP_ID = data["deP_ID"];
            this.markerId = data["markerId"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["passwordRepeat"] = this.passwordRepeat;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["subbrId"] = this.subbrId;
        data["deP_ID"] = this.deP_ID;
        data["markerId"] = this.markerId;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string | undefined;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    passwordRepeat: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
    isEmailConfirmed: boolean;
    subbrId: string | undefined;
    deP_ID: string | undefined;
    markerId: string | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    subbrName!: string | undefined;
    deptName!: string | undefined;
    phoneNumber!: string | undefined;
    authStatusName!: string | undefined;
    authStatus!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    markerId!: string | undefined;
    creationTime!: moment.Moment;
    isChecked!: boolean | undefined;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.subbrName = data["subbrName"];
            this.deptName = data["deptName"];
            this.phoneNumber = data["phoneNumber"];
            this.authStatusName = data["authStatusName"];
            this.authStatus = data["authStatus"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.markerId = data["markerId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isChecked = data["isChecked"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["subbrName"] = this.subbrName;
        data["deptName"] = this.deptName;
        data["phoneNumber"] = this.phoneNumber;
        data["authStatusName"] = this.authStatusName;
        data["authStatus"] = this.authStatus;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["markerId"] = this.markerId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isChecked"] = this.isChecked;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    subbrName: string | undefined;
    deptName: string | undefined;
    phoneNumber: string | undefined;
    authStatusName: string | undefined;
    authStatus: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    markerId: string | undefined;
    creationTime: moment.Moment;
    isChecked: boolean | undefined;
    id: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number;
    defaultAccountLockoutSeconds!: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number;
    defaultAccountLockoutSeconds: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    taxNo!: string | undefined;
    subbrId!: string | undefined;
    branchName!: string | undefined;
    deP_ID!: string | undefined;
    deP_NAME!: string | undefined;
    branchCode!: string | undefined;
    profilePicture!: GetProfilePictureOutput;
    branch!: IUserLoginBranch;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.taxNo = data["taxNo"];
            this.subbrId = data["subbrId"];
            this.branchName = data["branchName"];
            this.deP_ID = data["deP_ID"];
            this.deP_NAME = data["deP_NAME"];
            this.branchCode = data["branchCode"];
            this.profilePicture = data["profilePicture"] ? GetProfilePictureOutput.fromJS(data["profilePicture"]) : <any>undefined;
            this.branch = data["branch"] ? IUserLoginBranch.fromJS(data["branch"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["taxNo"] = this.taxNo;
        data["subbrId"] = this.subbrId;
        data["branchName"] = this.branchName;
        data["deP_ID"] = this.deP_ID;
        data["deP_NAME"] = this.deP_NAME;
        data["branchCode"] = this.branchCode;
        data["profilePicture"] = this.profilePicture ? this.profilePicture.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    taxNo: string | undefined;
    subbrId: string | undefined;
    branchName: string | undefined;
    deP_ID: string | undefined;
    deP_NAME: string | undefined;
    branchCode: string | undefined;
    profilePicture: GetProfilePictureOutput;
    branch: IUserLoginBranch;
    id: number;
}

export class UserLoginSettingEditDto implements IUserLoginSettingEditDto {
    loginMethod!: string | undefined;
    ldapServerName!: string | undefined;
    adfsWtrealm!: string | undefined;
    adfsMetadataAddress!: string | undefined;
    emailActivationEnable!: boolean | undefined;
    fogotPasswordEnable!: boolean | undefined;

    constructor(data?: IUserLoginSettingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loginMethod = data["loginMethod"];
            this.ldapServerName = data["ldapServerName"];
            this.adfsWtrealm = data["adfsWtrealm"];
            this.adfsMetadataAddress = data["adfsMetadataAddress"];
            this.emailActivationEnable = data["emailActivationEnable"];
            this.fogotPasswordEnable = data["fogotPasswordEnable"];
        }
    }

    static fromJS(data: any): UserLoginSettingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginSettingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginMethod"] = this.loginMethod;
        data["ldapServerName"] = this.ldapServerName;
        data["adfsWtrealm"] = this.adfsWtrealm;
        data["adfsMetadataAddress"] = this.adfsMetadataAddress;
        data["emailActivationEnable"] = this.emailActivationEnable;
        data["fogotPasswordEnable"] = this.fogotPasswordEnable;
        return data; 
    }
}

export interface IUserLoginSettingEditDto {
    loginMethod: string | undefined;
    ldapServerName: string | undefined;
    adfsWtrealm: string | undefined;
    adfsMetadataAddress: string | undefined;
    emailActivationEnable: boolean | undefined;
    fogotPasswordEnable: boolean | undefined;
}

export class UserMenu implements IUserMenu {
    name!: string | undefined;
    displayName!: string | undefined;
    customData!: any | undefined;
    items!: UserMenuItem[] | undefined;

    constructor(data?: IUserMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.customData = data["customData"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenu {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["customData"] = this.customData;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserMenu {
    name: string | undefined;
    displayName: string | undefined;
    customData: any | undefined;
    items: UserMenuItem[] | undefined;
}

export class UserMenuItem implements IUserMenuItem {
    name!: string | undefined;
    icon!: string | undefined;
    displayName!: string | undefined;
    order!: number;
    url!: string | undefined;
    customData!: any | undefined;
    target!: string | undefined;
    isEnabled!: boolean;
    isVisible!: boolean;
    items!: UserMenuItem[] | undefined;

    constructor(data?: IUserMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.displayName = data["displayName"];
            this.order = data["order"];
            this.url = data["url"];
            this.customData = data["customData"];
            this.target = data["target"];
            this.isEnabled = data["isEnabled"];
            this.isVisible = data["isVisible"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["displayName"] = this.displayName;
        data["order"] = this.order;
        data["url"] = this.url;
        data["customData"] = this.customData;
        data["target"] = this.target;
        data["isEnabled"] = this.isEnabled;
        data["isVisible"] = this.isVisible;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserMenuItem {
    name: string | undefined;
    icon: string | undefined;
    displayName: string | undefined;
    order: number;
    url: string | undefined;
    customData: any | undefined;
    target: string | undefined;
    isEnabled: boolean;
    isVisible: boolean;
    items: UserMenuItem[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    id!: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class UserNotificationInfo implements IUserNotificationInfo {
    tenantId!: number | undefined;
    userId!: number;
    tenantNotificationId!: string;
    state!: UserNotificationState;
    creationTime!: moment.Moment;
    id!: string;

    constructor(data?: IUserNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.tenantNotificationId = data["tenantNotificationId"];
            this.state = data["state"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["tenantNotificationId"] = this.tenantNotificationId;
        data["state"] = this.state;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotificationInfo {
    tenantId: number | undefined;
    userId: number;
    tenantNotificationId: string;
    state: UserNotificationState;
    creationTime: moment.Moment;
    id: string;
}

export class UserNotificationInfoWithNotificationInfo implements IUserNotificationInfoWithNotificationInfo {
    userNotification!: UserNotificationInfo;
    notification!: TenantNotificationInfo;

    constructor(data?: IUserNotificationInfoWithNotificationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNotification = data["userNotification"] ? UserNotificationInfo.fromJS(data["userNotification"]) : <any>undefined;
            this.notification = data["notification"] ? TenantNotificationInfo.fromJS(data["notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserNotificationInfoWithNotificationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotificationInfoWithNotificationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNotification"] = this.userNotification ? this.userNotification.toJSON() : <any>undefined;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserNotificationInfoWithNotificationInfo {
    userNotification: UserNotificationInfo;
    notification: TenantNotificationInfo;
}

export enum UserNotificationState {
    Unread = 0, 
    Read = 1, 
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class WfDefinitionParam implements IWfDefinitionParam {
    functioN_ID!: string | undefined;
    reF_ID!: string | undefined;
    menU_ID!: number | undefined;
    amt!: number | undefined;
    wF_VALUE!: string | undefined;
    useR_ID!: string | undefined;

    constructor(data?: IWfDefinitionParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.functioN_ID = data["functioN_ID"];
            this.reF_ID = data["reF_ID"];
            this.menU_ID = data["menU_ID"];
            this.amt = data["amt"];
            this.wF_VALUE = data["wF_VALUE"];
            this.useR_ID = data["useR_ID"];
        }
    }

    static fromJS(data: any): WfDefinitionParam {
        data = typeof data === 'object' ? data : {};
        let result = new WfDefinitionParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["functioN_ID"] = this.functioN_ID;
        data["reF_ID"] = this.reF_ID;
        data["menU_ID"] = this.menU_ID;
        data["amt"] = this.amt;
        data["wF_VALUE"] = this.wF_VALUE;
        data["useR_ID"] = this.useR_ID;
        return data; 
    }
}

export interface IWfDefinitionParam {
    functioN_ID: string | undefined;
    reF_ID: string | undefined;
    menU_ID: number | undefined;
    amt: number | undefined;
    wF_VALUE: string | undefined;
    useR_ID: string | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string] : string; };
    stripe!: { [key: string] : string; };

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; };
    stripe: { [key: string] : string; };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}